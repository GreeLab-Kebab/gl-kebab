import EventEmitter from 'eventemitter3';
import hearing from 'hearing-aid';
import yeast from 'yeast';

/**
 * The registry of current
 *
 * @type {Object}
 * @private
 */
export const registry = Object.create(null);

/**
 * A distributed Event listener to offload event handling.
 *
 * @constructor
 * @param {Mixed} api The event interface we need to listen upon.
 * @public
 */
export default class EventDist extends EventEmitter {
    constructor(api) {
        super();

        //
        // We default to an EventEmitter in the case where no API is provided. This
        // allows the module to operate as intended in environments where no native
        // event system (like browsers) is provided.
        //
        this._api = api || new EventEmitter();
        this._hearing = {};
        this._id = yeast();

        registry[this._id] = this;
    }

    /**
     * Assign a listener for a given event.
     *
     * @param {String} event Name of the event we want to listen upon.
     * @param {Function} fn Callback event handler.
     * @param {Mixed} context Scope of the component.
     * @returns {EventDist} Chaining purposes.
     * @public
     */
    on(event) {
        if (!(event in this._hearing)) {
            this._hearing[event] = hearing(this._api, event, (...args) => {
                this.emit(event, ...args);
            });
        }

        this.addListener(...arguments);
        return this;
    }

    /**
     * Remove an assigned listener.
     *
     * @param {String} event Name of the event we want to listen upon.
     * @returns {EventDist} Chaining purposes.
     * @public
     */
    off(event) {
        this.removeListener(...arguments);

        if (!this.listeners(event).length) {
            //
            // Make sure that we actually clean up the DOM listeners if we have no
            // more event listeners assigned internally.
            //
            if (event in this._hearing) {
                this._hearing[event]();

                delete this._hearing[event];
            }
        }

        return this;
    }

    /**
     * Listen to the event once. Remove the listener after.
     *
     * @param {String} event Name of the event we want to listen upon.
     * @param {Function} fn Callback event handler.
     * @param {Mixed} context Scope of the component.
     * @returns {EventDist} Chaining purposes.
     * @api public
     */
    once(event, fn, context) {
        return this.on(event, function dispatch(e) {
            this.off(event, dispatch, context); // eslint-disable-line no-invalid-this
            fn(e);
        });
    }

    /**
     * Destroy the current instance.
     *
     * @returns {Boolean} Indication of first destruction.
     * @public
     */
    destroy() {
        if (!this._hearing) return false;

        delete registry[this._id];

        Object.keys(this._hearing).forEach((event) => {
            this._hearing[event]();
        });

        this._hearing = this._api = this._id = null;
        this.removeAllListeners();

        return true;
    }
}



// WEBPACK FOOTER //
// ./node_modules/eventdist/index.js