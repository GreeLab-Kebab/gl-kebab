import React from 'react';
import PropTypes from 'prop-types';
import Component, {
    breakpoints
} from '@ux/component';

const blockBreakpoints = ['mobile', 'phablet', 'tablet'];

/**
 * UXCore based ButtonSet. A ButtonSet will always start with
 * an initial state that does not set the `ux-btn-block` class.
 *
 * @displayName Button Set
 * @class ButtonSet
 * @public
 */
export default class ButtonSet extends Component {
    constructor() {
        super();

        //
        // Set blockBreakpoints on this instance so that
        // it is accessible externally.
        //
        this.blockBreakpoints = blockBreakpoints.slice();
        this.state.block = false;
    }

    /**
     * If the breakpoint is supported, checkHeights,
     * otherwise, set block as false.
     *
     * @public
     */
    checkBreakpoint() {
        if (~this.blockBreakpoints.indexOf(breakpoints.breakpoint)) {
            this.checkHeights();
            return;
        }

        this._setBlockState(false);
    }

    /**
     * If set is taller than shortest button,
     * set block as true
     *
     * @public
     */
    checkHeights() {
        const btnSetHeight = this.buttonSet.clientHeight;

        //
        // Find the height of each button & put it in an array.
        // Remark: not using `Array.from` to support IE.
        //
        const btns = [];
        const children = this.buttonSet.children;
        for (let i = 0; i < children.length; i++) {
            btns.push(children[i]);
        }

        const btnHeights = btns.map(function(child) {
            const styles = window.getComputedStyle(child);
            return child.offsetHeight +
                parseInt(styles.marginTop, 10) +
                parseInt(styles.marginBottom, 10);
        });
        this._setBlockState(btnSetHeight > Math.min(...btnHeights));
    }

    /**
     * Only setState if result doesn't match current state
     *
     * @param {boolean} target If true, sets 'ux-btn-block' class.
     * @private
     */
    _setBlockState(target) {
        if (this.state.blockÂ  !== target) {
            this.setState({
                block: target
            });
        }
    }

    /**
     * Once the ButtonSet has been rendered, listen to the
     * appropriate changes in Window size
     *
     * @private
     */
    componentDidMount() {
        //
        // List breakpoints that require listening
        //
        this.breakpoint('mobile', 'phablet', 'tablet', 'desktop', 'large');
        this.checkBreakpoint();
    }

    /**
     * When a ButtonSet is rerendered, check to see if the blocking
     * state needs to be updated.
     *
     * @private
     */
    componentDidUpdate() {
        this.checkBreakpoint();
    }

    /**
     * Remove the eventListeners of breakpoints.
     *
     * @private
     */
    componentWillUnmount() {
        this.breakup();
    }

    /**
     * Render the ButtonSet Component.
     *
     * @returns {ReactElement} ButtonSet element.
     * @private
     */
    render() {
        const classNames = this.classNames('ux-btn-set', {
            'ux-btn-block': this.state.block,
            'ux-btn-split': this.props.split
        }, this.props.className);

        return ( <
            div className = {
                classNames
            }
            ref = {
                bSet => {
                    this.buttonSet = bSet;
                }
            }
            role = 'group' > {
                React.Children.map(this.props.children, child => {
                    if (!child) {
                        return null;
                    }
                    return React.cloneElement(child, {
                        className: this.classNames('ux-btn-set-item', child.props.className)
                    });
                })
            } <
            /div>
        );
    }
}

/**
 * Optional properties: split defines if the ButtonSet's
 * children should split to multiple lines or not.
 *
 * @enum {Object} expected types of properties.
 * @public
 */
ButtonSet.propTypes = {
    /** Classes to set on the element */
    className: PropTypes.string,
    /** Defines whether child elements too wide to fit on screen should drop down to the next line*/
    split: PropTypes.bool,
    /** Child elements to be included in the Button Set*/
    children: PropTypes.node
};



// WEBPACK FOOTER //
// ./node_modules/@ux/button-set/index.js