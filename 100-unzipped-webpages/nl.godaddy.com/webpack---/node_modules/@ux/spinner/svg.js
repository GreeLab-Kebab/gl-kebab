import vars from './definitions';
import platform from 'platform-specific';
import {
    Svg,
    Circle,
    Path
} from 'svgs';
import React, {
    Component
} from 'react';
import {
    tween
} from '@godaddy/shifty/tweenable';
import Fulfilling from 'fulfilling';
import PropTypes from 'prop-types';
import design from './design';
import ms from 'millisecond';


/**
 * SVG based Spinner
 *
 * @displayName SVG Spinner
 * @class Spinner
 * @public
 */
export default class Spinner extends Component {
    constructor() {
        super(...arguments);

        this.duration = ms(vars.uxSpinnerDuration);
        this.mounted = false;
        this.state = {
            start: 0,
            end: 0
        };
    }

    /**
     * They key frames of the animation that we iterate over.
     *
     * @returns {Array} Animation specification
     * @private
     */
    keyframes() {
        return [{
            duration: 25,
            start: 0,
            end: 90
        }, {
            duration: 25,
            start: 90,
            end: 270
        }, {
            duration: 25,
            start: 270,
            end: 360
        }, {
            duration: 25,
            start: 360,
            end: 360
        }];
    }

    /**
     * Start the animation when the component is mounted.
     *
     * @returns {void}
     * @private
     */
    componentDidMount() {
        this.mounted = true;
        this.animate();
    }

    /**
     * Tricky part here, we could unmount mid-animation frame so we need to set
     * a flag to instruct our animation sequence to stop iterating through our
     * animation key frames and the setState calls
     *
     * @private
     */
    componentWillUnmount() {
        this.mounted = false;
    }

    /**
     * Representation of a single animation cycle
     *
     * @returns {void}
     * @private
     */
    animate() {
        if (!this.mounted) return;

        const self = this;
        const frames = this.keyframes();
        const duration = this.duration;
        const initial = {
            start: 0,
            end: 0
        };

        /**
         * Every step of the animation is an setState for React so we can animate
         * during the render step
         *
         * @param {Object} progress Progress of the animation
         * @private
         */
        const setState = (progress) => {
            if (!this.mounted) return;

            this.setState(progress);
        };

        (function next() {
            const frame = frames.shift();

            if (!self.mounted) return;
            if (!frame) return self.animate();

            tween({
                promise: Fulfilling,

                from: initial,
                to: {
                    start: frame.start,
                    end: frame.end
                },
                duration: duration / 100 * ms(frame.duration),
                step: setState
            }).then(() => {
                initial.start = frame.start;
                initial.end = frame.end;

                next();
            });
        }());
    }

    /**
     * Calculate the correct coordinates for the arc.
     *
     * @param {Number} x Center x
     * @param {Number} y Center y
     * @param {Number} radius Radius
     * @param {Number} angle Angle in degrees
     * @returns {Object} x/y positions
     * @private
     */
    polarToCartesian(x, y, radius, angle) {
        const angledRad = (angle - 90) * Math.PI / 180.0;

        return {
            x: x + (radius * Math.cos(angledRad)),
            y: y + (radius * Math.sin(angledRad))
        };
    }

    /**
     * Generate an arc based on given start x/y and start/end angle
     *
     * @param {Number} center position of the center
     * @param {Number} radius Radius of the circle
     * @param {Number} startDeg Starting degree of the arc
     * @param {Number} endDeg Ending degree of the arc
     * @returns {String} The generated path
     * @private
     */
    arc(center, radius, startDeg, endDeg) {
        const start = this.polarToCartesian(center, center, radius, endDeg);
        const end = this.polarToCartesian(center, center, radius, startDeg);
        const largeArcFlag = endDeg - startDeg <= 180 ? '0' : '1';

        return [
            'M', start.x, start.y,
            'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y
        ].join(' ');
    }

    /**
     * Renders the component.
     *
     * @returns {ReactElement} Rendered Spinner element.
     * @private
     */
    render() {
        const {
            inline,
            shade,
            size
        } = this.props;
        const styles = design(size, shade);
        const {
            width,
            strokeWidth
        } = styles.size;
        const center = width / 2;
        const radius = center - strokeWidth;
        const d = this.arc(center, radius, this.state.start, this.state.end);
        const style = {};

        //
        // Notable difference in react-native and browser svg is that browsers
        // render the svg in inline by default while svg's on react-native are block
        // level because layout needs is controlled with flex-boxes.
        //
        if (platform.type !== 'react-native' && inline) {
            style.display = 'block';
        }

        return ( <
            Svg width = {
                width
            }
            height = {
                width
            }
            viewBox = {
                `0 0 ${width} ${width}`
            }
            style = {
                style
            } >
            <
            Circle { ...styles.circle
            }
            r = {
                radius
            }
            cx = {
                center
            }
            cy = {
                center
            }
            /> <
            Path { ...styles.path
            }
            d = {
                d
            }
            /> <
            /Svg>
        );
    }
}

Spinner.propTypes = {
    /** Determines whether the spinner will be displayed inline or not */
    inline: PropTypes.bool,
    /** The label for the spinner */
    label: PropTypes.node,
    /** Defines the shade of the spinner (light, primary, or dark) */
    shade: PropTypes.string.isRequired,
    /** Defines the size of the spinner (sm, md, or lg) */
    size: PropTypes.string.isRequired
};

/**
 * Default properties.
 *
 * @type {Object}
 * @private
 */
Spinner.defaultProps = {
    shade: 'primary', // Default color.
    size: 'md' // Default size.
};



// WEBPACK FOOTER //
// ./node_modules/@ux/spinner/svg.js