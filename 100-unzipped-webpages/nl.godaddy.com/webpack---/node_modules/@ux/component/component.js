import PropTypes from 'prop-types';
import breakpoints from './breakpoints';
import obassign from 'object-assign';
import React, {
    Component,
    createContext
} from 'react';
import EventDist from 'eventdist';
import debug from 'diagnostics';
import name from 'fn.name';
import addhoc from 'addhoc';

/**
 * We want to be able to execute this code in a non DOM environment as well so
 * we optionally scout the document.body and fallback to polyfill. As EventDist
 * doesn't care about the event interface provided we can just provide it with
 * an EventEmitter instance.
 *
 * NOTE: This should only check if we are in a browser like environment as it
 * should trigger for JSDOM and real browsers.
 *
 * @private
 */
const hasDOM = typeof document !== 'undefined';
export const target = hasDOM ? window : {};

/**
 * Our EventDist on the window element so we can listen to window manipulation
 *
 * @type {EventDist}
 * @public
 */
export const eventdist = new EventDist(hasDOM && target);

/**
 * React context to allow sharing of a single EventDist instance among components
 *
 * @const {React.Context}
 * @public
 * @example
 * import { EventDistContext } from '@ux/component';
 *
 * export default class MyApplicationComponent extends React.Component {
 *   constructor(...args) {
 *     this.eventdist = new EventDist(window);
 *   }
 *   render() {
 *     return (
 *       <EventDistContext.Provider value={ this.eventdist }>
 *         // ...
 *         <SomeComponentThatUsesWithEventDist />
 *         // ...
 *       </EventDistContext.Provider>
 *     )
 *   }
 * }
 */
export const EventDistContext = createContext(null);

/**
 * Higher-Order Component function to provide a shared eventdist instance.
 *
 * @param {React.Component} WrappedComponent The component to be augmented with a shared eventdist instance
 * @returns {React.Component} A wrapped component class that provides a `eventdist` object as a prop
 * @public
 * @example
 * import Component, { withEventDistContext, EventDistShape } from '@ux/component';
 * class MyComponent extends Component {
 *   componentDidMount() {
 *     this.eventdist...
 *   }
 * }
 * MyComponent.propTypes = {
 *   ...EventDistShape
 * };
 *
 * export default withEventDistContext(MyComponent);
 */
export const withEventDistContext = addhoc(getWrappedComponent =>
        <
        EventDistContext.Consumer > {
            sharedEventDist => getWrappedComponent({
                eventdist: sharedEventDist
            })
        } <
        /EventDistContext.Consumer>, 'WithEventDistContext');

        /**
         * Shape of props added to components wrapped with {@link withEventDistContext}.
         *
         * @const {Object} EventDistShape
         * @public
         */
        export const EventDistShape = {
            eventdist: PropTypes.object
        };

        /**
         * The default component that extends React.Component so we can force the
         * Component interface and prevent React.createClass usage.
         * @displayName Shared Component
         * @constructor
         * @public
         */
        export default class SharedComponent extends Component {
            constructor(props, ...args) {
                super(props, ...args);

                this._name = name(this).toLowerCase();
                this.debug = debug('ux:component:' + this._name);
                this.eventdist = props && props.eventdist || eventdist;

                this.points = [];
                this.state = {
                    viewport: breakpoints.viewport(),
                    breakpoint: breakpoints.breakpoint
                };

                this.on.bind(this);
                this.off.bind(this);
                this.once.bind(this);
                this.breakup.bind(this);
                this.breakpoint.bind(this);
            }

            /**
             * Trigger a re-render of the component when a new breakpoint has reached.
             * This method should only be called once for the lifecycle of a component as
             * you don't want to add multiple listeners for the same event as that would
             * lead to multiple `setState` calls.
             *
             * @returns {Component} Returns self for chaining purposes.
             * @public
             */
            breakpoint(...points) {
                this.points.push(...points);
                this._resize();

                return this.eventdist.on('breakpoint:changed', this._resize, this);
            }

            /**
             * The resize handler.
             *
             * @param {String} breakpoint Current breakpoint.
             * @private
             */
            _resize(breakpoint) {
                const points = this.points;
                if (!points || !points.length) return;

                //
                // Find the nearest registered point by minimal distance from the actual width.
                //
                if (!~points.indexOf(breakpoint)) {
                    const distances = points.map(point => Math.abs(breakpoints.compare(point, 'width')));
                    breakpoint = points[distances.indexOf(Math.min(...distances))];
                }

                //
                // Check if the breakpoint is actually different Breakpoint might have changed based on nearest algorithm.
                //
                if (this.state.breakpoint === breakpoint) return;

                this.debug('updating state as breakpoint changed to %s', breakpoint);
                this.setState({
                    viewport: breakpoints.viewport(),
                    breakpoint: breakpoint
                });
            }

            /**
             * Un-attach our mounted handlers.
             *
             * @returns {Component} Returns self for chaining purposes.
             * @public
             */
            breakup(...points) {
                //
                // If there are no points provided assume that assigned listeners need to be
                // removed.
                //
                if (!points.length) points = this.points;

                this.points = this.points.filter(point => {
                    return !~points.indexOf(point);
                });


                if (!this.points.length) {
                    this.eventdist.off('breakpoint:changed', this._resize, this);
                }

                return this;
            }

            /**
             * Generate a persistent id so it will be same every single time so it can
             * still be used to link to certain parts in the form. If there is already an
             * `id` provided it will fallback to that.
             *
             * We want to follow the HTML4 specification here to ensure that we generate
             * valid id attributes for every single doc type. HTML5 is less strict about
             * this as it only disallows spaces to be present in the attribute.
             *
             * @param {String} key Fallback key to retrieve from props.
             * @returns {String} The persistent but semi unique id.
             * @public
             */
            id(key) {
                const props = this.props;
                let value = (props.id || props[key] || this._name).toString().trim();

                // If there are non-ASCII characters, use encodeURIComponent to deterministically replace them
                // eslint-disable-next-line no-control-regex
                value = value.replace(/[^\x00-\x7F]/g, char => {
                    return encodeURIComponent(char).replace('%', ':');
                });

                //
                // An id attribute must start with A-Za-z char. If this is not the case
                // we're going to prefix it. Just for clarity we prefix it with the word
                // `id-`
                //
                if (!/^[A-Za-z]/.test(value)) value = 'id-' + value;

                // eslint-disable-next-line no-useless-escape
                return value.replace(/[^A-Za-z\:\;\-\_0-9\.]+/g, '-');
            }

            /**
             * A polyfill for Object.assign.
             *
             * @param {Arguments} arguments Objects that should be assigned.
             * @returns {Object} New object in memory with cloned properties.
             * @public
             */
            assign() {
                return obassign.apply(this, arguments);
            }

            /**
             * Check if breakpoint is mobile.
             *
             * @returns {Boolean} Mobile or not.
             * @public
             */
            get isMobile() {
                return !!~['mobile', 'phablet'].indexOf(this.state.breakpoint);
            }

            /**
             * Assign an new event listener to the body element so we can listen for
             * key presses and other events.
             *
             * @param {String} event Event name.
             * @param {Function} fn Completion callback function.
             * @returns {Component} Returns self for chaining purposes.
             * @public
             */
            on(event, fn) {
                this.eventdist.on(event, fn, this);

                return this;
            }

            /**
             * Remove an assigned event listener of the body element. This will only
             * remove previously assigned listeners through the `on` event..
             *
             * @param {String} event Event name.
             * @param {Function} fn Completion callback function, optional.
             * @returns {Component} Returns self for chaining purposes.
             * @public
             */
            off(event, fn) {
                this.eventdist.off(event, fn, this);
                return this;
            }

            /**
             * Assign an new event listener to the body element that we listen to once.
             *
             * @param {String} event Event name.
             * @param {Function} fn Completion callback function.
             * @returns {Component} Returns self for chaining purposes.
             * @public
             */
            once(event, fn) {
                this.eventdist.once(event, fn, this);

                return this;
            }
        }

        SharedComponent.propTypes = {
            ...EventDistShape
        };



        // WEBPACK FOOTER //
        // ./node_modules/@ux/component/component.js