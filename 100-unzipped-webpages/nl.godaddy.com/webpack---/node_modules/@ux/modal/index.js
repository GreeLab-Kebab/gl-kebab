/* eslint-disable jsx-a11y/no-static-element-interactions */
import listen from 'hearing-aid';
import React from 'react';
import {
    withNamespace,
    NamespaceShape
} from '@ux/namespace-component';
import {
    withEventDistContext
} from '@ux/component';
import Base from './modal';
import Header from './modal-header';
import Nav from './modal-nav';
import Body from './modal-body';
import Footer from './modal-footer';

/**
 * Placeholder component to handle the rendering of the modal dialog.
 *
 * @constructor
 * @public
 */
class ModalComponent extends Base {
    constructor(props = {}) {
        super(...arguments);

        this.hideHandle = null;
        this.backdrop = null;
        this.listener = null;
        this.startTarget = null;
        this.target = props.target;
        this.onKeyDown = this.keydown.bind(this);
    }

    /**
     * The component is mounted in the DOM.
     *
     * @private
     */
    componentDidMount() {
        if (this.state.open === false) {
            return;
        }

        const html = this.html = this.target || document.documentElement;
        const target = this.target = this.target || document.body;

        //
        // Store the previous element so we can return focus after modal dialog closes.
        //
        this.previousElement = document.activeElement;
        while (this.previousElement && typeof(this.previousElement.focus) !== 'function') {
            this.previousElement = this.previousElement.parentElement;
        }

        if (this.modalDialog) {
            this.dialogButton = this.modalDialog.querySelector('.modal button[data-action="close"]');
        }

        this.on('keydown', this.keydown);

        if (this.modalDialog) {
            const focusableEls = this.modalDialog.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex]:not([tabindex="-1"])');
            this.focusableEls = Array.prototype.slice.call(focusableEls);
            this.firstFocusableEl = this.focusableEls[0];
            this.lastFocusableEl = this.focusableEls[this.focusableEls.length - 1];
        }

        if (this.dialogButton) {
            this.dialogButton.focus();
        }

        //
        // Check if we need to render the backdrop correctly.
        //
        if (this.backdrop || this.props.backdrop === false) return;

        //
        // Generate the placeholder element which is appended to the DOM so we can
        // generate the modal dialog content somewhere else than in our rendered
        // context.
        //
        const backdrop = this.backdrop = document.createElement('div');

        backdrop.className = this.classNames(this.namespace('modal-backdrop'), {
            [this.namespace('fade')]: this.props.animate !== false
        });

        target.appendChild(backdrop);
        this.listener = listen(backdrop, 'click', this.onBackgroundClick.bind(this));

        //
        // Store the height of the target and restrict it to the `innerHeight` of the window. Add className
        // to the target to indicate that the modal dialog is open. This className ensures that the correct
        // scroll bars are added when we have content that is overflowing.
        //
        const offsetY = window.pageYOffset;
        const style = target.style;

        this.prev = {
            height: style.height.length ? window.getComputedStyle(target).height : ''
        };

        style.height = (window.innerHeight + offsetY) + 'px';

        html.className = this.classNames(html.className, this.namespace('modal-open'));

        //
        // Now that the element is appended to the body we can fade the backdrop in
        // IF there is reason to animate.
        //
        if (this.props.animate !== false) {
            backdrop.className = this.classNames(backdrop.className, this.namespace('show'));
        }

        this.insideMouseDown = this.on('mousedown', (e) => {
            this.startTarget = e.target;
        });

        //
        // We dont want to suppress clicks inside the modal body
        // otherwise things that use @ux/component.outside() will never get the event
        // but we do want to close the modal if the event is outside the modal body
        //
        this.hideHandle = this.outside('mouseup', (event, fn) => {
            if (event.target !== this.modalOuter) return;
            if (event.target !== this.startTarget) return;

            if (this.props.disableAutoClose) return;

            this.hideHandle = null;
            this.off('click', fn);
            this.close();
        }, this.modalDialog);
    }

    /**
     * Remove the dialog from the DOM.
     *
     * @public
     */
    close() {

        //
        // Return early if the dialog is not open. This prevents the onClose handler
        // from being called twice if the modal is closed normally, and then the consumer
        // of the modal component removes the component itself from the DOM.
        //
        if (this.state.open === false) {
            return;
        }

        const {
            html,
            target,
            prev
        } = this;

        this.off('keydown', this.keydown);

        if (this.hideHandle) {
            this.off('click', this.hideHandle);
            this.hideHandle = null;
        }

        if (this.backdrop) {
            html.className = this.classNames(html.className, {
                [this.namespace('modal-open')]: false
            }) || '';

            target.style.height = prev.height;
            target.removeChild(this.backdrop);

            this.listener = null;
            this.backdrop = null;
        }

        if (this.previousElement) {
            this.previousElement.focus();
        }

        this.setState({
            open: false
        }, () => {
            //
            // Optionally call the close callback that has been provided to the modal
            // dialog.
            //
            if (typeof this.props.onClose === 'function') {
                this.props.onClose(this);
            }
        });
    }

    /**
     * Handle the Tab keydown. Do not allow tabbing in background and set focus.
     *
     * @private
     */
    handleForwardTab() {
        if (document.activeElement === this.lastFocusableEl) {
            event.preventDefault();
            this.firstFocusableEl.focus();
        }
    }

    /**
     * Handle the shift + Tab keydown. Do not allow tabbing in background and set focus.
     *
     * @private
     */
    handleBackwardTab() {
        if (document.activeElement === this.firstFocusableEl) {
            event.preventDefault();
            this.lastFocusableEl.focus();
        }
    }

    /**
     * Handle the closing of the dialog when the ESC key is pressed. Do not allow tabbing in background when modal is open.
     *
     * @param {Event} event DOM Event for the keydown handling.
     * @private
     */
    keydown(event) {
        if (event.key === 'Escape' && this.state.open && !this.props.disableAutoClose) {
            this.close();
        }

        if (event.key === 'Tab' && this.state.open) {
            if (this.focusableEls.length <= 1) {
                event.preventDefault();
            }

            if (event.shiftKey) {
                this.handleBackwardTab();
            } else {
                this.handleForwardTab();
            }

            if (this.lastFocusableEl && (this.lastFocusableEl.disabled || this.lastFocusableEl.tabIndex === -1)) {
                event.preventDefault();
                this.firstFocusableEl.focus();
            }
        }
    }

    /**
     * Render the modal dialog.
     *
     * @returns {React.DOM} Valid DOM.
     * @public
     */
    render() {
        const {
            state,
            props
        } = this;
        const titleForId = typeof props.title === 'string' ? props.title.replace(/[^a-z0-9_-]/ig, '') : Date.now().toString();
        const id = `${titleForId}-modal-dialog`;

        //
        // The user has closed the dialog, so we shouldn't render anything here. But
        // the render method of React expects something to be returned. The `null`
        // value is the only thing that works here.
        //
        if (state.open === false) {
            return null;
        }

        return ( <
            div onKeyDown = {
                this.onKeyDown
            }
            className = {
                this.namespace('modal', 'fade', 'show')
            } { ...this.show
            }
            ref = {
                r => {
                    this.modalOuter = r;
                }
            } >
            <
            div role = 'dialog'
            aria - label = {
                id
            }
            id = {
                id
            }
            className = {
                this.classNames(this.namespace('modal-dialog'), props.className)
            } >
            <
            div className = {
                this.namespace('modal-content')
            }
            ref = {
                r => {
                    this.modalDialog = r;
                }
            }
            style = {
                props.style
            } > {
                this.baseRender(Header, Nav, Body, Footer)
            } <
            /div> <
            /div> <
            /div>
        );
    }
}

ModalComponent.propTypes = {
    /** Common modal props */
    ...Base.propTypes,
    /** Namespace Consumer props */
    ...NamespaceShape
};

//
// Make importing easier by exposing the individual components to the Modal
// class.
//
const Modal = withEventDistContext(withNamespace(ModalComponent));
export default Modal;
Modal.Header = Header;
Modal.Nav = Nav;
Modal.Body = Body;
Modal.Footer = Footer;



// WEBPACK FOOTER //
// ./node_modules/@ux/modal/index.js