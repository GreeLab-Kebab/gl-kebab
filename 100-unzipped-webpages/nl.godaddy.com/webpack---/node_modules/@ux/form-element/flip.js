import {
    NamespaceConsumer,
    withNamespace,
    NamespaceShape
} from '@ux/namespace-component';
import {
    propTypes,
    defaultProps
} from './enums';
import PropTypes from 'prop-types';
import Fieldset from '@ux/fieldset';
import Button from '@ux/button';
import React from 'react';

/**
 * Renders a radio/checkbox element according to the design specifications.
 *
 * @displayName Flip (Radio / Checkbox) (Web)
 *
 * @class Flip
 * @private
 */
export class Flip extends NamespaceConsumer {
    /**
     * Render the actual component.
     *
     * @returns {React.DOM} The component.
     * @private
     */
    render() {
        const props = this.props;
        const grid = props.grid;

        var currentChecked = !!props.checked;
        if (props.design !== 'base' && typeof props.elements.input !== 'undefined') {
            currentChecked = props.elements.input.checked;
        }

        //
        // This forces the input element to be rendered as a correct checkbox/radio
        // element. If we're going inline, it requires a different class name.
        //
        let className = this.classNames({
            'sr-only': props.hideLabel,
            'form-control-label': !!grid.label,
            'form-check-label': !props.inline,
            'form-check-inline': props.inline,
            'disabled': props.disabled,
            'active': (props.design !== 'base' && currentChecked)
        }, {
            'has-danger': props.validates === false
        }, ['custom-control', `custom-${props.type}`]);

        if (props.design !== 'base') {
            className += ` btn ${Button.designs[props.design]}`;
        }

        className = this.classNames(
            grid.label,
            this.namespace(className)
        );

        const customIndicator = ( <
            span className = {
                this.namespace('custom-control-indicator')
            } > < /span>
        );

        const customDescription = ( <
            span className = {
                this.namespace('custom-control-description')
            } > {
                props.label
            } <
            /span>
        );

        const label = ( <
            label htmlFor = {
                props.id
            } // eslint-disable-line jsx-a11y/label-has-for
            ref = {
                r => {
                    props.elements.label = r;
                }
            }
            className = {
                className
            }
            id = {
                'label-' + props.id
            } > {
                props.input
            } {
                props.design === 'base' ? customIndicator : null
            } {
                props.design === 'base' ? customDescription : props.label
            } {
                props.notice
            } {
                props.error
            } <
            /label>
        );

        return ( <
            Fieldset proxy = {!!props.proxy
            } > {
                props.inline ? label : < div className = {
                        this.namespace('form-check')
                    } > {
                        label
                    } < /div> } <
                    /Fieldset>
            );
        }
    }

    /**
     * PropType validation
     *
     * @type {Object}
     * @private
     */
    Flip.propTypes = {
        ...NamespaceShape,
        ...propTypes.input,

        /** The design to use for the input, see @ux/button for design options */
        design: PropTypes.oneOf(Object.keys(Button.designs)),
        /** True if the element (radio or checkbox) is checked */
        checked: PropTypes.bool
    };

    /**
     * Properties for Flip, design is 'base' by default.
     *
     * @enum {Object} defaultProps
     * @public
     */
    Flip.defaultProps = {
        ...defaultProps.input,
        design: 'base'
    };

    export default withNamespace(Flip);



    // WEBPACK FOOTER //
    // ./node_modules/@ux/form-element/flip.js