import {
    withNamespace,
    NamespaceShape
} from '@ux/namespace-component';
import validateComponents from 'react-component-validator';
import React, {
    Fragment
} from 'react';
import Component, {
    withEventDistContext
} from '@ux/component';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import Base, {
    types
} from './dropdown';

//
// Import all child components.
//
import DropdownControl from './dropdown-control';
import DropdownDivider from './dropdown-divider';
import DropdownHeader from './dropdown-header';
import DropdownMenu, {
    alignmentTypes,
    autoAlignments,
    menuAlignmentPropType
} from './dropdown-menu';
import DropdownItem from './dropdown-item';

/**
 * Track of the current selected value with a hidden input element. Allowing
 * simple POST requests of forms.
 *
 * @class DropdownValue
 * @private
 */
class DropdownValue extends Component {
    render() {
        const allowedTypes = ['select', 'tripledot', 'custom'];
        if (!~allowedTypes.indexOf(this.props.type)) {
            return null;
        }

        return <input { ...this.props
        }
        type = 'hidden'
        readOnly / > ;
    }
}

/**
 * PropType validation
 *
 * @enum {Object} propTypes
 * @public
 */
DropdownValue.propTypes = {
    /** Type of dropdown */
    type: PropTypes.oneOf(types)
};

/**
 * Display a Dropdown that works standalone button, as select or multiselect.
 *
 * @displayName Dropdown (Web)
 * @class Dropdown
 * @extends React.Component
 * @public
 */
class DropdownComponent extends Base {
    constructor() {
        super(...arguments);
        this.hideHandle = null;
        this.selectItem = this.selectItem.bind(this);
        this.toggleBackground = this.toggleBackground.bind(this);
    }

    /**
     * Hide the dropdown if clicks are outside the dropdown itself, and select default selected
     *
     * @private
     */
    componentDidMount() {
        /* eslint react/no-find-dom-node: 0 */
        this.hideHandle = this.outside('click', this.hide, ReactDOM.findDOMNode(this.element));
    }

    /**
     * Remove the attached click event listener.
     *
     * @private
     */
    componentWillUnmount() {
        this.off('click', this.hideHandle || this.hide);
        this.hideHandle = null;
    }

    /**
     * Scroll to the active item.
     *
     * @param {object} prevProps - Previous props before update
     * @param {object} prevState - Previous state before update
     * @private
     */
    componentDidUpdate(prevProps, prevState) {
        super.componentDidUpdate(prevProps);
        const activeItem = this.element && this.element.querySelector('.active');
        const {
            open
        } = this.state;

        if (open && open !== prevState.open) {
            const { ...bounds
            } = this.getElementBounds();
            let newState = this.getHorizontalRender(bounds);
            newState = { ...newState,
                ...this.getVerticalRender(bounds)
            };

            if (Object.keys(newState).length > 0) {
                this.setState(newState);
            }
        }

        if (open && activeItem) {
            this.scrollIntoViewIfNeeded(activeItem);
        }
    }

    /**
     * Fetches all element bounds to necessary calculations of display
     * @private
     * @returns {object} element bounds
     */
    getElementBounds() {
        // Viewport Bounds
        const viewportBounds = {
            x: window.pageXOffset,
            y: window.pageYOffset,
            width: window.innerWidth,
            height: window.innerHeight
        };

        // Main Dropdown Element
        const elementBounds = this.element && this.element.getBoundingClientRect();

        // Dropdown Menu Element
        const menuBounds = this.menuElement && this.menuElement.wrapper && this.menuElement.wrapper.getBoundingClientRect();

        // Label Element (if one exists)
        const labelBounds = this.componentLabel && this.componentLabel.getBoundingClientRect();

        // Menu Item Element
        const menuItemRef = this.menuElement &&
            this.menuElement.dropdownItem &&
            this.menuElement.dropdownItem.getRef &&
            this.menuElement.dropdownItem.getRef();

        const menuItemBounds = menuItemRef && menuItemRef.getBoundingClientRect();

        // Get Dropdown Item height
        const itemHeight = menuItemBounds && menuItemBounds.height || 45;

        return {
            viewportBounds,
            elementBounds,
            menuBounds,
            labelBounds,
            itemHeight
        };
    }

    /**
     * Compute vertical spacing for menu and determine whether to show above or below the dropdown control.
     *
     * @param {object} bounds - Object containing element bounds calculated in getElementBounds()
     * @returns {obbject} Temporary updated state object
     * @private
     */
    getVerticalRender(bounds) {
        // Temporary object to prevent multiple state updates
        const newState = {};
        const {
            viewportBounds,
            elementBounds,
            menuBounds,
            labelBounds,
            itemHeight
        } = bounds;

        const hasLabel = labelBounds && labelBounds.height > 0;
        if (this.state.hasLabel !== hasLabel) {
            newState.hasLabel = hasLabel;
        }

        if (elementBounds) {
            // Determine to show the menu above or below
            const menuBottomBound = elementBounds.top + elementBounds.height + menuBounds.height - (itemHeight / 2);
            const overflowBelow = viewportBounds.height < menuBottomBound;
            const spaceAbove = elementBounds.top - menuBounds.height > 0;
            const showUp = overflowBelow && spaceAbove;

            if (this.state.showUp !== showUp) {
                newState.showUp = showUp;
            }
        }

        return newState;
    }

    /**
     * Compute horizontal spacing for menu and determine whether to show aligned left or right to the dropdown control.
     *
     * @param {object} bounds - Object containing menu bounds calculated in getElementBounds()
     * @returns {object} Temporary updated state object
     * @private
     */
    getHorizontalRender(bounds) {
        const newState = {};
        if (autoAlignments[this.props.menuAlignment] || !this.props.menuAlignment) {
            const {
                elementBounds,
                menuBounds,
                viewportBounds
            } = bounds;
            if (elementBounds && menuBounds) {
                const left = elementBounds.right + viewportBounds.x - window.document.documentElement.clientLeft - menuBounds.width;
                const right = elementBounds.left + viewportBounds.x - window.document.documentElement.clientLeft + menuBounds.width;

                let alignmentOverride;
                // The element needs to be right aligned if it's too close or outside the bounds of the viewport
                // and it it small enough to fit inside a viewport, if it's too big we'll leave the default
                if (viewportBounds.width - right < 10 && menuBounds.width < viewportBounds.width) {
                    alignmentOverride = alignmentTypes.right;
                } else if (left < 10) {
                    // Only force different than the default if the leftmost bounds is outside or too close to the left side of the viewport
                    alignmentOverride = alignmentTypes.left;
                }

                // Compare with current state
                if (this.state.alignmentOverride !== alignmentOverride) {
                    newState.alignmentOverride = alignmentOverride;
                }
            }
        }
        return newState;
    }

    toggleBackground(isOpen) {
        if (this.props.enableFullscreen) {
            if (isOpen) {
                document.body.classList.add('dropdown-open');
            } else {
                document.body.classList.remove('dropdown-open');
            }
        }

        const {
            open,
            selected
        } = this.state;
        const {
            required
        } = this.props;
        if (!open && selected.length === 0 && required) {
            this.setState({
                error: true
            });
        } else if (selected.length > 0 && required) {
            this.setState({
                error: false
            });
        }
    }

    /**
     * Extract DropdownControl from all children.
     *
     * @param {React.Element[]} children - React elements.
     * @returns {React.Element} DropdownControl with children.
     * @private
     */
    control(children) {
        const {
            placeholder,
            type,
            disabled,
            toggleIcon,
            content,
            size,
            namespace
        } = this.props;
        const dropdownControl = children.filter(
            child => child.type === DropdownControl
        )[0] || < DropdownControl / > ;
        return React.cloneElement(dropdownControl, {
            children: dropdownControl.props.children || this.getSelectedItem(children) || placeholder,
            hasPlaceholder: !!(!dropdownControl.props.children && !this.getSelectedItem(children) && placeholder),
            key: 'control',
            toggle: this.show,
            type,
            onKeyDown: this.keyDown.bind(this),
            disabled,
            toggleIcon,
            content,
            size,
            namespace
        });
    }

    /**
     * Returns all children that are not of type DropdownControl.
     *
     * @param {React.Element[]} children - React elements.
     * @returns {React.Element[]} React elements.
     * @private
     */
    items(children) {
        return children.filter(child => {
            return child.type !== DropdownControl &&
                child.type !== DropdownHeader &&
                child.type !== DropdownDivider;
        });
    }

    /**
     * Render Dropdown component.
     *
     * @returns {React.Element} div element with Dropdown.
     * @private
     */
    render() {
            const {
                keyboardSelectionIndex,
                open,
                showUp,
                hasLabel,
                error
            } = this.state;
            const props = {
                ...this.props,
                keyboardSelectionIndex,
                onChange: this.selectItem,
                onToggle: this.toggle
            };
            const select = ~props.type.indexOf('select');
            const tripledot = props.type === 'tripledot';
            // Use the alignment if set, otherwise tripledot prefersRight by default,
            // Everything else should left align
            props.menuAlignment = props.menuAlignment ||
                (tripledot ?
                    alignmentTypes.preferRight :
                    alignmentTypes.left);
            const children = React.Children.toArray(props.children);
            const disabled = props.disabled;
            const title = (props.label || props.required) && ( <
                Fragment > {
                    props.label && < label key = 'label'
                    ref = {
                        r => {
                            this.componentLabel = r;
                        }
                    } > {
                        props.label
                    } < /label> } {
                        props.required && < span className = {
                                props.namespace('text-danger')
                            } > * < /span> } <
                            /Fragment>
                    );
                    const className = this.classNames(props.className, {
                            'ux-select-dropdown': select
                        },
                        props.namespace(this.classNames('dropdown', {
                            'triple-dot-dropdown': tripledot,
                            'dropdown-disabled': disabled,
                            open,
                            'menu-up': showUp,
                            'has-label': hasLabel,
                            'full-screen': this.props.enableFullscreen,
                            error
                        }))
                    );

                    const openMenu = open ? 'true' : 'false';
                    const ElementType = props.elementType;

                    return ( <
                        ElementType ref = {
                            r => this.element = r
                        }
                        id = {
                            props.id
                        }
                        className = {
                            className
                        }
                        role = 'menubar'
                        aria - expanded = {
                            openMenu
                        }
                        aria - haspopup = {
                            'true'
                        } > {
                            title
                        } {
                            this.control(children)
                        } <
                        DropdownValue key = 'value'
                        type = {
                            props.type
                        }
                        value = {
                            props.value
                        }
                        name = {
                            props.name
                        }
                        /> <
                        DropdownMenu key = 'menu' { ...props
                        }
                        ref = {
                            r => {
                                this.menuElement = r;
                            }
                        }
                        toggle = {
                            this.toggle
                        }
                        selected = {
                            this.selected
                        }
                        alignmentOverride = {
                            this.state.alignmentOverride
                        }
                        keyboardSelectionIndex = {
                            this.state.keyboardSelectionIndex
                        } > {
                            children.filter(child => child.type !== DropdownControl)
                        } <
                        /DropdownMenu> {
                            error && props.required &&
                                <
                                span className = {
                                    this.props.namespace('form-error')
                                }
                            role = 'alert' > {
                                    props.required
                                } <
                                /span>
                        } <
                        /ElementType>
                    );
                }
            }

            /**
             * Default to button dropdown.
             *
             * @enum {Object} defaultProps
             * @public
             */
            DropdownComponent.defaultProps = {
                ...Base.defaultProps,
                type: 'button',
                elementType: 'div',
                enableFullscreen: true
            };

            /**
             * Define properties and validate the type of children that are passed
             * to the Dropdown.
             *
             * @enum {Object} propTypes
             * @public
             */
            DropdownComponent.propTypes = {
                /** Common dropdown props */
                ...Base.propTypes,
                /** Namespace Consumer props */
                ...NamespaceShape,
                /** ID attribute for the dropdown container */
                id: PropTypes.string,
                /** Type of the dropdown */
                type: PropTypes.oneOf(types),
                /** Wrapper element type for the dropdown */
                elementType: PropTypes.string,
                /** Alignment of the dropdown menu */
                alignment: menuAlignmentPropType,
                /** Boolean whether the dropdown menu is fullscreen (mobile only) */
                enableFullscreen: PropTypes.bool,
                /** Children components of a dropdown. Can be a DropdownControl,
                 *  DropdownDivider, DropdownHeader, or DropdownItem */
                children: validateComponents([
                    DropdownControl,
                    DropdownItem,
                    DropdownDivider,
                    DropdownHeader
                ]),
                /** Error message to show if the dropdown is required */
                required: PropTypes.oneOfType([
                    PropTypes.node,
                    PropTypes.bool
                ])
            };

            //
            // Attach childs to the main Component for availability without ES6 imports.
            //
            DropdownComponent.DropdownControl = DropdownControl;
            DropdownComponent.DropdownDivider = DropdownDivider;
            DropdownComponent.DropdownHeader = DropdownHeader;
            DropdownComponent.DropdownItem = DropdownItem;

            //
            // Export the Class and related children.
            //
            const Dropdown = withEventDistContext(withNamespace(DropdownComponent));

            export {
                Dropdown as
                default,
                DropdownControl,
                DropdownDivider,
                DropdownHeader,
                DropdownItem
            };



            // WEBPACK FOOTER //
            // ./node_modules/@ux/dropdown/index.js