'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tweenable = exports.composeEasingObject = exports.tweenProps = exports.clone = exports.each = undefined;

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

exports.tween = tween;

var _easingFunctions = require('./easing-functions');

var easingFunctions = _interopRequireWildcard(_easingFunctions);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};
        if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }
        newObj.default = obj;
        return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

// CONSTANTS
var DEFAULT_EASING = 'linear';
var DEFAULT_DURATION = 500;
var UPDATE_TIME = 1000 / 60;
var root = typeof window !== 'undefined' ? window : global;

// requestAnimationFrame() shim by Paul Irish (modified for Shifty)
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
var DEFAULT_SCHEDULE_FUNCTION = root.requestAnimationFrame || root.webkitRequestAnimationFrame || root.oRequestAnimationFrame || root.msRequestAnimationFrame || root.mozCancelRequestAnimationFrame && root.mozRequestAnimationFrame || setTimeout;

var noop = function noop() {};

/**
 * Handy shortcut for doing a for-in loop. This is not a "normal" each
 * function, it is optimized for Shifty.  The iterator function only receives
 * the property name, not the value.
 * @param {Object} obj
 * @param {Function(string)} fn
 * @private
 */
var each = exports.each = function each(obj, fn) {
    Object.keys(obj).forEach(fn);
};

/**
 * @param {Object} obj
 * @return {Object}
 * @private
 */
var clone = exports.clone = function clone(obj) {
    return (0, _objectAssign2.default)({}, obj);
};

/**
 * This object contains all of the tweens available to Shifty.  It is
 * extensible - simply attach properties to the `Tweenable.formulas`
 * Object following the same format as `linear`.
 *
 * `pos` should be a normalized `number` (between 0 and 1).
 * @type {Object(function)}
 * @private
 */
var formulas = clone(easingFunctions);

/**
 * Tweens a single property.
 * @param {number} start The value that the tween started from.
 * @param {number} end The value that the tween should end at.
 * @param {Function} easingFunc The easing curve to apply to the tween.
 * @param {number} position The normalized position (between 0.0 and 1.0) to
 * calculate the midpoint of 'start' and 'end' against.
 * @return {number} The tweened value.
 * @private
 */
var tweenProp = function tweenProp(start, end, easingFunc, position) {
    return start + (end - start) * easingFunc(position);
};

/**
 * Calculates the interpolated tween values of an Object for a given
 * timestamp.
 * @param {Number} forPosition The position to compute the state for.
 * @param {Object} currentState Current state properties.
 * @param {Object} originalState: The original state properties the Object is
 * tweening from.
 * @param {Object} targetState: The destination state properties the Object
 * is tweening to.
 * @param {number} duration: The length of the tween in milliseconds.
 * @param {number} timestamp: The UNIX epoch time at which the tween began.
 * @param {Object} easing: This Object's keys must correspond to the keys in
 * targetState.
 * @private
 */
var tweenProps = exports.tweenProps = function tweenProps(forPosition, currentState, originalState, targetState, duration, timestamp, easing) {
    var normalizedPosition = forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;

    each(currentState, function(key) {
        var easingObjectProp = easing[key];
        var easingFn = typeof easingObjectProp === 'function' ? easingObjectProp : formulas[easingObjectProp];

        currentState[key] = tweenProp(originalState[key], targetState[key], easingFn, normalizedPosition);
    });

    return currentState;
};

/**
 * Creates a usable easing Object from a string, a function or another easing
 * Object.  If `easing` is an Object, then this function clones it and fills
 * in the missing properties with `"linear"`.
 * @param {Object.<string|Function>} fromTweenParams
 * @param {Object|string|Function} easing
 * @return {Object.<string|Function>}
 * @private
 */
var composeEasingObject = exports.composeEasingObject = function composeEasingObject(fromTweenParams) {
    var easing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EASING;

    var composedEasing = {};
    var typeofEasing = typeof easing === 'undefined' ? 'undefined' : _typeof(easing);

    if (typeofEasing === 'string' || typeofEasing === 'function') {
        each(fromTweenParams, function(prop) {
            return composedEasing[prop] = easing;
        });
    } else {
        each(fromTweenParams, function(prop) {
            return composedEasing[prop] = composedEasing[prop] || easing[prop] || DEFAULT_EASING;
        });
    }

    return composedEasing;
};

var Tweenable = exports.Tweenable = function() {
    /**
     * @constructs shifty.Tweenable
     * @param {Object=} initialState The values that the initial tween should
     * start at if a `from` object is not provided to `tween` or `setConfig`.
     * @param {Object=} config Configuration object to be passed to
     * [`setConfig`]{@link shifty.Tweenable#setConfig}.
     */
    function Tweenable() {
        var initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck(this, Tweenable);

        this._currentState = initialState;
        this._configured = false;
        this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;

        // To prevent unnecessary calls to setConfig do not set default
        // configuration here.  Only set default configuration immediately before
        // tweening if none has been set.
        if (config !== undefined) {
            this.setConfig(config);
        }
    }

    /**
     * Applies a filter to Tweenable instance.
     * @param {Tweenable} tweenable The `Tweenable` instance to call the filter
     * upon.
     * @param {String} filterName The name of the filter to apply.
     * @private
     */


    _createClass(Tweenable, [{
        key: '_applyFilter',
        value: function _applyFilter(filterName) {
            var _this = this;

            var filters = Tweenable.filters;
            var args = this._filterArgs;

            each(filters, function(name) {
                var filter = filters[name][filterName];

                if (typeof filter !== 'undefined') {
                    filter.apply(_this, args);
                }
            });
        }

        /**
         * Handles the update logic for one step of a tween.
         * @param {number=} currentTimeOverride Needed for accurate timestamp in
         * shifty.Tweenable#seek.
         * @private
         */

    }, {
        key: '_timeoutHandler',
        value: function _timeoutHandler(currentTimeOverride) {
            var _this2 = this,
                _arguments = arguments;

            var delay = this._delay;
            var currentState = this._currentState;
            var timestamp = this._timestamp;
            var duration = this._duration;
            var targetState = this._targetState;
            var step = this._step;

            var endTime = timestamp + delay + duration;
            var currentTime = Math.min(currentTimeOverride || Tweenable.now(), endTime);
            var hasEnded = currentTime >= endTime;
            var offset = duration - (endTime - currentTime);

            if (this.isPlaying()) {
                if (hasEnded) {
                    step(targetState, this._attachment, offset);
                    this.stop(true);
                } else {
                    // This function needs to be .call-ed because it is a native method in
                    // some environments:
                    // http://stackoverflow.com/a/9678166
                    this._scheduleId = this._scheduleFunction.call(root, function() {
                        return _this2._timeoutHandler.apply(_this2, _arguments);
                    }, UPDATE_TIME);

                    this._applyFilter('beforeTween');

                    // If the animation has not yet reached the start point (e.g., there was
                    // delay that has not yet completed), just interpolate the starting
                    // position of the tween.
                    if (currentTime < timestamp + delay) {
                        currentTime = 1;
                        duration = 1;
                        timestamp = 1;
                    } else {
                        timestamp += delay;
                    }

                    tweenProps(currentTime, currentState, this._originalState, targetState, duration, timestamp, this._easing);

                    this._applyFilter('afterTween');
                    step(currentState, this._attachment, offset);
                }
            }
        }

        /**
         * Configure and start a tween.
         * @method shifty.Tweenable#tween
         * @param {Object=} config See `config` options for `{@link
         * shifty.Tweenable#setConfig}`
         * @return {Promise}
         */

    }, {
        key: 'tween',
        value: function tween() {
            var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

            if (this._isTweening) {
                return this;
            }

            // Only set default config if no configuration has been set previously and
            // none is provided now.
            if (config !== undefined || !this._configured) {
                this.setConfig(config);
            }

            this._timestamp = Tweenable.now();
            this._start(this.get(), this._attachment);
            return this.resume();
        }

        /**
         * Configure a tween that will start at some point in the future.
         *
         * @method shifty.Tweenable#setConfig
         * @param {Object} config See below
         * @property {Object=} config.from Starting position.  If omitted, `{@link
         * shifty.Tweenable#get}` is used.
         * @property {Object=} config.to Ending position.
         * @property {number=} config.duration How many milliseconds to animate for.
         * @property {number=} config.delay  How many milliseconds to wait before
         * starting
         * the tween.
         * @property {Function(Object, *)=} config.start Function to execute when the
         * tween begins.  Receives the state of the tween as the first parameter and
         * `attachment` as the second parameter.
         * @property {Function(Object, *, number)=} config.step Function to execute
         * on every tick.  Receives `get` as the first parameter, `attachment` as the
         * second parameter, and the time elapsed since the start of the tween as the
         * third.  This function is not called on the final step of the animation.
         * @property {Object.<string|Function|string|Function>=} config.easing Easing
         * curve name(s) or function(s) to use for the tween.
         * @property {*=} config.attachment Cached value that is passed to the
         * `step`/`start` functions.
         * @property {Function} config.promise Promise constructor for when you want
         * to use Promise library or polyfill Promises in unsupported environments.
         * @return {Tweenable}
         */

    }, {
        key: 'setConfig',
        value: function setConfig() {
            var _this3 = this;

            var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this._configured = true;

            // Attach something to this Tweenable instance (e.g.: a DOM element, an
            // object, a string, etc.);
            this._attachment = config.attachment;

            // Init the internal state
            (0, _objectAssign2.default)(this, {
                _pausedAtTime: null,
                _scheduleId: null,
                _delay: config.delay || 0,
                _start: config.start || noop,
                _step: config.step || noop,
                _duration: config.duration || DEFAULT_DURATION,
                _currentState: clone(config.from || this.get())
            });

            // Separate Object.assign here; it depends on _currentState being set above
            (0, _objectAssign2.default)(this, {
                _originalState: this.get(),
                _targetState: clone(config.to || this.get())
            });

            var currentState = this._currentState;
            // Ensure that there is always something to tween to.
            this._targetState = (0, _objectAssign2.default)({}, currentState, this._targetState);

            this._easing = composeEasingObject(currentState, config.easing);
            this._filterArgs = [currentState, this._originalState, this._targetState, this._easing];
            this._applyFilter('tweenCreated');

            var Promised = config.promise || Promise;
            this._promise = new Promised(function(resolve, reject) {
                _this3._resolve = resolve;
                _this3._reject = reject;
            });

            // Needed to silence (harmless) logged errors when a .catch handler is not
            // added by downsteam code
            this._promise.catch(noop);

            return this;
        }

        /**
         * @method shifty.Tweenable#get
         * @return {Object} The current state.
         */

    }, {
        key: 'get',
        value: function get() {
            return clone(this._currentState);
        }

        /**
         * @method shifty.Tweenable#set
         * @param {Object} state The state to set.
         * @description Set the current state.
         */

    }, {
        key: 'set',
        value: function set(state) {
            this._currentState = state;
        }

        /**
         * Pause a tween.  Paused tweens can be resumed from the point at which they
         * were paused.  This is different from `stop`, as that method causes a tween
         * to start over when it is resumed.
         * @method shifty.Tweenable#pause
         * @return {Tweenable}
         */

    }, {
        key: 'pause',
        value: function pause() {
            this._pausedAtTime = Tweenable.now();
            this._isPaused = true;

            return this;
        }

        /**
         * Resume a paused tween.
         * @method shifty.Tweenable#resume
         * @return {Promise}
         */

    }, {
        key: 'resume',
        value: function resume() {
            if (this._isPaused) {
                this._timestamp += Tweenable.now() - this._pausedAtTime;
            }

            this._isPaused = false;
            this._isTweening = true;
            this._timeoutHandler();

            return this._promise;
        }

        /**
         * Move the state of the animation to a specific point in the tween's
         * timeline.  If the animation is not running, this will cause the `step`
         * handlers to be called.
         * @method shifty.Tweenable#seek
         * @param {millisecond} millisecond The millisecond of the animation to seek
         * to.  This must not be less than `0`.
         * @return {Tweenable}
         */

    }, {
        key: 'seek',
        value: function seek(millisecond) {
            millisecond = Math.max(millisecond, 0);
            var currentTime = Tweenable.now();

            if (this._timestamp + millisecond === 0) {
                return this;
            }

            this._timestamp = currentTime - millisecond;

            if (!this.isPlaying()) {
                this._isTweening = true;
                this._isPaused = false;

                // If the animation is not running, call _timeoutHandler to make sure that
                // any step handlers are run.
                this._timeoutHandler(currentTime);

                this.pause();
            }

            return this;
        }

        /**
         * Stops and cancels a tween.
         * @param {boolean=} gotoEnd If `false` or omitted, the tween just stops at
         * its current state, and the tween promise is not resolved.  If `true`, the
         * tweened object's values are instantly set to the target values, and the
         * promise is resolved.
         * @method shifty.Tweenable#stop
         * @return {Tweenable}
         */

    }, {
        key: 'stop',
        value: function stop(gotoEnd) {
            this._isTweening = false;
            this._isPaused = false;

            (root.cancelAnimationFrame || root.webkitCancelAnimationFrame || root.oCancelAnimationFrame || root.msCancelAnimationFrame || root.mozCancelRequestAnimationFrame || root.clearTimeout)(this._scheduleId);

            if (gotoEnd) {
                this._applyFilter('beforeTween');
                tweenProps(1, this._currentState, this._originalState, this._targetState, 1, 0, this._easing);
                this._applyFilter('afterTween');
                this._applyFilter('afterTweenEnd');
                this._resolve(this._currentState, this._attachment);
            } else {
                this._reject(this._currentState, this._attachment);
            }

            return this;
        }

        /**
         * Whether or not a tween is running.
         * @method shifty.Tweenable#isPlaying
         * @return {boolean}
         */

    }, {
        key: 'isPlaying',
        value: function isPlaying() {
            return this._isTweening && !this._isPaused;
        }

        /**
         * Set a custom schedule function.
         *
         * If a custom function is not set,
         * [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame)
         * is used if available, otherwise
         * [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout)
         * is used.
         * @method shifty.Tweenable#setScheduleFunction
         * @param {Function(Function,number)} scheduleFunction The function to be
         * used to schedule the next frame to be rendered.
         */

    }, {
        key: 'setScheduleFunction',
        value: function setScheduleFunction(scheduleFunction) {
            this._scheduleFunction = scheduleFunction;
        }

        /**
         * `delete` all "own" properties.  Call this when the `Tweenable` instance
         * is no longer needed to free memory.
         * @method shifty.Tweenable#dispose
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            var _this4 = this;

            each(this, function(prop) {
                return delete _this4[prop];
            });
        }
    }]);

    return Tweenable;
}();

(0, _objectAssign2.default)(Tweenable, {
    /**
     * @memberof shifty.Tweenable
     * @type {Object.<Function(number)>}
     * @static
     * @description A static Object of easing functions that can by used by
     * Shifty.
     */
    formulas: formulas,
    filters: {},

    /**
     * @memberof shifty.Tweenable
     * @function
     * @static
     * @description Returns the current timestamp
     * @returns {number}
     */
    now: Date.now || function(_) {
        return +new Date();
    }
});

/**
 * @method shifty.tween
 * @param {Object=} config See `config` options for `{@link
 * shifty.Tweenable#setConfig}`
 * @description Standalone convenience method that functions identically to
 * [`shifty.Tweenable#tween`]{@link shifty.Tweenable#tween}.  You can use this to create
 * tweens without needing to set up a `{@link shifty.Tweenable}` instance.
 *
 *     import { tween } from 'shifty';
 *
 *     tween({ from: { x: 0 }, to: { x: 10 } }).then(
 *       () => console.log('All done!')
 *     );
 *
 * @returns {Promise}
 */
function tween() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var tweenable = new Tweenable();
    var promise = tweenable.tween(config);
    promise.tweenable = tweenable;

    return promise;
}


// WEBPACK FOOTER //
// ./node_modules/@godaddy/shifty/tweenable.js