'use strict';

var cookieHelper = require('./cookie');
var object = require('./object');
var cryptoHelper = require('./crypto');

var _authInfoToken = {};

var _authRealms = ['idp', 'jomax'];

var _authRealmIdMap = {
    idp: 'info_shopperId',
    jomax: 'info_accountName'
};

function _isTokenEmpty(token) {
    return Object.keys(token).length < 1;
}

// Fetch the info_token for a particular realm from the browser
function _getInfoTokenClaims(realm) {
    var claims = {};
    var cookieName = 'info_' + realm;
    var cookie = cookieHelper.findCookie(cookieName);
    if (cookie) {
        try {
            claims = JSON.parse(cookie);
        } catch (err) {} // eslint-disable-line no-empty
    }
    return claims;
}

// Finds/updates _authInfoToken with the newest auth token.
// If none are found, the _authInfoToken variable is cleared.
function updateAuthTokens() {
    var token = {};
    for (var i = 0; i < _authRealms.length; i++) {
        var realm = _authRealms[i];
        var infoToken = _getInfoTokenClaims(realm);

        // Update the info token if its newer or not currently defined
        if (!_isTokenEmpty(infoToken) && (_isTokenEmpty(token) || token.iat < infoToken.iat)) {
            token = infoToken;
        }
    }

    _authInfoToken = token;
}

function isAuthenticated() {
    return !_isTokenEmpty(_authInfoToken);
}

// boolean value of whether the authenticated
// user is in a delegation scenario
function isDelegated() {
    if (!isAuthenticated()) {
        return false;
    }

    var authType = _authInfoToken.auth;
    return authType && authType !== 'basic';
}

// Boolean value of whether an employee token is found
// on the browser or the newest token is an employee
// delegation scenario
function isEmployee() {
    if (!isAuthenticated()) {
        return false;
    }

    var tokenType = _authInfoToken.typ;
    var authType = _authInfoToken.auth;
    // Check if the latest token is for jomax
    if (tokenType && tokenType === 'jomax') {
        return true;
    }

    // Check if the latest token is an employee impersonation
    if (authType && authType !== 'basic' && authType.charAt(0) === 'e') {
        return true;
    }

    // Check if there is a jomax token on the browser
    var jomaxToken = _getInfoTokenClaims('jomax');
    return !_isTokenEmpty(jomaxToken);
}

// Returns the delegate's (parent's) claims, if found.
function _getDelegationClaims(currentClaims) {
    if ('del' in currentClaims) {
        return _getDelegationClaims(currentClaims.del);
    }
    return currentClaims;
}

function _cryptOrUndefined(encrypt, value) {
    if (!encrypt) {
        // If we're not encrypting... just return the value
        return value;
    }

    if (value) {
        // Return encrypted value
        return cryptoHelper.sha256(value);
    }
}

// Fetch a claim from a delegation token
// (This will parse the token recursively)
function getDelegateClaim(claim, encrypt) {
    if (isAuthenticated()) {
        var authType = _authInfoToken.auth;
        if (authType !== 'basic') {
            var delegationClaims = _getDelegationClaims(_authInfoToken);
            return _cryptOrUndefined(encrypt, delegationClaims[claim]);
        }
    }
}

// Returns the employee id if a jomax token is found
// If the newest token is an employee delegation token,
// the employee id will be returned.
function getEmployeeId(encrypt) {
    if (isAuthenticated()) {
        var tokenType = _authInfoToken.typ;
        var authType = _authInfoToken.auth;
        var idClaimName = _authRealmIdMap.jomax;

        // Check if the latest token is for jomax
        if (tokenType && tokenType === 'jomax') {
            return _cryptOrUndefined(encrypt, _authInfoToken[idClaimName]);
        }

        // Check if the latest token is an employee impersonation
        if (authType && authType !== 'basic' && authType.charAt(0) === 'e') {
            return getDelegateEmployeeId(encrypt);
        }

        // Check if there is a jomax token on the browser
        var jomaxToken = _getInfoTokenClaims('jomax');
        if (!_isTokenEmpty(jomaxToken)) {
            return _cryptOrUndefined(encrypt, jomaxToken[idClaimName]);
        }
    }
}

// Fetch the jomax (employee) username from the current token
function getDelegateEmployeeId(encrypt) {
    return getDelegateClaim(_authRealmIdMap.jomax, encrypt);
}

// Search an auth token for a particular claim
function _getInfoTokenClaim(tokenClaims, claim, type) {
    var tokenType = tokenClaims.typ;
    if (typeof type !== 'undefined' && tokenType && tokenType !== type) {
        return;
    }

    var rVal = void 0;
    var authType = tokenClaims.auth;
    // If this is a delegation token, search
    // sub claims recursively
    if (authType && authType !== 'basic') {
        var subClaims = tokenClaims[authType];
        rVal = _getInfoTokenClaim(subClaims, claim, type);
    } else {
        rVal = tokenClaims[claim];
    }

    return rVal;
}

// Get the customer id for the user who is delegated into
// the current user.
function getDelegateCustomerId(encrypt) {
    return getDelegateClaim('info_cid', encrypt);
}

// Get the customer id from the newest auth token
function getCustomerId(encrypt) {
    if (isAuthenticated()) {
        // Search the info token for the customer id claim
        return _cryptOrUndefined(encrypt, _getInfoTokenClaim(_authInfoToken, 'info_cid'));
    }
}

// Fetches the appropriate ID for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) ID will be returned.
function getUserId(encrypt) {
    if (isAuthenticated()) {
        var tokenType = _authInfoToken.typ;

        // For the auth type (idp vs pass vs jomax), lookup the
        // name of the claim that holds the customer id
        var claimToLookup = _authRealmIdMap[tokenType];

        // Search the info token for the customer id claim
        return _cryptOrUndefined(encrypt, _getInfoTokenClaim(_authInfoToken, claimToLookup));
    }
}

// Fetches the shopper ID for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) ID will be returned.
function getShopperId(encrypt) {
    if (isAuthenticated()) {
        var tokenType = _authInfoToken.typ;
        if (tokenType === 'idp') {
            return _cryptOrUndefined(encrypt, _getInfoTokenClaim(_authInfoToken, 'info_shopperId'));
        }
    }
}

// Fetches the claim for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) claim will be searched.
function getClaimFromInfoToken(claimName) {
    if (isAuthenticated()) {
        return _getInfoTokenClaim(_authInfoToken, claimName);
    }
}

// First tries to fetch the fpid for the newest auth tokken.
// If not found, fallback/fetch the fpid from the brand cookie
function getFederationPartnerId() {
    if (isAuthenticated()) {
        var fpid = _getInfoTokenClaim(_authInfoToken, 'fpid');
        if (!fpid) {
            var tokenType = _authInfoToken.typ;
            if (typeof tokenType !== 'undefined') {
                fpid = cookieHelper.findCookie('brand_' + tokenType);
            }
        }
        return fpid;
    }
}

// Fetches the realm for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) realm will be returned.
function getUserRealm() {
    if (isAuthenticated()) {
        return _getInfoTokenClaim(_authInfoToken, 'typ');
    }
}

var internalExports = {};
if (process.env.NODE_ENV !== 'production') {
    internalExports = {
        _getInfoTokenClaims: _getInfoTokenClaims,
        _getInfoTokenClaim: _getInfoTokenClaim,
        _getDelegationClaims: _getDelegationClaims,
        _cryptOrUndefined: _cryptOrUndefined
    };
}

module.exports = object.merge({
    getClaimFromInfoToken: getClaimFromInfoToken,
    getDelegateCustomerId: getDelegateCustomerId,
    getDelegateEmployeeId: getDelegateEmployeeId,
    getEmployeeId: getEmployeeId,
    getFederationPartnerId: getFederationPartnerId,
    getCustomerId: getCustomerId,
    getUserRealm: getUserRealm,
    getShopperId: getShopperId,
    isAuthenticated: isAuthenticated,
    isDelegated: isDelegated,
    isEmployee: isEmployee,
    updateAuthTokens: updateAuthTokens,
    getUserId: getUserId
}, internalExports);