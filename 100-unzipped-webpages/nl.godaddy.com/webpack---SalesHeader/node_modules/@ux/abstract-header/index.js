import {
    URL
} from '@ux/util';
import Cart from '@ux/cart';
import {
    events,
    traffic2,
    Customer,
    shopperDataLoader
} from '@ux/header-util';
import {
    NamespaceConsumer
} from '@ux/namespace-component';

/**
 * Super class for @ux/{sales,application,utility, pass}-headers. This module
 * should not be used directly, but rather extended in order to centralize a
 * lot of the shared business logic among the header.
 */
export default class AbstractHeader extends NamespaceConsumer {
    constructor(props) {
        super(...arguments);

        this.events = events;
        this.state = {
            cartItems: 0
        };

        // Expose a method on ux.eldorado.header to updateCart for passing down
        // to UtilityBar's Cart class as props.items
        this.updateCart = Cart.update.bind(this);

        traffic2.init({
            type: props.traffic,
            beacon: true
        });
        this.customer = this.createCustomer();
    }

    /**
     * @typedef {typeof Customer} Customer
     */
    /**
     * Returns a valid Customer instance using the props associated
     * with this instance. Derived Headers (e.g. ApplicationHeader, SalesHeader, etc.)
     * should override this method to define custom cookie behavior.
     *
     * @returns {Customer} Customer instance from @ux/header-util.
     */
    createCustomer() {
        return new Customer(this.props);
    }

    /**
     * Returns a value indicating if this instance will display no components
     * which themselves would require authentication (and thus a GUI call).
     * @param  {Object} components This has two distinct upstream locations:
     *   - `@ux/sales-header`:  props.components.utilityBar`.
     *   - `@ux/utility-header`: props.components (read from preset.components).
     * @returns {Boolean} Returns true if no auth data is required.
     */
    isUnauthenticated(components) {
        components = components || {};
        return !(components.accountDelegation ||
            components.notifications ||
            components.accountTray ||
            components.cart ||
            components.contactTray); // Federated partner info requires GUI call
    }

    getWindowLocation() {
        return window.location.href;
    }

    /**
     * Read in cookie Data for OrderConfirmation
     */
    getOrderDetails() {
        const orderId = new URL(this.getWindowLocation(), true).query.orderId;
        if (orderId) {
            this.setState({
                orderId
            });
        }
    }

    /**
     * Returns a shallow copy of any state set by the GUI call in
     * this.getCustomerDetails() for ease-of-access.
     * @returns {Object} All state we set from our GUI call for the customer.
     */
    getCustomerState() {
        const {
            state = {}
        } = this;

        return {
            displayName: state.displayName,
            federatedPartner: state.federatedPartner,
            items: state.items,
            isInGoCohort: state.isInGoCohort,
            isPro: state.isPro,
            loggedIn: state.loggedIn,
            name: state.name,
            proshopper: state.proshopper,
            rewardPoints: state.rewardPoints,
            shopperId: state.shopperId,
            username: state.username,
            vip: state.vip
        };
    }

    /**
     * Get customer details.
     *
     * @param {Function} [done] Completion callback.
     * @api private
     */
    getCustomerDetails(done) {
        // Start with data from the existing cookie
        this.customer.updateFromCookie();

        if (typeof done !== 'function') {
            done = () => {};
        }

        if (this.state.unauthenticated) {
            // No components visible that use customer data, so we can skip the GUI call
            shopperDataLoader.configureOnly({
                url: this.props.urls.gui.href,
                privateLabelId: this.props.privateLabelId,
                shopperId: this.customer.shopperId
            });

            done();
            return;
        }

        // Next, try to fetch fresh data from the server
        this.customer.fetch({
            gui: this.props.urls.gui.href
        }, error => {
            if (error) {
                const doneWithError = () => {
                    events.emit('error', error);
                    done(error);
                };

                // We still have some data from the cookie, so just fall back to that.
                // We use the presence of a shopper ID as a weak proxy to login state.
                // This won't actually unlock any real actions -- just tells the header to act
                // like the user is logged in. If they are not really logged in, they'll get
                // sent to SSO when they try to do anything that requires login.
                if (this.customer.shopperId) {
                    this.setState({
                        displayName: this.customer.displayName(true),
                        federatedPartner: this.customer.get('federatedPartner'),
                        name: this.customer.displayName(),
                        shopperId: this.customer.shopperId,
                        loggedIn: true
                    }, doneWithError);
                } else {
                    doneWithError();
                }

                return;
            }

            const proUser = this.customer.get('proshopper');
            const proshopper = proUser && proUser.status === 1;
            const rewardPoints = proshopper ? proUser.rewardPoints : null;
            const tmsData = this.customer.get('tms');
            const isInGoCohort = tmsData && tmsData.some(split => {
                return split.Name === 'wsb_vnext';
            });

            this.setState({
                displayName: this.customer.displayName(true),
                federatedPartner: this.customer.get('federatedPartner'),
                items: this.customer.cart,
                isInGoCohort,
                isPro: proshopper,
                loggedIn: this.customer.loggedIn,
                name: this.customer.displayName(),
                proshopper,
                rewardPoints,
                shopperId: this.customer.shopperId,
                username: this.customer.get('loginName'),
                vip: this.customer.vip
            }, done);
        }, false);
    }


    /**
     * Query Traffic for the variant result of a given experiment and pipe the result to React state
     * @param {Object} opt Options
     * @param {String} opt.expId The experiment ID
     * @param {Object} [opt.attributes] An optional object to to pass along attributes
     * for Traffic/Split.io to calculate the variant ID. If none pass {}
     * @param {String} opt.stateFieldName The name of the React state field to store the result in
     * @param {StateValueTransformerFn} [opt.stateValueTransformer] An optional function to transform a variant ID into a state
     *   value. If omitted, the state field will contain the variant ID itself
     * @example <caption>Sets the state value to a boolean based on if the variant ID is 'B'</caption>
     * pipeExpVariantToState({'my_experiment', { 'market-id': 'en-US' }, 'myExperiment', variantId => variantId === 'B'}, done)
     * @param {Function} [done] Callback function
     *
     * @callback StateValueTransformerFn
     * @param {String} variantId The variant identifier to transform
     *
     */
    pipeExpVariantToState({
        expId,
        attributes = {},
        stateFieldName,
        stateValueTransformer = (variantId => variantId)
    }, done) {
        // During server-rendering, we don't want to access `window`
        if (typeof window === 'undefined') return;

        const expDataLayer = window._expDataLayer = window._expDataLayer || [];
        const pipeVariantToState = variantId => {
            this.setState({
                [stateFieldName]: stateValueTransformer(variantId)
            }, done);
        };

        expDataLayer.push({
            schema: 'get_variant_for_experiment',
            version: 'v1',
            data: {
                experiment_id: expId,
                callback: pipeVariantToState,
                attributes: attributes
            }
        });
    }

    /**
     * Notify listeners the header is mounted and expose the instance.
     */
    componentDidMount() {
        this.events.emit('mount', 'header', this);
        this.events.emit('mount:header', this);

        this.getCustomerDetails();
        this.getOrderDetails();
    }

    /**
     * Notify header was updated.
     */
    componentDidUpdate() {
        events.emit('update:header', this);
    }

    /**
     * Needed to prevent enzyme from complaining about
     * missing inst.render method
     * @returns {undefined}
     */
    render() {
        return null;
    }
}