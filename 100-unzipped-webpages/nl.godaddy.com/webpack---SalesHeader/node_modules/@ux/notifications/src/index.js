import {
    NamespaceProvider,
    NamespaceConsumer,
    NamespaceShape,
    withNamespace
} from '@ux/namespace-component';
import {
    URL,
    cookie
} from '@ux/util';
import React from 'react';
import PropTypes from 'prop-types';

import trfq from 'react-trfq';

import shapes from './shapes';
import * as cache from './cache';
import NotificationBadge from './badge';
import NotificationList from './list';

const trfqEventDesc = 'click';

export class Notifications extends NamespaceConsumer {
    constructor(props) {
        super(props);

        this.openList = this.openList.bind(this);
        this.closeList = this.closeList.bind(this);
        this.toggleList = this.toggleList.bind(this);
        this.generateEid = this.generateEid.bind(this);

        // A reference to the trigger function that wraps the click handler. We keep a reference
        // to it so we can unbind the event later, when the component unmounts.
        this.clickEventTrigger = null;
        this._isMounted = true;
    }

    dismiss() {
        if (!this._isMounted) return;

        this.setState({
            dismissed: true
        });

        cookie.set('notificationsDismissed', true, {
            domain: '.' + new URL().domain(1)
        });
    }

    componentWillUnmount() {
        this.off('click', this.clickEventTrigger);
        this._isMounted = false;
    }

    openList(event) {
        event.preventDefault();

        const {
            isLoaded
        } = this.state;
        if (!isLoaded || !this._isMounted) {
            return;
        }

        this.setState({
            isOpen: true
        }, function badgeOpened() {
            this.bellClickLogImpressions();
            this.dismiss();
        }.bind(this));
    }

    closeList() {
        const {
            isLoaded
        } = this.state;
        if (!isLoaded || !this._isMounted) {
            return;
        }

        this.setState({
            isOpen: false
        });
    }

    toggleList(e) {
        const {
            isOpen
        } = this.state;
        const {
            openList,
            closeList
        } = this;
        isOpen ? closeList(e) : openList(e);
    }

    generateEid(suffix) {
        const manifest = this.props.manifest.toLowerCase();
        return `uxp.hyd.${manifest}.${suffix}`;
    }

    bellClickLogImpressions() {
        let eid = this.generateEid('notifications.unseencounterbell.click');
        const {
            notifications,
            dismissed
        } = this.state;
        if (notifications && notifications.length > 0) {
            if (dismissed) {
                eid = this.generateEid('notifications.seencounterbell.click');
            }
            trfq.logEvent(eid, trfqEventDesc);
            notifications.forEach(function(n) {
                if (n.eids && n.eids.impression) {
                    trfq.logImpression(n.eids.impression);
                }
            });
        } else {
            eid = this.generateEid('notifications.emptybell.click');
            trfq.logEvent(eid, trfqEventDesc);
        }
    }

    notesLoadLogImpressions() {
        let eid = this.generateEid('notifications.emptybell.impression');
        const {
            notifications,
            dismissed
        } = this.state;
        if (notifications && notifications.length > 0) {
            if (dismissed) {
                eid = this.generateEid('notifications.seencounterbell.impression');
            } else {
                eid = this.generateEid('notifications.unseencounterbell.impression');
            }
        }
        trfq.logImpression(eid);
    }

    componentDidMount() {
        const props = this.props;
        const {
            endpoint,
            privateLabelId,
            shopperId,
            market
        } = props;
        const dismissed = cookie.get('notificationsDismissed') === 'true';

        this.clickEventTrigger = this.outside('click', this.closeList, this.domNode);

        cache.get(
            props.cache.href, this.namespace('notification-cache'),
            endpoint, privateLabelId, shopperId, market,
            function notifRequestSuccess(response) {
                if (!this._isMounted) return;
                const {
                    notifications
                } = response;
                this.setState({
                    isLoaded: true,
                    isOpen: false,
                    notifications,
                    dismissed
                });
                this.notesLoadLogImpressions();
            }.bind(this),
            function notifRequestFailed() {
                if (!this._isMounted) return;
                this.setState({
                    failed: true,
                    isLoaded: true,
                    dismissed
                });
            }.bind(this)
        );
    }

    renderCaret() {
        return this.props.showOpenCaret && < div className = {
            this.namespace('caret')
        }
        />;
    }

    renderNotificationList() {
        const {
            closeList
        } = this;
        const {
            sso,
            messages
        } = this.props;
        const {
            failed,
            notifications
        } = this.state;

        return ( <
            React.Fragment > {
                this.renderCaret()
            } <
            NotificationList failed = {
                failed
            }
            notifications = {
                notifications
            }
            messages = {
                messages
            }
            sso = {
                sso
            }
            closeList = {
                closeList
            }
            /> <
            /React.Fragment>
        );
    }

    render() {
        const {
            toggleList
        } = this;
        const {
            className,
            sso,
            messages,
            tooltip,
            showCount
        } = this.props;
        const {
            isOpen,
            notifications,
            isLoaded
        } = this.state;

        const refHandler = function refHandler(domNode) {
            this.domNode = domNode;
        }.bind(this);

        const classes = this.classNames(
            className, this.namespace('notifications', 'dropdown'), {
                [this.namespace('open')]: isOpen,
                [this.namespace('loaded')]: isLoaded,
                [this.namespace('has-notifications')]: notifications && notifications.length > 0 && sso
            }
        );

        return <div ref = {
            refHandler
        }
        className = {
            classes
        }
        onClick = {
                toggleList
            } >
            <
            NotificationBadge
        messages = {
            messages
        }
        showCount = {
            showCount
        }
        count = {
            notifications && notifications.length
        }
        tooltip = {
            tooltip
        }
        /> {
            isOpen && this.renderNotificationList()
        } <
        /div>;
    }
}

Notifications.defaultProps = {
    showOpenCaret: false,
    showCount: true
};

Notifications.propTypes = {
    ...NamespaceShape,
    manifest: PropTypes.string.isRequired,
    cache: PropTypes.shape({
        href: PropTypes.string.isRequired
    }).isRequired,
    endpoint: PropTypes.shape({
        href: PropTypes.string.isRequired
    }).isRequired,
    sso: shapes.sso.isRequired,
    privateLabelId: PropTypes.number,
    shopperId: PropTypes.string,
    market: PropTypes.string.isRequired,
    messages: shapes.messages.isRequired,
    className: PropTypes.string,
    tooltip: PropTypes.string,
    showOpenCaret: PropTypes.bool,
    showCount: PropTypes.bool
};

export default withNamespace(Notifications);

export function Container(props) {
    const {
        namespace,
        ...rest
    } = props;
    return <NamespaceProvider namespace = {
            namespace
        } >
        <
        Notifications { ...rest
        }
    /> <
    /NamespaceProvider>;
}

Container.propTypes = {
    namespace: PropTypes.string
};