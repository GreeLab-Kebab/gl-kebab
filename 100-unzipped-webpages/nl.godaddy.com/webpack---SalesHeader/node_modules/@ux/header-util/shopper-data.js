import fetch from '@godaddy/fetch';
import events from './events';
import qs from 'querystringify';

/**
 * Loader for shopper data from the GUI API
 *
 * Data load is triggered by the header, but this class allows for other components to subscribe to the response
 * @class ShopperDataLoader
 * @public
 */
class ShopperDataLoader {
    constructor() {
        this._requestTriggered = false;
        this._data = null;
    }

    /**
     * Request the shopper data from GUI and notify subscribers.
     *
     * @memberof ShopperDataLoader
     * @private
     */
    _requestShopperData() {
        if (this._requestTriggered)
            return;

        this._requestTriggered = true;

        const queryParams = {
            plId: this._privateLabelId,
            shopperId: this._shopperId,
            sid: this._shopperId
        };
        const url = this._url + qs.stringify(queryParams, true);
        fetch(url, {
                method: 'GET',
                credentials: 'include'
            })
            .then(response => {
                if (response.status >= 400) {
                    const error = new Error(response.statusText);
                    error.status = response.status;
                    return Promise.reject(error);
                }
                return response.json();
            })
            .then(data => {
                this._data = data;
                events.emit('shopperData', null, data);
            })
            .catch(error => {
                events.emit('shopperData', error);
            });
    }

    /**
     * Configure this loader
     *
     * @param {Object} opts Options for the call
     *    @param {String} opts.url URL to the GUI service
     *    @param {Number|String} [opts.privateLabelId=1] Private Label id (e.g. 1 for GoDaddy, 2 for BlueRazor, etc.)
     *    @param {Number|String} opts.shopperId Shopper id number
     * @returns {Boolean} true if configuration succeeded, false if there was missing data
     *
     * @memberof ShopperDataLoader
     * @private
     */
    _configure(opts) {
        if (!opts.url) {
            return false;
        }

        this._url = opts.url;
        this._shopperId = opts.shopperId;
        this._privateLabelId = opts.privateLabelId || 1;

        return true;
    }

    /**
     * Callback for shopper data subscriptions
     * @callback ShopperDataCallback
     * @param {Object|String} err Error, if any
     * @param {Object} data Shopper data object
     */
    /**
     * Subscribe for shopper data when it becomes available.
     *
     * Guaranteed to be async -- if data is immediately available, callback is run on next tick.
     * @param {Object} [opts] Optional options for the call -- typically only passed in from UX Platform headers
     * @param {String}        opts.url URL to the GUI service
     * @param {Number|String} opts.privateLabelId Private Label id (e.g. 1 for GoDaddy, 2 for BlueRazor, etc.)
     * @param {Number|String} opts.shopperId Shopper id number
     * @param {ShopperDataCallback} cb Callback
     *
     * @memberof ShopperDataLoader
     * @public
     */
    shopperData(opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = null;
        }

        if (this._data) {
            setTimeout(cb.bind(undefined, null, this._data), 0); // eslint-disable-line no-undefined
            return;
        }

        events.once('shopperData', cb);

        if (opts) {
            if (!this._configure(opts)) {
                setTimeout(cb.bind(undefined, { // eslint-disable-line no-undefined
                    error: 'opts object is incomplete'
                }), 0);
                return;
            }

            this._requestShopperData();
        } else if (this._url && this._shopperId && this._privateLabelId) {
            // Loader is already configured, so kick off the request now
            this._requestShopperData();
        }
    }

    /**
     * Configure this loader only, but do not request data unless something else on the page needs it
     * This is only used by the UXP headers when the header itself doesn't need GUI data.
     * If the header does need data, it should call {@link shopperData}(opts, cb) instead.
     *
     * @param {Object} opts Options for the call
     *    @param {String} opts.url URL to the GUI service
     *    @param {Number|String} [opts.privateLabelId=1] Private Label id (e.g. 1 for GoDaddy, 2 for BlueRazor, etc.)
     *    @param {Number|String} opts.shopperId Shopper id number
     * @returns {Boolean} true if configuration succeeded, false if there was missing data
     *
     * @memberof ShopperDataLoader
     * @public
     */
    configureOnly(opts) {
        if (!this._configure(opts)) {
            return false;
        }

        // If there are queued requests, kick off the GUI call
        if (events.listeners('shopperData', true)) {
            this._requestShopperData();
        }

        return true;
    }
}

// Export a singleton ShopperDataLoader object
const shopperDataLoader = new ShopperDataLoader();
export {
    shopperDataLoader as
    default,
    ShopperDataLoader
};