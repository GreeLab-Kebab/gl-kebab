function __$styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') {
        return;
    }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

import React, {
    PureComponent,
    createRef
} from 'react';
import PropTypes from 'prop-types';
import {
    debounce,
    differenceBy,
    isEqual,
    without
} from 'lodash';
import Bricks from 'bricks.js';
import LazyLoad, {
    forceCheck
} from 'react-lazyload';
import {
    Attribution,
    Gif
} from '@giphy/react-giphy-brand';
import styled from 'styled-components';
import {
    distanceInWordsToNow
} from 'date-fns';
import {
    giphyIndigo,
    giphyRed,
    giphyYellow
} from '@giphy/js-brand';

var getTvProps = function getTvProps(_ref, columnWidth, gutterSize) {
    var channels = _ref.channels,
        channel = _ref.channel,
        _ref$columnSpan = _ref.columnSpan,
        columnSpan = _ref$columnSpan === undefined ? 1 : _ref$columnSpan,
        _ref$aspectRatio = _ref.aspectRatio,
        aspectRatio = _ref$aspectRatio === undefined ? 16 / 9 : _ref$aspectRatio,
        _ref$align = _ref.align,
        align = _ref$align === undefined ? 'left' : _ref$align,
        _ref$GiphyTV = _ref.GiphyTV,
        GiphyTV = _ref$GiphyTV === undefined ? function() {
            return null;
        } : _ref$GiphyTV;
    var columns = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    var width = Math.round(columnSpan * columnWidth + (columnSpan - 1) * gutterSize);
    var columnOffsetX = 0;

    // column alignment
    if (align === 'center') {
        columnOffsetX = Math.round((columns - columnSpan) / 2);
    }
    if (align === 'right') {
        columnOffsetX = columns - columnSpan;
    }

    return {
        channels: channels || [channel || '@trending'],
        width: width,
        height: Math.round(width / aspectRatio),
        top: 0,
        left: columnOffsetX ? Math.round(columnOffsetX * (columnWidth + gutterSize)) : 0,
        columnOffset: columnOffsetX,
        columnSpan: columnSpan,
        margin: gutterSize,
        GiphyTV: GiphyTV
    };
};

var getGifOffset = function getGifOffset(gifIndex, _ref2) {
    var height = _ref2.height,
        columnSpan = _ref2.columnSpan,
        margin = _ref2.margin,
        columnOffset = _ref2.columnOffset;

    if (gifIndex >= columnOffset && gifIndex < columnSpan + columnOffset) {
        return height + margin;
    }
    return 0;
};

function throttle(fn) {
    var _arguments = arguments;
    var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

    var last = void 0,
        deferTimer = void 0;
    return function() {
        var now = +new Date(),
            args = _arguments;
        if (last && now < last + threshhold) {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(function() {
                last = now;
                fn.apply(scope, args);
            }, threshhold);
        } else {
            last = now;
            fn.apply(scope, args);
        }
    };
}

var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
};

var createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();







var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target;
};



var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
};









var taggedTemplateLiteral = function(strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
};









var toConsumableArray = function(arr) {
    if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
    } else {
        return Array.from(arr);
    }
};

var _templateObject = taggedTemplateLiteral(['\n    box-sizing: border-box;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border: ', ';\n    background: ', ';\n'], ['\n    box-sizing: border-box;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border: ', ';\n    background: ', ';\n']);
var _templateObject2 = taggedTemplateLiteral(['\n    font-family: \'NexaBlack\';\n    pointer-events: none;\n    background-color: ', ';\n    color: black;\n    font-weight: 900;\n    font-size: 18px;\n    height: 34px;\n    width: 34px;\n    position: absolute;\n    top: 0;\n    right: 0;\n    line-height: 34px;\n    text-align: center;\n'], ['\n    font-family: \'NexaBlack\';\n    pointer-events: none;\n    background-color: ', ';\n    color: black;\n    font-weight: 900;\n    font-size: 18px;\n    height: 34px;\n    width: 34px;\n    position: absolute;\n    top: 0;\n    right: 0;\n    line-height: 34px;\n    text-align: center;\n']);
var _templateObject3 = taggedTemplateLiteral(['\n    pointer-events: none;\n    color: #fff;\n    font-weight: 900;\n    font-size: 36px;\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n'], ['\n    pointer-events: none;\n    color: #fff;\n    font-weight: 900;\n    font-size: 36px;\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n']);
var _templateObject4 = taggedTemplateLiteral(['\n    align-items: center;\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n    padding-bottom: ', ';\n'], ['\n    align-items: center;\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n    padding-bottom: ', ';\n']);
var _templateObject5 = taggedTemplateLiteral(['\n    bottom: 6px;\n    left: 6px;\n    position: absolute;\n    transform: scale(0.8);\n    transform-origin: left bottom;\n'], ['\n    bottom: 6px;\n    left: 6px;\n    position: absolute;\n    transform: scale(0.8);\n    transform-origin: left bottom;\n']);
var _templateObject6 = taggedTemplateLiteral(['\n    background-color: rgba(0, 0, 0, 0.66);\n    color: ', ';\n    width: 36px;\n    height: 36px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    line-height: 42px;\n    font-size: 18px;\n    text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.5);\n    text-align: center;\n'], ['\n    background-color: rgba(0, 0, 0, 0.66);\n    color: ', ';\n    width: 36px;\n    height: 36px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    line-height: 42px;\n    font-size: 18px;\n    text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.5);\n    text-align: center;\n']);

var Overlay = styled.div(_templateObject, function(props) {
    return props.isSelected ? '6px solid ' + giphyIndigo : '6px solid transparent';
}, function(props) {
    return props.showDetails ? 'rgba(0, 0, 0, 0.4)' : 'transparent';
});

var IndexLabel = styled.div(_templateObject2, giphyYellow);

var RatingLabel = styled.div(_templateObject3);

var Details = styled.div(_templateObject4, function(props) {
    return props.padded ? '48px' : '0px';
});

var AttributionWrapper = styled.div(_templateObject5);

var LockIcon = styled.div(_templateObject6, giphyRed);

var GifSelectionOverlay = function GifSelectionOverlay(_ref) {
    var gif = _ref.gif,
        _ref$index = _ref.index,
        index = _ref$index === undefined ? 0 : _ref$index,
        _ref$showDetails = _ref.showDetails,
        showDetails = _ref$showDetails === undefined ? false : _ref$showDetails,
        onClick = _ref.onClick;

    var isSelected = index > 0;
    var hasUser = !!gif.user;
    var style = !isSelected ? gif.style || {} : null;
    var isPrivate = hasUser && !gif.user.is_public;
    return React.createElement(
        'div',
        null,
        React.createElement(
            Overlay, {
                isSelected: isSelected,
                showDetails: showDetails,
                style: style,
                'data-gifurl': gif.url,
                onClick: onClick
            },
            showDetails && React.createElement(
                Details, {
                    padded: hasUser,
                    title: 'Uploaded ' + distanceInWordsToNow(new Date(gif.create_datetime)) + ' ago'
                },
                gif.rating && React.createElement(
                    RatingLabel,
                    null,
                    gif.rating.toUpperCase()
                ),
                hasUser && React.createElement(
                    AttributionWrapper,
                    null,
                    React.createElement(Attribution, {
                        user: gif.user
                    }),
                    isPrivate && React.createElement(LockIcon, {
                        className: 'ss-lock'
                    })
                )
            )
        ), !showDetails && isSelected && React.createElement(
            IndexLabel,
            null,
            index
        )
    );
};

__$styleInject("._container_15ggs_3 {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    position: relative;\n    width: 100%;\n}\n._containerSelection_15ggs_8 {\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n._gifWrapper_15ggs_13 {\n    -webkit-animation: _fadeIn_15ggs_1 .2s ease-out;\n            animation: _fadeIn_15ggs_1 .2s ease-out;\n}\n\n@-webkit-keyframes _fadeIn_15ggs_1 {\n    0% { opacity: 0; }\n    100% { opacity: 1; }\n}\n\n@keyframes _fadeIn_15ggs_1 {\n    0% { opacity: 0; }\n    100% { opacity: 1; }\n}", {});
var gutterSize = "16px";




var css = {
    "gutterSize": "16px",
    "container": "_container_15ggs_3",
    "containerSelection": "_containerSelection_15ggs_8 _container_15ggs_3",
    "gifWrapper": "_gifWrapper_15ggs_13",
    "fadeIn": "_fadeIn_15ggs_1"
};

var DebugOverlay = function DebugOverlay(_ref) {
    var isSeen = _ref.isSeen;
    return React.createElement(
        'div', {
            className: css.selected,
            style: {
                border: 0,
                backgroundColor: 'rgba(0, 0, 0, ' + (isSeen ? 0.5 : 0) + ')',
                pointerEvents: 'none'
            }
        },
        isSeen ? 'SEEN' : ''
    );
};

var GridTV = function GridTV(_ref) {
    var channels = _ref.channels,
        left = _ref.left,
        top = _ref.top,
        width = _ref.width,
        height = _ref.height,
        GiphyTV = _ref.GiphyTV;
    return React.createElement(
        'div', {
            style: {
                width: width,
                height: height,
                left: left,
                top: top,
                position: 'absolute'
            }
        },
        React.createElement(
            LazyLoad, {
                height: height,
                unmountIfInvisible: true
            },
            React.createElement(GiphyTV, {
                channels: channels.length ? channels : ['@trending'],
                hideLogo: true,
                letterbox: false,
                random: true,
                apiKey: '3eFQvabDx69SMoOemSPiYfh9FY0nzO9x'
            })
        )
    );
};

var _class$1;
var _temp2$1;

var array = PropTypes.array;
var bool = PropTypes.bool;
var element = PropTypes.element;
var number = PropTypes.number;
var string = PropTypes.string;
var object = PropTypes.object;
var oneOfType = PropTypes.oneOfType;
var shape = PropTypes.shape;
var func = PropTypes.func;
var Grid = (_temp2$1 = _class$1 = function(_PureComponent) {
    inherits(Grid, _PureComponent);

    function Grid() {
        var _ref;

        var _temp, _this, _ret;

        classCallCheck(this, Grid);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Grid.__proto__ || Object.getPrototypeOf(Grid)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
            gifWidth: 0,
            selectedGifIds: [],
            seenGifIds: [],
            showGifDetails: false
        }, _this.loadedGifs = [], _this.onResize = throttle(_this.updateGifWidth, 250, _this), _this.onScroll = throttle(_this.scroll, 250, _this), _this.onKeyDown = _this.keyDown.bind(_this), _this.checkForSeenGifs = debounce(function() {
            // iterate through all gifs that have been loaded
            // but not seen yet, and make sure they are fully
            // visible in the viewport before considering
            // them as seen.
            var _this$props = _this.props,
                gifs = _this$props.gifs,
                onGifSeen = _this$props.onGifSeen;
            var seenGifIds = _this.state.seenGifIds;

            var newSeenIds = [];
            _this.loadedGifs.forEach(function(_ref2) {
                var gifId = _ref2.gifId,
                    img = _ref2.img;

                if (seenGifIds.indexOf(gifId) < 0) {
                    var _img$getBoundingClien = img.getBoundingClientRect(),
                        left = _img$getBoundingClien.left,
                        top = _img$getBoundingClien.top,
                        bottom = _img$getBoundingClien.bottom,
                        right = _img$getBoundingClien.right;

                    if (left >= 0 && top >= 0 && bottom <= window.innerHeight && right <= window.innerWidth) {
                        newSeenIds.push(gifId);
                        onGifSeen && onGifSeen(gifs.find(function(gif) {
                            return gif.id === gifId;
                        }));
                    }
                }
            });
            if (newSeenIds.length) {
                _this.loadedGifs = _this.loadedGifs.filter(function(item) {
                    return newSeenIds.indexOf(item.gifId) < 0;
                });
                _this.setState({
                    seenGifIds: [].concat(toConsumableArray(seenGifIds), newSeenIds)
                });
            }
        }, 300), _this.onGifVisible = function(_ref3, img) {
            var gifId = _ref3.id;
            var seenGifIds = _this.state.seenGifIds;
            // if this gif has not triggered its onSeen
            // callback yet, add it to the loadedGifImages
            // dict and call checkForSeenGifs

            if (seenGifIds.indexOf(gifId) < 0) {
                _this.loadedGifs.push({
                    gifId: gifId,
                    img: img
                });
                _this.checkForSeenGifs();
            }
        }, _this.setSelectedGifs = function(gifs) {
            _this.setState({
                selectedGifIds: gifs.map(function(g) {
                    return g.id;
                })
            });
        }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Grid, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            var selectedGifs = this.props.selectedGifs;

            if (selectedGifs && selectedGifs.length) {
                this.setState({
                    selectedGifIds: selectedGifs.map(function(gif) {
                        return gif.id;
                    })
                });
            }
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _props = this.props,
                columns = _props.columns,
                gutter = _props.gutter,
                sizes = _props.sizes,
                selectionMode = _props.selectionMode,
                onLoadMore = _props.onLoadMore;

            // bricks

            this.bricks = Bricks({
                container: this.inner,
                packed: 'data-packed',
                sizes: sizes || [{
                    columns: columns,
                    gutter: gutter
                }]
            });

            // size
            this.updateGifWidth();

            // events
            if (window) {
                window.addEventListener('resize', this.onResize, false);
                if (onLoadMore) {
                    window.addEventListener('scroll', this.onScroll, false);
                    // check after packed and update if we're on a big monitor
                    this.bricks.on('pack', this.onScroll);
                    this.bricks.on('update', this.onScroll);
                }
            }
            selectionMode && this.bindSelectionEvents();
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var _props2 = this.props,
                selectionMode = _props2.selectionMode,
                onLoadMore = _props2.onLoadMore;

            clearTimeout(this.resizeDelay);
            clearTimeout(this.scrollDelay);
            window && window.removeEventListener('resize', this.onResize, false);
            window && onLoadMore && window.removeEventListener('scroll', this.onScroll, false);
            selectionMode && this.unbindSelectionEvents();
            if (onLoadMore) {
                this.bricks.off('pack', this.onScroll);
                this.bricks.off('update', this.onScroll);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(_ref4) {
            var nextSelectionMode = _ref4.selectionMode,
                nextSelectedGifs = _ref4.selectedGifs,
                nextGifs = _ref4.gifs;

            if (nextSelectionMode !== this.props.selectionMode) {
                this.setState({
                    selectedGifIds: [],
                    showGifDetails: false
                });
            }

            if (nextSelectedGifs !== this.props.selectedGifs) {
                this.setState({
                    selectedGifIds: nextSelectedGifs.map(function(gif) {
                        return gif.id;
                    })
                });
            }

            var selectedGifIds = this.state.selectedGifIds;
            var currentGifs = this.props.gifs;

            if (currentGifs !== nextGifs) {
                if (nextGifs.length < currentGifs.length) {
                    // find any removed gifs
                    var removedIds = differenceBy(currentGifs, nextGifs, 'id').map(function(_ref5) {
                        var id = _ref5.id;
                        return id;
                    });
                    // make sure they're not selected
                    var newSelectedGifIds = without.apply(undefined, [selectedGifIds].concat(toConsumableArray(removedIds)));
                    this.setState({
                        selectedGifIds: newSelectedGifIds
                    });
                }
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            var _props3 = this.props,
                gifs = _props3.gifs,
                gutter = _props3.gutter,
                columns = _props3.columns,
                selectionMode = _props3.selectionMode,
                onSelectionUpdate = _props3.onSelectionUpdate;
            var _state = this.state,
                selectedGifIds = _state.selectedGifIds,
                gifWidth = _state.gifWidth;


            var numberOfOldGifs = prevProps.gifs.length;
            var numberOfNewGifs = gifs.length;

            if (prevProps.gutter !== gutter || prevProps.columns !== columns) {
                this.updateGifWidth();
            }

            if (prevState.gifWidth !== gifWidth) {
                this.bricks.pack();
                forceCheck();
            }

            if (prevProps.selectionMode !== selectionMode) {
                selectionMode ? this.bindSelectionEvents() : this.unbindSelectionEvents();
            }

            if (!isEqual(prevProps.gifs, gifs)) {
                if (numberOfNewGifs > numberOfOldGifs) {
                    // we just added new gifs
                    this.bricks.update();
                } else {
                    // we changed existing gifs or removed a gif
                    this.bricks.pack();
                }
                forceCheck();
            }

            if (!isEqual(selectedGifIds, prevState.selectedGifIds)) {
                onSelectionUpdate && onSelectionUpdate(selectedGifIds);
            }
        }
    }, {
        key: 'bindSelectionEvents',
        value: function bindSelectionEvents() {
            window && window.addEventListener('keydown', this.onKeyDown, false);
            document && document.addEventListener('click', this.onDocumentClick, false);
        }
    }, {
        key: 'unbindSelectionEvents',
        value: function unbindSelectionEvents() {
            window && window.removeEventListener('keydown', this.onKeyDown, false);
            document && document.removeEventListener('click', this.onDocumentClick, false);
        }
    }, {
        key: 'updateGifWidth',
        value: function updateGifWidth() {
            if (!this.el) return;

            var _props4 = this.props,
                columns = _props4.columns,
                gutter = _props4.gutter;

            var gutterOffset = gutter * (columns - 1);
            var width = this.el.offsetWidth;
            var gifWidth = Math.floor((width - gutterOffset) / columns);
            this.setState({
                gifWidth: gifWidth
            });
        }
    }, {
        key: 'scroll',
        value: function scroll() {
            if (!this.el) return;
            var _props5 = this.props,
                onGifSeen = _props5.onGifSeen,
                onLoadMore = _props5.onLoadMore;

            var _el$getBoundingClient = this.el.getBoundingClientRect(),
                bottom = _el$getBoundingClient.bottom;

            if (bottom <= window.innerHeight * 1.5) {
                onLoadMore();
            }
            onGifSeen && this.checkForSeenGifs();
        }
    }, {
        key: 'keyDown',
        value: function keyDown(e) {
            var gifs = this.props.gifs;
            var selectedGifIds = this.state.selectedGifIds;

            var hasOneSelection = selectedGifIds.length === 1;
            var selectedGif = hasOneSelection && gifs.find(function(_ref6) {
                var id = _ref6.id;
                return id === selectedGifIds[0];
            });
            var selectedIndex = selectedGif ? gifs.indexOf(selectedGif) : -1;

            switch (e.which) {
                // alt key
                case 18:
                    this.setState({
                        showGifDetails: !this.state.showGifDetails
                    });
                    break;
                    // esc key
                case 27:
                    this.setState({
                        selectedGifIds: []
                    });
                    break;
                    // left arrow
                case 37:
                    selectedIndex > 0 && this.setState({
                        selectedGifIds: [gifs[selectedIndex - 1].id]
                    });
                    break;
                    // right arrow
                case 39:
                    selectedIndex > -1 && selectedIndex < gifs.length - 1 && this.setState({
                        selectedGifIds: [gifs[selectedIndex + 1].id]
                    });
                    break;
            }
        }
    }, {
        key: 'onGifSelectionClick',
        value: function onGifSelectionClick(_ref7, gif) {
            var shiftKey = _ref7.shiftKey,
                metaKey = _ref7.metaKey;
            var gifs = this.props.gifs;
            var selectedGifIds = this.state.selectedGifIds;

            var updatedGifIds = [].concat(toConsumableArray(selectedGifIds));

            if (metaKey) {
                if (updatedGifIds.indexOf(gif.id) > -1) {
                    updatedGifIds = updatedGifIds.filter(function(id) {
                        return id !== gif.id;
                    });
                } else {
                    updatedGifIds.push(gif.id);
                }
            } else if (shiftKey) {
                var allGifIds = gifs.map(function(gif) {
                    return gif.id;
                });
                var lastSelectedId = updatedGifIds.length ? updatedGifIds[updatedGifIds.length - 1] : null;
                var startIndex = lastSelectedId ? allGifIds.indexOf(lastSelectedId) : 0;
                var endIndex = allGifIds.indexOf(gif.id);
                updatedGifIds = updatedGifIds.concat(allGifIds.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1).filter(function(id) {
                    return selectedGifIds.indexOf(id) < 0;
                }));
            } else {
                updatedGifIds = [gif.id];
            }

            this.setState({
                selectedGifIds: updatedGifIds
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props6 = this.props,
                gifs = _props6.gifs,
                debug = _props6.debug,
                columns = _props6.columns,
                gutter = _props6.gutter,
                autoPlay = _props6.autoPlay,
                showTags = _props6.showTags,
                tvConfig = _props6.tvConfig,
                children = _props6.children,
                overlayElement = _props6.overlayElement,
                selectionMode = _props6.selectionMode,
                onGifHover = _props6.onGifHover,
                onGifSeen = _props6.onGifSeen,
                onGifClick = _props6.onGifClick,
                onGifRightClick = _props6.onGifRightClick,
                onGifTagClick = _props6.onGifTagClick;
            var _state2 = this.state,
                gifWidth = _state2.gifWidth,
                selectedGifIds = _state2.selectedGifIds,
                seenGifIds = _state2.seenGifIds,
                showGifDetails = _state2.showGifDetails;

            var tvProps = tvConfig ? getTvProps(tvConfig, gifWidth, gutter, columns) : null;
            return React.createElement(
                'div', {
                    className: selectionMode ? css.containerSelection : css.container,
                    ref: function ref(c) {
                        return _this2.el = c;
                    }
                },
                tvProps && React.createElement(GridTV, tvProps),
                React.createElement(
                    'div', {
                        ref: function ref(c) {
                            return _this2.inner = c;
                        }
                    },
                    children,
                    gifWidth && gifs.map(function(gif, i) {
                        return React.createElement(
                            'div', {
                                key: gif.id,
                                className: css.gifWrapper,
                                style: {
                                    width: gifWidth,
                                    paddingTop: tvProps && getGifOffset(i, tvProps)
                                }
                            },
                            React.createElement(
                                Gif, {
                                    gif: gif,
                                    showTags: selectionMode ? false : showTags,
                                    autoPlay: autoPlay,
                                    width: gifWidth,
                                    onVisible: debug || onGifSeen ? _this2.onGifVisible : undefined,
                                    onHover: onGifHover,
                                    onClick: onGifClick,
                                    onRightClick: onGifRightClick,
                                    onTagClick: onGifTagClick
                                },
                                gif.overlayElement && gif.overlayElement, !debug && selectionMode ? React.createElement(GifSelectionOverlay, {
                                    gif: gif,
                                    index: selectedGifIds.indexOf(gif.id) + 1,
                                    showDetails: showGifDetails,
                                    onClick: function onClick(e) {
                                        return _this2.onGifSelectionClick(e, gif);
                                    }
                                }) : debug ? React.createElement(DebugOverlay, {
                                    isSeen: seenGifIds.indexOf(gif.id) > -1
                                }) : overlayElement
                            )
                        );
                    })
                )
            );
        }
    }]);
    return Grid;
}(PureComponent), _class$1.propTypes = {
    gifs: array,
    columns: number,
    autoPlay: bool,
    debug: bool,
    gutter: number,
    showTags: bool,
    sizes: object,
    overlayElement: element,
    selectionMode: bool,
    selectedGifs: array,
    onSelectionUpdate: func,
    onGifSeen: func,
    onGifHover: func,
    onGifClick: func,
    onGifRightClick: func,
    onGifTagClick: func,
    onLoadMore: func,
    tvConfig: shape({
        aspectRatio: number,
        channel: oneOfType([string, number]),
        channels: array,
        columnSpan: number,
        align: string
    })
}, _temp2$1);

var _class;
var _temp2;

var GUTTER = parseInt(gutterSize);

var GiphyGrid = (_temp2 = _class = function(_PureComponent) {
    inherits(GiphyGrid, _PureComponent);

    function GiphyGrid() {
        var _ref;

        var _temp, _this, _ret;

        classCallCheck(this, GiphyGrid);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GiphyGrid.__proto__ || Object.getPrototypeOf(GiphyGrid)).call.apply(_ref, [this].concat(args))), _this), _this.gridRef = createRef(), _this.setSelectedGifs = function(gifs) {
            if (_this.gridRef.current) {
                _this.gridRef.current.setSelectedGifs(gifs);
            }
        }, _this.clearSelectedGifs = function() {
            if (_this.gridRef.current) {
                _this.gridRef.current.setSelectedGifs([]);
            }
        }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(GiphyGrid, [{
        key: 'render',
        value: function render() {
            return React.createElement(Grid, _extends({}, this.props, {
                ref: this.gridRef
            }));
        }
    }]);
    return GiphyGrid;
}(PureComponent), _class.propTypes = {
    gifs: PropTypes.array,
    autoPlay: PropTypes.bool,
    columns: PropTypes.number,
    sizes: PropTypes.object,
    debug: PropTypes.bool,
    gutter: PropTypes.number,
    tvConfig: PropTypes.object,
    showTags: PropTypes.bool,
    overlayElement: PropTypes.element,
    selectionMode: PropTypes.bool,
    onSelectionUpdate: PropTypes.func,
    onGifSeen: PropTypes.func,
    onGifHover: PropTypes.func,
    onGifClick: PropTypes.func,
    onGifRightClick: PropTypes.func,
    onGifTagClick: PropTypes.func,
    onLoadMore: PropTypes.func
}, _class.defaultProps = {
    gifs: [],
    autoPlay: true,
    debug: false,
    columns: 4,
    gutter: GUTTER,
    showTags: false,
    selectionMode: false
}, _temp2);

export default GiphyGrid;