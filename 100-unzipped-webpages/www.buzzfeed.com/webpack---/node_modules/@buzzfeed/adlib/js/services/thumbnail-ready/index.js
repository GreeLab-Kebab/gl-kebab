import {
    getBaseUrl
} from '@buzzfeed/bf-utils/lib/query-string';

// js-ad-thumbnail is preferred, but also support userwidget classes for now
const thumbnailSelector = [
    '.js-ad-thumbnail',
    '.bf-image',
    '.bf-image-big',
    '.bf-image-dblbig',
    '.bf-mobile-image',
    '.bf-bg-image',
    '.bf-image-bigstory',
    '.bf-image-dblwidestory',
    '.bf-image-dblbigstory',
    '.bf-image-widestory'
].join(',');

export function checkImgReady(img) {
    // treating `data:image` src as a 1x1 transparent placeholder
    if (!img.src || /^data:image/.test(img.src)) {
        return null;
    }

    let onLoad;
    let unsubscribeRoutine = [];

    // remove query params (like `resize`, `output-quality` etc.) from src
    const format = getBaseUrl(img.src)
        // get file extension
        .split('.').pop();

    const ready = new Promise(function checker(resolve) {
        // if image is already loaded, resolve immediately
        if (img.complete) {
            resolve();
            // if it's a GIF, resolve as soon as image dimensions are known (do not wait for complete `load`)
        } else if (/^gif$/i.test(format)) {
            if (img.naturalHeight) {
                resolve();
            } else {
                // have to use `setTimeout` as images don't have `readystatechange` event or anything like that
                let timeoutId = setTimeout(() => {
                    checker(resolve);
                }, 100);
                unsubscribeRoutine.push(() => clearTimeout(timeoutId));
            }
            // if image is not loaded and `load` handler is not yet attached, wait for `load` event
        } else if (!onLoad) {
            onLoad = () => {
                resolve();
                img.removeEventListener('load', onLoad);
                img.removeEventListener('error', onLoad);
            };
            img.addEventListener('load', onLoad);
            img.addEventListener('error', onLoad);
            unsubscribeRoutine.push(() => {
                img.removeEventListener('load', onLoad);
                img.removeEventListener('error', onLoad);
            });
        }
    });

    ready.unsubscribe = () => {
        unsubscribeRoutine.forEach((fn) => fn());
        unsubscribeRoutine = [];
    };

    return ready;
}

export function checkVideoReady(video) {
    let onMetadata;
    const ready = new Promise((resolve) => {
        if (video.readyState >= HTMLVideoElement.HAVE_METADATA) {
            resolve();
            return;
        }
        onMetadata = () => {
            resolve();
            video.removeEventListener('loadedmetadata', onMetadata);
        };
        video.addEventListener('loadedmetadata', onMetadata);
    });
    ready.unsubscribe = () => video.removeEventListener('loadedmetadata', onMetadata);
    return ready;
}

export function checkBgImgReady() {
    // there is no way to determine when background image loads,
    // but it shouldn't be an issue since elements with background images usually have sizes set with CSS,
    // so it's fine to treat those elements as "ready"
    const ready = Promise.resolve();
    ready.unsubscribe = () => {}; // no-op function
    return ready;
}

export function checkReady(element, state) {
    const thumbnailNodes = element.querySelectorAll(thumbnailSelector);
    thumbnailNodes.forEach((node) => {
        const thumbnailIdx = state.thumbnails.indexOf(node);
        // exit if we're already watching that thumbnail
        if (thumbnailIdx > -1) {
            return;
        }
        let ready;
        if (node.nodeName === 'IMG') {
            ready = checkImgReady(node);
        } else if (node.nodeName === 'VIDEO') {
            ready = checkVideoReady(node);
        } else {
            const bgImage = getComputedStyle(node).backgroundImage;
            if (/^url/.test(bgImage)) {
                ready = checkBgImgReady(node);
            }
        }
        if (ready) {
            state.thumbnails.push(node);
            state.thumbnailsReady.push(ready);
        }
    });
    if (state.thumbnailsReady.length === 0) {
        return null;
    }
    const ready = Promise.all(state.thumbnailsReady);
    ready.unsubscribe = () => {
        // remove references to DOM nodes
        // (which may even have been detached from DOM since they were saved to the list)
        state.thumbnails = [];
        state.thumbnailsReady.forEach((thReady) => {
            thReady.unsubscribe();
        });
        state.thumbnailsReady = [];
    };
    return ready;
}

/**
 * Use this function to determine when ad thumbnail has been loaded enough for its dimensions to be known.
 *
 * Elements with class `js-ad-thumbnail` are considered thumbnails.
 * It's not necessary for the thumbnail to be present in DOM by the time this function is called.
 * - If the thumbnail is an image that is already loaded, the promise will resolve immediately;
 * - If it's a GIF image, the promise will resolve as soon as image dimensions are known;
 * - For other image types the promise will resolve as soon as image loads;
 * - If the thumbnail is a video, the promise will resolve as soon as video metadata loads.
 *
 * @param {HTMLElement} element - the module element
 * @returns {Promise} - resolved when ad thumbnail has been loaded enough
 * The promise has additional method `unsubscribe` to remove event listeners;
 * make sure to call it when destroying module instance
 */
export function thumbnailReady(element) {
    let checkReadyState = {
        // typically there will be only one `.js-ad-thumbnail`, but just in case
        thumbnails: [],
        // array each item of which is a promise that resolves when respective thumbnail is ready
        thumbnailsReady: [],
    };

    let unsubscribe;
    const ready = new Promise((resolve) => {
        let observer;
        let thumbnailsReady;
        unsubscribe = () => {
            if (observer) {
                observer.disconnect();
            }
            if (thumbnailsReady) {
                thumbnailsReady.unsubscribe();
            }
        };

        // exit if thumbnail node already exists in DOM
        thumbnailsReady = checkReady(element, checkReadyState);
        if (thumbnailsReady) {
            thumbnailsReady.then(resolve);
            return;
        }

        // otherwise listen for DOM mutation to see if any of them adds a thumbnail
        observer = new MutationObserver(() => {
            thumbnailsReady = checkReady(element, checkReadyState);
            if (thumbnailsReady) {
                thumbnailsReady.then(resolve);
                observer.disconnect();
            }
        });
        observer.observe(element, {
            'subtree': true,
            'attributes': true,
            'childList': true
        });
    });
    ready.unsubscribe = unsubscribe;
    // when promise resolves, make sure all remaining observers/event listeners/timeouts are cleared
    ready.then(ready.unsubscribe);
    return ready;
}