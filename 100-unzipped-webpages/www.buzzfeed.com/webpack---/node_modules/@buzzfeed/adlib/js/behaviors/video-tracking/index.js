import {
    Application
} from 't3js';
import {
    bfaTrack,
    getScreenOrientation,
    getUniqueEventName
} from '@buzzfeed/buzzblocks/js/services/util/standalone';
import abeagle from '@buzzfeed/buzzblocks/js/services/abeagle';
import solid from '@buzzfeed/buzzblocks/js/services/solid/standalone';


// namespace for easier testing
const util = {
    bfaTrack,
    getScreenOrientation,
    getUniqueEventName
};


const SECS_TO_MS = 1000;

function getOpt(videoData) {
    return {
        dimension3: videoData.wid || 'unknown-ad',
        dimension4: videoData.videoName || 'unknown',
    };
}

/* eslint-disable */
function initMoatTracking(a, c, d, h, k) {
    var f = document.createElement("script"),
        b = [];
    c = {
        adData: {
            ids: c,
            duration: d,
            url: k
        },
        dispatchEvent: function(a) {
            this.sendEvent ? (b && (b.push(a), a = b, b = !1), this.sendEvent(a)) : b.push(a)
        }
    };
    d = "_moatApi" + Math.floor(1E8 * Math.random());
    var e, g;
    try {
        e = a.ownerDocument, g = e.defaultView || e.parentWindow
    } catch (l) {
        e = document, g = window
    }
    g[d] = c;
    f.type = "text/javascript";
    a && a.insertBefore(f, a.childNodes[0] || null);
    f.src = "https://z.moatads.com/" + h + "/moatvideo.js#" + d;
    return c;
}
/* eslint-enable */

/**
 * Behavior for ad video tracking.
 * Note:
 *   - Tracking data must match a certain structure for nielsenMapping
 *   - More info in feedpager/static/js/tracking/bfa/common/nielsenMapping.js
 */
class AdVideoTracking {
    constructor(context) {
        this.context = context;
        this.element = context.getElement();
        /** @type {AdConfig} */
        let config = context.getConfig();
        this.config = config;

        this.segmentStartTime = 0;
        this.videoMuted = true;
        this.isPaused = false;
        this.isPlaying = true;
        this.hasPlayed = false;
        this.segmentRestartsPlayingTimer = null;

        this.moatApi = null;
        this.moatPartnerCode = 'buzzfeedjsvideo132359557321';
        this.moatQuartiles = ['AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile', 'AdVideoComplete'];
        this.moatId = null;

        this.onmessage = {};
        this.onmessage[util.getUniqueEventName('native-video-embed:playback-quartile', this.element)] = this.handleVideoProgress;
        this.onmessage[util.getUniqueEventName('dfp-native-video:play', this.element)] = this.handleVideoPlay;
        this.onmessage[util.getUniqueEventName('dfp-native-video:replay', this.element)] = this.handleVideoReplay;
        this.onmessage[util.getUniqueEventName('dfp-native-video:pause', this.element)] = this.handleVideoPause;
        this.onmessage[util.getUniqueEventName('dfp-native-video:volumechange', this.element)] = this.handleVolumeChange;
        this.onmessage[util.getUniqueEventName('dfp-native-video:loaded-metadata', this.element)] = this.handleLoadedMetadata;

        this.moatEnabled = false;
        this.moatMetaLoadTracked = false; // for meta onload tracking

        abeagle.getExperimentVariant('moat_dfp_native_video_tracking')
            .then((variant) => {
                if (variant === 'on') {
                    this.moatEnabled = true;
                    this.moatId = (Math.floor(Math.random() * 90000000) + 10000).toString() + Date.now();
                }
            })
            .catch(abeagle.defaultErrorHandler);
    }

    initializeMoat(videoData, callback = null) {
        if (this.moatEnabled) {
            let moatIds = {
                'level1': videoData.advertiserId,
                'level2': videoData.orderId,
                'level3': videoData.lineItemId,
                'level4': videoData.creativeId,
                'slicer1': this.config.adPos,
                'slicer2': 'fluid',
                'zMoatBrowser': solid.isAny(['xs', 'sm']) ? 'mobileweb' : 'desktop',
                'zMoatIID': this.moatId
            };

            let videoContainer = this.element.parentElement.querySelector(`#div-gpt-ad-${videoData.wid}`);

            this.moatApi = initMoatTracking(
                videoContainer, moatIds, videoData.duration, this.moatPartnerCode, videoData.source);

            // use callback to make sure we get an event that NEEDS to fire
            // for moat, especially after load
            if (callback) {
                setTimeout(() => callback(), 0);
            }
        }
    }

    getAdVolumeFromVideoData(videoData) {
        return videoData.muted ? 0 : videoData.volume;
    }

    /**
     * Bundles and tracks the video_view_segment
     * @returns {void}
     *
     */
    trackSegment(videoData) {
        // DFP Native Video currently only supports autoplay
        let startType = 'autoplay';

        this._clearSegmentRestartsPlayingTimer();

        let segmentDuration = videoData.currentTime - this.segmentStartTime;

        let bfaRoute = 'track/video/segment';
        let bfaData = {
            n: 'native-video-segment',
            l: this.config.adPos,
            d: videoData.video || 'unknown-ad',
            data: {
                d: segmentDuration * SECS_TO_MS,
                e: 'video_view_segment',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: startType,
                t: this.segmentStartTime * SECS_TO_MS,
                v: videoData.muted ? videoData.muted : 'muted'
            },
            opt: getOpt(videoData),
        };

        util.bfaTrack(bfaRoute, bfaData);
    }

    /**
     * handles when video meta data is loaded
     * can treat this as a onload event even before video starts playing
     * need to track  "AdVideoStart" on this to sync MOAT tracking
     * ADSGROUP-734
     * @param {Object} videoData - data from the video element
     * @returns {void}
     */
    handleLoadedMetadata(videoData) {
        if (this.moatEnabled) {
            if (!this.moatApi) {
                // if this is the case, call again so we can make sure moat tracks it
                this.initializeMoat(videoData, () => this.handleLoadedMetadata(videoData));
            } else if (!this.moatMetaLoadTracked) {
                // let's only call this once for moat for now
                this.moatMetaLoadTracked = true;
                this._dispatchMoatEvent({
                    'type': 'AdVideoStart',
                    'adVolume': this.getAdVolumeFromVideoData(videoData)
                });
            }
        }
    }
    /**
     *  tracks video load event - sets up segment tracking
     * @param {Object} videoData - data from the video element
     * @returns {void}
     */
    handleVideoView(videoData) {
        if (this.moatEnabled && !this.moatApi) {
            this.initializeMoat(videoData);
        }

        this._dispatchMoatEvent({
            'type': 'AdVideoStart',
            'adVolume': this.getAdVolumeFromVideoData(videoData)
        });
        this.segmentStartTime = videoData.currentTime ? videoData.currentTime : 0;

        this._clearSegmentRestartsPlayingTimer();

        this.isPlaying = true;

        // DFP Native Video currently only supports autoplay
        let startType = 'autoplay';

        this.hasPlayed = true;
        let bfaRoute = 'track/video/load';
        let bfaData = {
            t: 'video:load',
            n: 'native-video-load',
            l: this.config.adPos,
            d: videoData.video || 'unknown-ad',
            data: {
                d: Math.round(videoData.duration),
                e: 'video_view',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: startType,
                u: videoData.source,
                v: videoData.muted ? videoData.muted : 'muted',
                ut: '',
            },
            opt: getOpt(videoData),
        };
        util.bfaTrack(bfaRoute, bfaData);
    }

    handleVideoResume(videoData) {
        this._dispatchMoatEvent({
            'type': 'AdPlaying',
            'adVolume': this.getAdVolumeFromVideoData(videoData)
        });

        this._clearSegmentRestartsPlayingTimer();

        this.isPaused = false;
        this.isPlaying = true;

        let startType = 'click_to_play';

        this.hasPlayed = true;

        this.segmentStartTime = videoData.currentTime ? videoData.currentTime : 0;

        let bfaRoute = 'track/video/play';
        let bfaData = {
            n: 'click:native-video-play',
            l: this.config.adPos,
            d: videoData.video || 'unknown-ad',
            data: {
                d: Math.floor(videoData.currentTime),
                e: 'resume',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: startType,
                v: videoData.muted ? videoData.muted : 'muted',
                ut: '',
            },
            opt: getOpt(videoData),
        };
        util.bfaTrack(bfaRoute, bfaData);
    }

    handleVideoReplay(videoData) {
        if (this.moatEnabled) {
            if (this.moatApi) {
                this.moatApi = null;
            }
            this.initializeMoat(videoData);
        }

        this._dispatchMoatEvent({
            'type': 'AdVideoStart',
            'adVolume': this.getAdVolumeFromVideoData(videoData)
        });

        this._clearSegmentRestartsPlayingTimer();

        this.isPlaying = true;

        // Replays are always click to play.
        let startType = 'click_to_play';

        this.hasPlayed = true;

        this.segmentStartTime = videoData.currentTime ? videoData.currentTime : 0;

        let bfaRoute = 'track/video/load';
        let bfaData = {
            t: 'video:load',
            n: 'native-video-load',
            l: this.config.adPos,
            d: videoData.video || 'unknown-ad',
            data: {
                d: Math.round(videoData.duration),
                e: 'video_view',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: startType,
                u: videoData.source,
                v: videoData.muted ? videoData.muted : 'muted',
                ut: '',
            },
            opt: getOpt(videoData),
        };
        util.bfaTrack(bfaRoute, bfaData);
    }

    handleVideoProgress(videoData) {
        this._dispatchMoatEvent({
            'type': this.moatQuartiles[videoData.quartile - 1],
            'adVolume': this.getAdVolumeFromVideoData(videoData)
        });

        let percentage = videoData.quartile * 25 + '%';

        // Video has completed playing - track finish
        if (percentage === '100%') {
            // First track segment and then complete
            // Fixes race condition that causes playheadPosition to increment infinitely
            Promise.resolve(() => this.trackSegment(videoData))
                .then(() => this.onVideoComplete(videoData));

            // Track video progress
        } else {
            let bfaRoute = 'track/video/progress';
            let bfaData = {
                n: 'video:playback',
                l: this.config.adPos,
                d: percentage,
                data: {
                    d: Math.round(videoData.duration),
                    e: 'playback',
                    n: videoData.videoName || 'unknown',
                    o: getScreenOrientation(),
                    p: 1,
                    s: 'autoplay',
                    v: videoData.muted ? 'muted' : 'unmuted',
                },
                opt: getOpt(videoData),
            };
            util.bfaTrack(bfaRoute, bfaData);
        }
    }

    onVideoComplete(videoData) {
        let bfaRoute = 'track/video/finish';
        let bfaData = {
            n: 'video:finish',
            l: this.config.adPos,
            d: '100%',
            data: {
                d: Math.round(videoData.duration),
                e: 'finish',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: 'autoplay',
                v: videoData.muted ? 'muted' : 'unmuted',
            },
            opt: getOpt(videoData),
        };
        util.bfaTrack(bfaRoute, bfaData);
        this.isPlaying = false;
        this.isPaused = false;
    }

    handleVideoPause(videoData) {
        this._dispatchMoatEvent({
            'type': 'AdPaused',
            'adVolume': this.getAdVolumeFromVideoData(videoData)
        });

        if (!this.segmentRestartsPlayingTimer) {
            this.segmentRestartsPlayingTimer = setTimeout(() => {
                this.trackSegment(videoData);
            }, 1000);
        }

        let segmentPauseStartTime = videoData.currentTime ? videoData.currentTime : 0;

        let bfaRoute = 'track/video/pause';
        let bfaData = {
            n: 'click:native-video-pause', //_clickMode || _isMobile ? 'click:native-video-pause' : 'native-video:autopause',
            l: this.config.adPos,
            d: videoData.video || 'unknown-ad',
            data: {
                d: Math.floor(videoData.currentTime),
                e: 'pause',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: 'autoplay',
                t: segmentPauseStartTime * SECS_TO_MS,
                v: videoData.muted ? 'muted' : 'unmuted'
            },
            opt: getOpt(videoData),
        };

        if (!this.isPaused) {
            util.bfaTrack(bfaRoute, bfaData);
            this.isPaused = true;
            this.isPlaying = false;
        }
    }

    /**
     * tracks video mute action on or off
     * @param {boolean} videoMuted - current mute state of player
     * @returns {void}
     */
    handleVideoMute(videoData) {
        this.videoMuted = videoData.muted;

        if (this.hasPlayed) {
            this.trackSegment(videoData);
            this.segmentStartTime = videoData.currentTime ? videoData.currentTime : 0;
        }

        let bfaRoute = 'track/video/mute';
        let bfaData = {
            n: 'video:mute',
            l: this.config.adPos,
            d: videoData.muted ? 'muted' : 'unmuted',
            data: {
                e: 'mute',
                n: videoData.videoName || 'unknown',
                o: getScreenOrientation(),
                p: 1,
                s: 'autoplay',
                t: this.segmentStartTime * SECS_TO_MS,
                v: videoData.muted ? 'muted' : 'unmuted'
            },
            opt: getOpt(videoData),
        };

        util.bfaTrack(bfaRoute, bfaData);
    }

    handleVolumeChange(videoData) {
        this._dispatchMoatEvent({
            'type': 'AdVolumeChange',
            'adVolume': this.getAdVolumeFromVideoData(videoData)
        });

        if (this.videoMuted !== videoData.muted) {
            this.handleVideoMute(videoData);
        }
    }

    handleVideoPlay(videoData) {
        if (this.isPaused) {
            this.handleVideoResume(videoData);
        } else {
            this.handleVideoView(videoData);
        }
    }

    /**
     * Cleanup
     * @ignore
     * @return {void}
     */
    destroy() {
        this.moatApi = null;
        this.moatEnabled = null;
    }

    _dispatchMoatEvent(videoEvent) {
        if (this.moatApi && this.moatEnabled) {
            this.moatApi.dispatchEvent(videoEvent);
        }
    }
    _clearSegmentRestartsPlayingTimer() {
        if (this.segmentRestartsPlayingTimer) {
            clearTimeout(this.segmentRestartsPlayingTimer);
            this.segmentRestartsPlayingTimer = undefined;
        }
    }
}

export const name = 'ad-video-tracking';
export default AdVideoTracking;

Application.addBehavior(name, (context) => new AdVideoTracking(context));