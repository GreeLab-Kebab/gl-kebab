import {
    Application
} from 't3js';
import {
    Deferred
} from '@buzzfeed/buzzblocks/js/services/util/standalone';
import {
    thumbnailReady
} from '../../services/thumbnail-ready';
import ads from '../../../core/ads';


/**
 * Max time to wait for programmatic ad to load
 */
const PROGRAMMATIC_THRESHOLD = 1000;

/**
 * For how long an ad should be displayed to be considered "viewed"
 */
const EXPOSURE_TIME = 1000;


class DimensionObserver {
    constructor(context) {
        this.element = context.getElement();
        this.config = context.getConfig();
        this.context = context;
        this.isActive = true;
        this.ad = {
            type: null,
            height: 0,
            duration: 0
        };

        /**
         * Is resolved when the ad dimensions are known:
         *   - for native video ads - when they fire `ad-native-video-ready` event
         *     (i.e. when video's `loadedmetadata` is fired and the dimensions and duration are known)
         *   - for image display cards and brand posts - when `thumbnailReady` reports the main image is loaded
         *   - for other ads (including programmatic) - when they fire `ad-content-rendered` event
         */

        this.dimensionsReady = new Deferred();
        /**
         * Is resolved when the ad has been on display ~long enough~:
         *   - for native video ads - when they fire `ad-native-video-ended` or `ad-native-video-pause` events
         *     (i.e. when video has played through or has been paused by the user)
         *   - for programmatic ads - after `slotOnloadEvent` GPT event is fired (i.e. when ad iframe fully loads)
         *     or after the timeout specified in `EXPOSURE_TIME` if it's taking too long to load,
         *     waits the time specified in `EXPOSURE_TIME` and then resolves
         *   - for other ads - after `dimensionsReady` is resolved,
         *     waits the time specified in `EXPOSURE_TIME` and then resolves
         */
        this.hasExposed = new Deferred();
    }

    init() {
        if (!this.config.observeDimensions) {
            this.destroy();
            return;
        }

        this.dimensionsReady.then((...args) => this.reportDimensions(...args));
        this.hasExposed.then((...args) => this.reportHasExposed(...args));

        const wid = this.config.wid;
        this.onmessage = {
            [`ad-content-ready-${this.config.wid}`]: ({
                type
            }) => {
                if (type === 'dfp_native_video') {
                    type = 'video';
                }
                this.ad.type = type;
            },

            [`ad-content-rendered-${wid}`]: () => {
                const {
                    type
                } = this.ad;
                if (type !== 'video') {
                    this.dimensionsReady.resolve();
                }
            },
            [`ad-native-video-ready-${wid}`]: ({
                duration
            }) => {
                this.ad.duration = duration;
                this.dimensionsReady.resolve();
            },

            [`ad-native-video-pause--${wid}`]: this.hasExposed.resolve,
            [`ad-native-video-ended--${wid}`]: this.hasExposed.resolve,
        };

        ads.addSlotRenderEndedHandler(this.config.wid, this._handleSlotRenderEnded);
    }

    _handleSlotRenderEnded = (gptEv) => {
        if (gptEv.isEmpty) {
            this.ad.type = 'empty';
            this.dimensionsReady.resolve();
            this.hasExposed.resolve();
        } else if (ads.isProgrammaticSlot(gptEv)) {
            this.ad.type = 'programmatic';
            ads.addSlotOnloadHandler(this.config.wid, this._handleSlotOnload);
            // don't wait for iframe window onload longer than PROGRAMMATIC_THRESHOLD
            this._programmaticTimer = setTimeout(this._handleSlotOnload, PROGRAMMATIC_THRESHOLD);
        } else {
            this._thumbnailReady = thumbnailReady(this.element);
            this._thumbnailReady.then(this.dimensionsReady.resolve);
        }
    }

    _handleSlotOnload = () => {
        this._exposureTimer = setTimeout(this.hasExposed.resolve, EXPOSURE_TIME);
    }

    reportDimensions() {
        if (!this.isActive) {
            return;
        }
        const adType = this.ad.type;
        if (adType !== 'empty') {
            const {
                height
            } = this.element.getBoundingClientRect();
            this.ad.height = height;
        }
        if (adType !== 'video' && adType !== 'programmatic') {
            this._exposureTimer = setTimeout(this.hasExposed.resolve, EXPOSURE_TIME);
        }
        this.context.application.broadcast(`ad-dimensions-ready--${this.config.wid}`, this.ad);
    }

    reportHasExposed() {
        if (!this.isActive) {
            return;
        }
        this.context.application.broadcast(`ad-has-exposed--${this.config.wid}`, this.ad);
        this.removeListeners();
    }

    removeListeners() {
        delete this.onmessage;
        ads.removeSlotRenderEndedHandler(this.config.wid, this._handleSlotRenderEnded);
        ads.removeSlotOnloadHandler(this.config.wid, this._handleSlotOnload);
        if (this._thumbnailReady) {
            this._thumbnailReady.unsubscribe();
        }
        clearTimeout(this._programmaticTimer);
        clearTimeout(this._exposureTimer);
    }

    destroy() {
        this.isActive = false;
        this.removeListeners();
    }
}

export const name = 'ad-dimension-observer';

Application.addBehavior(name, (context) => new DimensionObserver(context));

export default DimensionObserver;