import {
    Application
} from 't3js';
import scrollListener from '@buzzfeed/buzzblocks/js/services/scroll-listener';
import dom from '@buzzfeed/buzzblocks/js/services/dom';
import util from '@buzzfeed/buzzblocks/js/services/util/standalone';

Application.addBehavior('sticky-sidebar-ad', function(context) {
    'use strict';
    //-----------------------------------------------------------
    // Private
    //-----------------------------------------------------------

    // Vars
    var _defaultTopMargin = 20;
    var _defaultBottomMargin = 0;
    var _elOffsetTop;
    var _eventHandlers = [];
    var _lastScrollTop = 0;
    var _sidebarHeight;
    var _minMargin;
    var _magicMargin = 40;
    var _offsetHasBeenReset = false;

    // Elements
    var _element = context.getElement();
    var _stickEl;
    var _navInternalWrapper;
    var _navWrapper;

    //-----------------------------------------------------------
    // Public
    //-----------------------------------------------------------
    /**
     * Behavior sticky sidebar element
     * Module which will use this behavior should have class "js-sticky".
     * This "sticky" element should contain all content
     */
    var _behavior = {};

    /**
     * Returns the number of pixels that the document has already been scrolled vertically.
     * @returns {Number} - scroll in pixels
     */
    function _getScrollPosition() {
        return window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
    }

    /**
     * Calculate top position for sticky element
     * @return {number} Internal Nav height + Nav height + _defaultTopMargin
     */
    function _getNavHeight() {
        var navHeight = 0;
        var navInternalHeight = 0;

        if (_navWrapper) {
            navHeight = dom.size(_navWrapper).height;
        }
        if (_navInternalWrapper) {
            navInternalHeight = dom.size(_navInternalWrapper).height;
        }
        return navInternalHeight + navHeight + _defaultTopMargin;
    }

    /**
     * Waiting for stopped change for module offsetTop
     * @return {void}
     */
    function _waitingForRenderModule() {
        _behavior.timeoutId = setTimeout(function() {
            if (_elOffsetTop === dom.offset(_element).top) {
                _lastScrollTop = _getScrollPosition();
                _behavior.resetSidebarDimensions();
                dom.on(window, 'resize', _behavior.resetSidebarDimensions);
                _behavior.watchingPosition();
                _resetSidebarOffset();

                _behavior.scrollListenerId = scrollListener.add({
                    throttleTimeout: 0,
                    callback: function() {
                        _behavior.watchingPosition();
                        _resetSidebarOffset();
                    },
                });
            } else {
                _elOffsetTop = dom.offset(_element).top;
                _waitingForRenderModule();
            }
        }, 250);
    }

    function _onRender() {
        _stickEl = dom.hasClass(_element, 'js-sticky') ? _element : null;
        if (!_stickEl) {
            return;
        }
        _elOffsetTop = dom.offset(_element).top;
        _navWrapper = dom.findOne(document, '.header');
        _navInternalWrapper = dom.findOne(document, '.int-menu-wrapper');

        _behavior.timeoutId = setTimeout(
            _waitingForRenderModule, 5000);
    }

    /**
     * Reset _elOffsetTop for sidebar when sidebar change the height
     */
    function _resetSidebarOffset() {
        if (!_offsetHasBeenReset && dom.hasClass(_stickEl, 'xs-fixed')) {
            var currentMargin = parseInt(dom.getStyle(_stickEl, 'marginTop'), 10);
            dom.removeClass(_stickEl, 'xs-fixed');
            dom.setStyle(_stickEl, {
                'margin-top': 'auto',
            });

            _elOffsetTop = dom.offset(_element).top;
            _behavior.resetSidebarDimensions();
            dom.addClass(_stickEl, 'xs-fixed');

            //set previous margin
            dom.setStyle(_stickEl, {
                'margin-top': currentMargin + 'px',
            });

            _offsetHasBeenReset = true;
        }
    }

    _eventHandlers[util.getUniqueEventName('module-rendered', _element)] = _onRender;
    _eventHandlers['load-feed'] = _behavior.watchingPosition;
    _behavior.messages = util.getKeys(_eventHandlers);

    _behavior.resetSidebarDimensions = function() {
        _sidebarHeight = dom.size(_stickEl).height + _defaultBottomMargin;
        _minMargin = _elOffsetTop - _getNavHeight();

        dom.setStyle(_stickEl, {
            width: `${dom.size(_element).width}px`,
        });
    };


    /**
     * Check element position and add/remove class xs-fixed.
     * Attaches the sidebar to the bottom of the page
     * @return {void}
     */
    _behavior.watchingPosition = function() {
        var scrollTop = _getScrollPosition();
        var minMargin = _minMargin;

        // scroll direction
        var scrollDelta = _lastScrollTop - scrollTop;
        var scrolledDown;
        if (scrollDelta > 0) {
            scrolledDown = 0;
        } else {
            scrolledDown = 1;
        }
        var isFixedPosition = dom.hasClass(_stickEl, 'xs-fixed');
        const bodyHeight = dom.size(document.body).height;
        const navHeight = _getNavHeight();

        if (
            (
                (bodyHeight - _sidebarHeight - _elOffsetTop > _magicMargin) &&
                !scrolledDown &&
                isFixedPosition
            ) ||
            (
                (bodyHeight > scrollTop + dom.size(_stickEl).height + navHeight) &&
                scrolledDown &&
                scrollTop > minMargin
            )
        ) {

            minMargin = Math.min(scrollTop, minMargin);
            dom.addClass(_stickEl, 'xs-fixed');
            dom.setStyle(_stickEl, {
                'top': navHeight + 'px',
            });

            if (scrollTop - 100 <= minMargin || scrollTop === minMargin) {
                dom.removeClass(_stickEl, 'xs-fixed');
                dom.setStyle(_stickEl, {
                    'margin-top': 'auto',
                });
            }
        }

        _lastScrollTop = scrollTop;
    };

    /**
     * Initialization logic.
     * @ignore
     * @return {void}
     */
    _behavior.init = function() {
        _onRender();
    };

    /**
     * Handles event subscriptions.
     * @param {String} msg - event name.
     * @param {*} data - event data.
     * @listens share-click
     * @return {void}
     */
    _behavior.onmessage = function(msg, data) {
        var handler = _eventHandlers[msg];
        if (typeof handler === 'function') {
            handler.call(this, data);
        }
    };

    /**
     * Cleanup.
     * @ignore
     * @return {void}
     */
    _behavior.destroy = function() {
        scrollListener.remove(_behavior.scrollListenerId);
        dom.off(window, 'resize', _behavior.resetSidebarDimensions);
        clearTimeout(_behavior.timeoutId);
        _element = null;
        _elOffsetTop = null;
        _defaultTopMargin = null;
    };

    return _behavior;
});
export const name = 'sticky-sidebar-ad';