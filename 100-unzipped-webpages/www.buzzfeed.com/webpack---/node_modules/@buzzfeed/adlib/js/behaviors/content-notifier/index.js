import {
    values
} from 'lodash';
import {
    Application
} from 't3js';
import {
    Deferred
} from '@buzzfeed/buzzblocks/js/services/util/standalone';
import ads from '../../../core/ads';
import buzzLoader from '../../services/buzz-loader';


/**
 * @overview
 * Fires event `ad-content-ready` along with ad content data when it's loaded.
 * - Native ads:
 *   Content is considered loaded when `ad-native--loaded` event is fired (@see `DFPMessageListener` mixin);
 *   Event data is what sent from ad iframe via post message.
 *
 * - Programmatic ads:
 *   Content is considered loaded when `slotRenderEnded` GPT event is fired;
 *   Event data is `{'type': 'programmatic'}` object.
 *
 * This is required for `ad-tracking` behavior to track impressions properly
 */
class AdContentNotifier {
    constructor(context) {
        this.context = context;
        this.element = context.getElement();
        /** @type {AdConfig} */
        this.config = context.getConfig();

        const adNativeLoadedMsg = `ad-native--loaded-${this.config.wid}`;

        const nativeContent = new Deferred({
            unsubscribe: () => delete this.onmessage[adNativeLoadedMsg]
        });

        const programmaticContent = new Deferred();
        programmaticContent._resolve = programmaticContent.resolve;
        programmaticContent.resolve = () => programmaticContent._resolve({
            'type': 'programmatic'
        });

        this.contentPending = {
            native: nativeContent,
            programmatic: programmaticContent
        };

        this.onmessage = {
            [adNativeLoadedMsg]: this.handleNativeAdLoad
        };
    }

    handleNativeAdLoad(ad) {
        if (/^buzz/.test(ad.type)) {
            buzzLoader.getBuzzData(ad).then(
                (buzzes) => {
                    if (buzzes.length > 1) {
                        ad.buzzes = buzzes;
                    } else {
                        ad.buzz = buzzes[0];
                    }
                    this.contentPending.native.resolve(ad);
                },
                (error) => this.contentPending.native.reject([ad, error])
            );
        } else {
            this.contentPending.native.resolve(ad);
        }
        this.stopLoadedListening(); // detach listeners now, do not wait for buzz data to load from SCA
    }

    init() {
        const {
            wid
        } = this.config;

        this._onSlotRenderEnded = ((gptEv) => {
            if (ads.isProgrammaticSlot(gptEv, this.config.size)) {
                this.contentPending.programmatic.resolve();
            }
        });
        ads.addSlotRenderEndedHandler(wid, this._onSlotRenderEnded);

        Promise.race(values(this.contentPending))
            .then(
                (ad) => {
                    this.context.application.broadcast(`ad-content-ready-${wid}`, ad);
                    this.element.classList.add('ad-content-ready', `ad-flexible--${ad.type}`);
                },
                ([ad, error]) => {
                    this.context.application.broadcast(`ad-content-error-${wid}`, [ad, error]);
                }
            )
            .then(() => this.stopLoadedListening());
    }

    stopLoadedListening() {
        values(this.contentPending).forEach((deferred) => deferred.unsubscribe());
        ads.removeSlotRenderEndedHandler(this.config.wid, this._onSlotRenderEnded);
    }

    destroy() {
        this.onmessage = {};
        this.stopLoadedListening();
    }
}

export const name = 'ad-content-notifier';
export default AdContentNotifier;

Application.addBehavior(name, (context) => new AdContentNotifier(context));