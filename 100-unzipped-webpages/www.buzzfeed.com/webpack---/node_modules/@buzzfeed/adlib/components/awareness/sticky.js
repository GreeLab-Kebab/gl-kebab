import {
    Application
} from 't3js';
import Sticky, {
    initEvent as stickyInitEvent
} from '@buzzfeed/buzzblocks/js/behaviors/stick-to-top';
import {
    detectTransitionEnd
} from '@buzzfeed/buzzblocks/js/services/dom';
import {
    getUniqueEventName
} from '@buzzfeed/buzzblocks/js/services/util/standalone';
import stickyRegistry from '@buzzfeed/buzzblocks/js/services/sticky-registry';
import dismissBtnTmpl from './_close.html';


const dom = {
    detectTransitionEnd
};
const util = {
    getUniqueEventName
};


/**
 * Scroll depth in px that serves as a threshold for the unit becoming sticky/non-sticky
 */
const STICKY_THRESHOLD = 3000;

const STICKY_PARAMS = {
    default: {
        maxScrollDepth: STICKY_THRESHOLD,
        positionMode: 'translate',
        priority: 'medium',
        breakpoints: ['ALL']
    }
};


class AwarenessSticky extends Sticky {
    constructor() {
        super(...arguments);
        this.config.initOnMsg = true;
        this.reset();

        this.config = { ...this.config,
            ...STICKY_PARAMS.default
        };
        this.unstickAfter = this.getPosition().inDocument + this.config.maxScrollDepth;

        this.onmessage[util.getUniqueEventName('ad-reveal', this.element)] = ({
            type,
            isSticky = true
        } = {}) => {
            /* for some reason this event can be fired multiple times,
            which leads to initializing sticky behavior and listeners each time,
            so we need to prevent this */
            delete this.onmessage[util.getUniqueEventName('ad-reveal', this.element)];

            if (!isSticky) {
                this.destroy();
                return;
            }

            if (type === 'spotlight') {
                this.config.breakpoints = ['md', 'lg'];
            }

            const test = Promise.resolve(type === 'spotlight');
            // @todo Uncomment if we need to re-test
            /*test = abeagle.getExperimentVariant('awareness_card_animated_sticky_exp', {rejectErrors: false})
              .then((variant) => variant === 'sticky');*/
            test.then((shouldStick) => {
                if (!shouldStick) {
                    this.destroy();
                    return;
                }

                this.element.querySelector('.js-awareness-wrapper')
                    .insertAdjacentHTML('beforeend', dismissBtnTmpl.render());
                this.element.querySelector('.js-awareness-dismiss').addEventListener('click', this._onDismiss);

                this.context.application.broadcast(util.getUniqueEventName(stickyInitEvent, this.element));
            });
        };
    }

    reset() {
        this.isHidden = false;
        this.userDismissed = false;
        this.element.classList.remove('sticky--show', 'sticky--hide');
        // add this class so the first appearance can be customized (e.g. not animated on As/Is and News)
        this.element.classList.add('sticky--first-time');
    }

    manageSticky() {
        super.manageSticky(...arguments);

        if (!this.isFixed || this.userDismissed) {
            return;
        }
        if (window.pageYOffset <= this.unstickAfter) {
            this.stickyShow();
        } else {
            this.stickyHide();
        }
    }

    stick() {
        super.stick(...arguments);
        this.isHidden = true;
        // remove until it's added back in `stickyShow`
        // (to prevent paginated sidebar from sliding down and up right afterwards)
        stickyRegistry.remove(this.element);
    }

    unstick() {
        super.unstick(...arguments);
        this.reset();
    }

    stickyShow() {
        if (!this.isFixed || !this.isHidden) {
            return;
        }
        this.isHidden = false;
        this.element.classList.remove('sticky--hide');
        // `top` is the property we animate to show/hide the unit
        dom.detectTransitionEnd(this.element, {
            properties: ['top']
        }).then(() => {
            stickyRegistry.add(this.element, this.stickyRegistryOpts);
        });
        this.element.classList.add('sticky--show');
    }

    stickyHide() {
        if (!this.isFixed || this.isHidden) {
            return;
        }
        this.isHidden = true;
        this.element.classList.remove('sticky--show', 'sticky--first-time');
        dom.detectTransitionEnd(this.element, {
            properties: ['top']
        }).then(() => {
            stickyRegistry.remove(this.element);
        });
        this.element.classList.add('sticky--hide');
    }

    _onDismiss = (ev) => {
        this.userDismissed = true;
        setTimeout(() => this.stickyHide(), 500);
        ev.preventDefault();
    }

    destroy() {
        const dismissBtn = this.element.querySelector('.js-awareness-dismiss');
        if (dismissBtn) {
            dismissBtn.removeEventListener('click', this._onDismiss);
        }
        super.destroy();
    }
}

const name = 'ad-awareness-sticky';

Application.addBehavior(name, (context) => new AwarenessSticky(context));

export {
    name
};