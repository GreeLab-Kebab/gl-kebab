import {
    Application
} from 't3js';
import {
    isObject,
    merge
} from 'lodash';
import prepareTemplate from '@buzzfeed/buzzblocks/js/services/nunjucks-env';
import solid from '@buzzfeed/buzzblocks/js/services/solid/standalone';
import {
    getUniqueEventName
} from '@buzzfeed/buzzblocks/js/services/util/standalone';
import AdError from '../error';


const AD_MANAGER_EVENTS = {
    FEED_LOADED: 'feed-ready-for-ads'
};


/**
 * A special exception that indicates the behavior/module instance is not enabled
 *
 * Using old-style class/inheritance because babel has issues with inheriting from built-in classes.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
 */
function Disabled() {
    Error.apply(this, arguments);
}
Disabled.prototype = Object.create(Error.prototype);
Disabled.prototype.constructor = Disabled;


/**
 * Indicates the end of iteration when a generator-like function returns an object of this type
 * (similar to `done: true` in native generators)
 */
class Done {}

function isDone(obj) {
    return obj instanceof Done;
}


/**
 * @class
 * @classdesc Base class for use with components that dynamically load content and need ads inserted
 * See the readme for usage examples
 */
class AdManager {
    /**
     * @constructor
     * @param {Object} context - T3 context object (passed automatically by T3)
     * @param {String} [options.mode=behavior] - whether the instance will be used as behavior of xpager's T3 module
     *   (the default and preferred way)
     *   or as a standalone T3 module
     */
    constructor(context, {
        mode
    } = {
        mode: 'behavior'
    }) {
        this.operationMode = {
            isBehavior: mode === 'behavior',
            isModule: mode === 'module'
        };
        this.config = (this.operationMode.isBehavior ? context.getConfig('ads') : context.getConfig()) || {};
        this.element = context.getElement();
        if (this.operationMode.isBehavior) {
            this.feedLoadedMsg = getUniqueEventName(AD_MANAGER_EVENTS.FEED_LOADED, this.element);
        } else {
            this.feedLoadedMsg = this.feedLoadedMsg || this.config.feedLoadedMsg;
        }
        this.onmessage = {};
        this._state = {};
        this.isActive = true;
    }

    init() {
        this.resolveConfig();
        this.initialized = Promise.resolve()
            .then(() => this.isEnabled())
            .then((isEnabled) => {
                // if it has been destroyed elsewhere while waiting for `isEnabled`
                if (!this.isActive || !isEnabled) {
                    throw new Disabled();
                }
            })
            .then(() => this.configure());

        // handle possible errors and make sure a `catch` won't accidentally suppress them
        // if someone `then`s on `init` return value
        this.initialized.catch((reason) => {
            if (this.operationMode.isModule) {
                Application.stop(this.element);
            } else {
                this.destroy();
            }
            return (reason instanceof Disabled) ? Promise.resolve() : Promise.reject(reason);
        });

        if (this.feedLoadedMsg) {
            this.onmessage[this.feedLoadedMsg] = this.handleFeedLoad;
        }

        return this.initialized; // for tests
    }

    destroy() {
        this.isActive = false;
        delete this.onmessage;
        delete this._state;
        delete this.element;
    }

    /**
     * Specifies whether the instance is enabled;
     * can be async
     * @returns {(Boolean|Promise)}
     */
    isEnabled() {
        // ad components whose `is_enabled` evaluates to False on backend will end up as nulls on frontend
        return (
            this.units.filter((ad) => ad).length > 0 ||
            this.unitsRepeated.filter((ad) => ad).length > 0
        );
    }

    /**
     * Configures the instance parameters such as density (for example, based on page classification or an A/B test);
     * can be async
     * @returns {(undefined|Promise)}
     */
    configure() {}

    /**
     * Resolves config options
     */
    resolveConfig() {
        const breakpoints = Object.keys(solid.cssBreakpoints);
        const breakpoint = solid.getBreakPoint();
        const resolve = (key) => {
            let value = this[`${key}_${breakpoint}`] || this.config[`${key}_${breakpoint}`];
            if (value !== undefined) {
                return value;
            }
            value = this[key] || this.config[key];
            // if it's not an object or doesn't contain neither breakpoints keys nor `default`, it must be a plain value
            if (!isObject(value) || !(breakpoints.some((bp) => bp in value) || 'default' in value)) {
                return value;
            }
            if (breakpoint in value) {
                value = value[breakpoint];
            } else {
                value = value.default;
            }
            return value;
        };

        this.units = resolve('units') || [];
        this.unitsRepeated = resolve('unitsRepeated') || [];
        this.placements = resolve('placements') || [];
        this.density = Number(resolve('density')) || 0;
    }

    /**
     * Generates a sequence of ad units and returns next ad on every call,
     * unless `{pause: true}` is passed, in which case the last return value will be returned on next call too.
     * First uses units from the `units` array,
     * then cycles through the `unitsRepeated` array indefinitely.
     * Restarts from the beginning when `reset` is called
     * @param {Boolean} [options.pause=false] - whether to go to next ad or to pause on last one
     * @returns {(Object|Done)} - ad unit config or a special `Done` instance
     *   when all available ad units are already used
     */
    getNextAd({
        pause
    } = {
        pause: false
    }) { // @todo Consider using a generator instead?
        if (!('currAd' in this._state)) {
            this._state.currAd = {
                idx: -1,
                isStale: true
            };
        }
        const state = this._state.currAd;

        if (isDone(state.ad)) {
            return state.ad;
        }

        if (pause) {
            state.isStale = false;
            return state.ad;
        }
        if (!state.isStale) {
            state.isStale = true;
            return state.ad;
        }

        const idx = state.idx + 1;
        const ad = this.getAd(idx);
        state.ad = ad;
        state.idx = idx;
        state.isStale = true;

        return ad || null;
    }

    getAd(idx) {
        let ad;
        let isRepeated = false;
        if (idx < this.units.length) {
            ad = this.units[idx];
        } else if (this.unitsRepeated.length > 0) {
            // cycle through repeated units infinitely
            ad = this.unitsRepeated[(idx - this.units.length) % this.unitsRepeated.length];
            isRepeated = true;
        } else {
            ad = new Done();
        }

        // for when the unit has additional template vars besides `slot`
        if (ad && !isDone(ad) && !('slot' in ad)) {
            ad = {
                'slot': ad
            };
        }

        // `isInfinitePost` logic is not related to base ad manager itself
        // @todo Move it where it belongs
        if (isRepeated || this.isInfinitePost) {
            // make sure wids don't repeat on the page
            ad.slot.isInfinite = true;
        }

        return ad;
    }

    /**
     * Generates a sequence of ad positions in feed and returns next position on every call,
     * unless `{pause: true}` is passed, in which case the last return value will be returned on next call too.
     * First uses positions from the `placements` array, if provided,
     * then switches to calculating positions based on `density` and continues indefinitely.
     * Restarts from the beginning when `reset` is called
     * @param {Boolean} [options.pause=false] - whether to go to next ad or to pause on last one
     * @returns {(Number|Done)} - position in feed or a special `Done` instance
     *   when all available positions are already used
     */
    getNextPlacement({
        pause
    } = {
        pause: false
    }) { // @todo Consider using a generator instead?
        if (!('currPlacement' in this._state)) {
            this._state.currPlacement = {
                idx: -1,
                placement: -1,
                isStale: true
            };
        }
        const state = this._state.currPlacement;

        if (isDone(state.placement)) {
            return state.placement;
        }

        if (pause) {
            state.isStale = false;
            return state.placement;
        }
        if (!state.isStale) {
            state.isStale = true;
            return state.placement;
        }

        const placements = this.placements;
        const density = this.density;
        const idx = state.idx + 1;

        let placement;
        if (idx < placements.length) {
            // subtract 1 since config placements are 1-based while the iteration is 0-based
            placement = placements[idx] - 1;
            // density will be 0 if density settings for this breakpoint were not found in the config
        } else if (density > 0) {
            placement = state.placement + density;
        } else {
            placement = new Done();
        }

        state.placement = placement;
        state.idx = idx;
        state.isStale = true;

        return placement;
    }

    /**
     * Handles `FEED_LOADED` event
     * @param {(NodeList|HTMLCollection|Array)} feedItems - HTML elements representing feed items
     */
    handleFeedLoad(feedItems) {
        return this.initialized.then(
            () => this.injectAds(feedItems),
            () => {} // no need to do anything here, errors will be handled in the dedicated `catch` (see above)
        );
    }

    /**
     * Inserts ads between the feed items according to rules specified in the config
     * @param {(NodeList|HTMLCollection|Array)} feedItems - HTML elements representing feed items
     */
    injectAds(feedItems) {
        if (!('currFeedItem' in this._state)) {
            this._state.currFeedItem = {
                idx: -1
            };
        }
        const state = this._state.currFeedItem;

        if (isDone(state.item)) {
            return;
        }

        // skip feed items processed at previous occurences of `FEED_LOADED` event
        // and go straight to new ones
        let _idx = state.item ? [].indexOf.call(feedItems, state.item) + 1 : 0;
        let feedItemIdx = state.idx;
        let feedItem = state.item;
        for (_idx; _idx < feedItems.length; _idx++) {
            feedItem = feedItems[_idx];

            // omit unwanted elements (e.g. hidden on this breakpoint)
            if (!this.isEligibleForAd(feedItem)) {
                continue;
            }

            // increment the counter since this feed item is eligible for ad
            feedItemIdx++;

            const newFeedItem = this.processFeedItem(feedItem, feedItemIdx);
            if (isDone(newFeedItem)) {
                feedItem = new Done();
                break;
            } else if (newFeedItem !== feedItem) {
                // increment the counter since the ad is now a feed item too
                feedItemIdx++;
            }
        }

        // keep a reference to last feed item (whether it's a regular item or a newly inserted ad)
        // so we can start from there the next time `FEED_LOADED` event occurs
        state.item = feedItem;
        state.idx = feedItemIdx;
    }

    /**
     * Inserts an ad before the feed item if there should be one
     * @param {HTMLElement} feedItem - HTML element representing feed item
     * @param {Number} feedItemIdx - position of the feed item in the feed
     * @returns {(HTMLElement|Done)} - HTML element representing newly inserted ad
     *   or the feed item itself if no ad was inserted,
     *   or a special `Done` instance when all available ad units or positions are already used
     */
    processFeedItem(feedItem, feedItemIdx) {
        // in most cases only `feedItemIdx` will be needed, but also pass `feedItem` just in case
        let ad = this.getAdForPlacement(feedItemIdx, feedItem);

        // if all ads are already inserted or no next placement is defined
        if (isDone(ad)) {
            return new Done();
        }

        // if there should be no ad after this item
        if (!ad) {
            return feedItem;
        }

        ad = this.prepareAd(ad, feedItemIdx);
        const adTemplate = this.getAdModuleTemplate(ad);
        if (!adTemplate) {
            return feedItem;
        }
        const adMarkup = prepareTemplate(adTemplate).render(ad);
        let adFeedItem;
        let adElement; // for application starting
        if (this.config.injectMethod === 'inside') {
            feedItem.insertAdjacentHTML('afterbegin', adMarkup);
            adFeedItem = feedItem;
            adElement = feedItem.firstElementChild;
        } else if (this.config.injectMethod === 'after') {
            feedItem.insertAdjacentHTML('afterend', adMarkup);
            adElement = adFeedItem = feedItem.nextElementSibling;
        } else {
            feedItem.insertAdjacentHTML('beforebegin', adMarkup);
            adElement = adFeedItem = feedItem.previousElementSibling;
        }

        if (adElement.hasAttribute('data-module')) {
            Application.start(adElement);
        } else { // if nested in a wrapper
            Application.startAll(adElement);
        }
        return adFeedItem;
    }

    /**
     */
    reset() {
        delete this._state.currAd;
        delete this._state.currPlacement;
    }

    /**
     * Checks whether an HTML element representing a feed item can have an ad before it
     * @param {HTMLElement} element - element to check
     * @returns {Boolean}
     */
    isEligibleForAd(feedItem) {
        // just in case the feed item is not in the DOM anymore
        // (e.g. was removed based on an A/B test variant after it was selected)
        return feedItem.parentNode !== null;
    }

    /**
     * Determines whether an ad should be inserted before the specified feed item
     * and returns ad unit's config if so, or null if not;
     * can also return a special `Done` instance when all available ad units or positions are already used
     * @param {Number} feedItemIdx - position of the feed item in the feed
     * @param {HTMLElement} feedItem - HTML element representing feed item
     * @returns {(Object|null|Done)}
     */
    getAdForPlacement(feedItemIdx) {
        const placement = this.getNextPlacement();
        if (isDone(placement)) {
            return new Done();
        } else if (feedItemIdx === placement) {
            return this.getNextAd();
        } else {
            this.getNextPlacement({
                pause: true
            });
            return null;
        }
    }

    /**
     * Modifies ad config before the ad is inserted
     * (for example, to provide additional custom targeting parameters)
     * @param {Object} ad - ad unit config
     * @param {Number} feedItemIdx - position of the feed item in the feed
     * @returns {Object}
     */
    prepareAd(ad, feedItemIdx) {
        ad = merge({}, ad); // to avoid mutations of config data in next calls
        // add 1 since the iteration is 0-based while BFA position should be 1-based
        ad.slot.position = feedItemIdx + 1;
        return ad;
    }

    /**
     * Returns a T3 module template corresponding to ad unit.
     * Must be overriden in derived classes
     * @param {Object} ad - ad unit config
     * @returns {Object} - nunjucks template
     * @throws {AdError} if the method is not overriden in derived class
     */
    getAdModuleTemplate() {
        throw new AdError('The method should be implemented in a derived class');
    }
}

AdManager.Done = Done;
AdManager.isDone = isDone;

/**
 * Returns function that generates a T3 behavior instance
 * @returns {Function} - callback to T3's `addBehavior` function
 */
AdManager.generateBehavior = function() {
    const Cls = this;
    return (context) => {
        return new Cls(context, {
            mode: 'behavior'
        });
    };
};

/**
 * Returns function that generates a T3 module instance
 * @returns {Function} - callback to T3's `addModule` function
 */
AdManager.generateModule = function() {
    const Cls = this;
    return (context) => {
        return new Cls(context, {
            mode: 'module'
        });
    };
};


export {
    AdManager,
    AD_MANAGER_EVENTS
};