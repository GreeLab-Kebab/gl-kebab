import cookies from '../cookies';

/**
 * Local code designed to interface with https://www.buzzfeed.com/destination-sync.html
 * (code found here: https://github.com/buzzfeed/mono/blob/master/site_root_files/locations/root/destination-sync.html)
 * Adapted from xdomain-cookies (http://contently.github.io/xdomain-cookies/)
 */

// Defined by destination-sync.html, the following must match exactly
const syncInitMessageType = 'destination-sync-init';
const writeCookieMessageType = 'destination-sync-write';
const readCookieMessageType = 'destination-sync-read';

const rejectOnTimeout = function(timeout) {
    return new Promise((_, reject) => {
        const error = {
            type: 'timeout',
            msg: `${timeout}ms timeout exceeded`,
        };
        setTimeout(() => reject(error), timeout);
    });
};

const getIframeOrigin = function(domain) {
    // The sourceOfTruthDomain drops all subdomains other than `stage`
    return domain.match(/^stage\./) ? `https://${domain}` : `https://www.${domain}`;
};

const getIframeURL = function(domain, data) {
    const syncFile = 'destination-sync.html';
    return `${getIframeOrigin(domain)}/${syncFile}#${encodeURIComponent(data)}`;
};

/**
 * XDomainCookies interfaces with /destination-sync.html to provide a way
 * to share cookies across BuzzFeed's domains. This is done by storing the
 * cookies on the destination-sync page, and communicating with that page
 * with messages. If the user is already part of the source of truth domain
 * then the iframe will not be used to get/save cookies.
 */
export default class XDomainCookies {

    /**
     * @param {Object} args
     * @param {String} args.sourceOfTruthDomain - The domain to be used
     *   as the source of truth for the cookies.
     * @param {String} args.localDomain - The domain we're reading the
     *   cookies from.
     * @param {String?} args.namespace - Used to namespace messages with the iframe.
     * @param {String?} args.env - The current context, should be 'prod' or otherwise.
     * @param {Int?} args.updateInterval - The interval in ms at which we should
     *   check in with the iframe to refresh the locally cached cookies.
     * @param {Int?} args.iframeTimeout - The time in ms we will wait before
     *   giving up on loading the source of truth iframe.
     */
    constructor({
        sourceOfTruthDomain,
        localDomain,
        namespace,
        env = 'dev',
        updateInterval = 1000 * 60 * 5, // 5 minutes
        iframeTimeout = 1000 * 3, // 3 seconds
    }) {
        this.sourceOfTruthDomain = sourceOfTruthDomain;
        this.localDomain = localDomain;
        this.env = env;
        this.namespace = namespace;
        this.iframeTimeout = iframeTimeout;
        this.cookies = {};

        if (sourceOfTruthDomain !== localDomain) {
            this.initIframe().then(() => {
                    setInterval(this.updateFromIframe.bind(this), updateInterval);
                })
                .catch(() => {}); // no updates for when iframe is not available
        }
    }

    /**
     * Generates a promise to get the value of the cookie requested.
     *
     * @param {String} name - The name, or key, of the cookie we're looking up.
     * @returns {Promise} - A promise which will resolve with the value
     *   for the cookie or null.
     */
    get(name) {
        // If we're in the same domain as the source of truth, use local cookies
        if (this.sourceOfTruthDomain === this.localDomain) {
            return Promise.resolve(cookies.get(name));
        }
        // Otherwise wait for iframe
        return this.initIframe().then(() => {
                let currentCookieVal = this.cookies[name] || cookies.get(name);
                return currentCookieVal;
            })
            .catch(() => cookies.get(name));
    }

    /**
     * Generates a promise to set the the cookie as described.
     *
     * @param {Object} args
     * @param {String} args.name - The name, or key, of the cookie
     * @param {String} args.value - The value to be set for the cookie
     * @param {Number} args.days - The expiration for the cookie in days.
     * @param {Boolean} arg.secureOnly - Whether the cookie should be marked secure
     */
    set({
        name,
        value,
        days,
        secureOnly = true
    }) {
        // If we're in the same domain as the source of truth, use local cookies
        if (this.sourceOfTruthDomain === this.localDomain) {
            cookies.set({
                name,
                value,
                days,
                localDomain: this.localDomain
            });
            return;
        }
        // Otherwise wait for iframe
        this.initIframe().then(() => {
                var data = {
                    namespace: this.namespace,
                    msgType: writeCookieMessageType,
                    cookieName: name,
                    cookieVal: value,
                    expiresDays: days,
                    secureOnly: secureOnly,
                };
                const targetOrigin = getIframeOrigin(this.sourceOfTruthDomain);
                this.iframe.contentWindow.postMessage(JSON.stringify(data), targetOrigin);
            })
            .catch(() => cookies.set({
                name,
                value,
                days,
                localDomain: this.localDomain
            }));
    }

    /**
     * This will ensure this instance of XDomainCookies can be cleaned up
     * by the garbage collector and remove it's iframe if it has one.
     * This is used for testing, but could also be useful if you ever have
     * need of removing your XDomainCookies, though typically its lifespan
     * will coincide with that of the page.
     */
    cleanup() {
        if (this.boundOnMessage) {
            window.removeEventListener('message', this.boundOnMessage);
        }
        if (this.iframe) {
            // This just makes sure we'll reject the iframeReady promise if we clean up,
            // without needing to wait for the timeout.
            const event = new ErrorEvent({
                message: 'XDomainCookies were cleaned up before ready'
            });
            this.iframe.dispatchEvent(event);
            this.iframe.remove();
        }
        this.iframeReady = null;
    }

    // Private methods

    initIframe() {
        if (this.iframeReady) {
            return this.iframeReady;
        }
        let loadIframe = new Promise((resolve, reject) => {
            // Wait until the first batch of cookies has been returned to mark the iframe as ready
            this.boundOnMessage = (event) => {
                this.onMessage(event, resolve);
            };
            window.addEventListener('message', this.boundOnMessage);
            this.createIframe(reject);
        });
        this.iframeReady = Promise.race([rejectOnTimeout(this.iframeTimeout), loadIframe])
            .catch(e => {
                if (this.env === 'prod' && window.raven) {
                    window.raven.captureException(
                        e.type === 'timeout' ? new Error(`Destination Sync: ${e.msg}`) : e
                    );
                }
                console.error(e);
                throw e;
            });
        return this.iframeReady;
    }

    createIframe(onerror) {
        // If we already have an iframe using this namespace, we'll re-use it here.
        // We can assume the windowOrigin will have to be the same if we can find
        // it in the same document.
        const iframeID = `xdomaincookies-${this.namespace}`;
        const preExistingIframe = document.getElementById(iframeID);
        if (preExistingIframe) {
            preExistingIframe.addEventListener('error', (event) => {
                onerror(event);
            });
            this.iframe = preExistingIframe;
            // force existing iframe to populate cookies for this instance
            if (this.iframe.contentWindow) {
                this.updateFromIframe();
            }
            return;
        }

        // Otherwise create a new iframe
        const data = JSON.stringify({
            namespace: this.namespace,
            windowOrigin: window.location.origin,
        });
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.addEventListener('error', (event) => {
            onerror(event);
        });
        iframe.id = iframeID;
        iframe.src = getIframeURL(this.sourceOfTruthDomain, data);
        this.iframe = iframe;
        document.body.appendChild(iframe);
    }

    updateFromIframe() {
        const data = {
            namespace: this.namespace,
            msgType: readCookieMessageType,
        };
        const targetOrigin = getIframeOrigin(this.sourceOfTruthDomain);
        this.iframe.contentWindow.postMessage(JSON.stringify(data), targetOrigin);
    }

    onMessage(event, resolve) {
        let data = {};
        try {
            data = JSON.parse(event.data);
        } catch (e) {}

        if (data.namespace !== this.namespace) {
            return;
        }

        if (data.msgType === syncInitMessageType || data.msgType === readCookieMessageType) {
            this.cookies = data.cookies;
        }
        resolve();
    }
}