import XDomainCookies from '../XDomainCookies';
import {
    getLocalCookieDomain,
    getSourceOfTruthCookieDomain
} from '../XDomainCookies/default-domains';

/**
 * A simple interface to make it easier to setting up a
 * particular cookie with the assumption that most of the
 * parameters will stay the same, allowing you to instantiate
 * it once and then continue to re-use.
 */
export default class XDomainCookieManager {
    /**
     * @param {Object} args
     * @param {String} args.cookieName - The name, or key, of the cookie
     * @param {Number} args.daysExpiry - How long, in days, the cookie
     *   should live before expiring.
     * @param {String} args.env - The current context, should be 'prod' or otherwise.
     * @param {String} args.namespace - The XDomainCookies namespace.
     * @param {Number} args.throttleTimer - If a number is specified here, we'll
     *   throttle how often we check the XDomainCookies for a value. This will
     *   prevent reading from cookies more often than we need. The default
     *   null value provides no throttling.
     * @param {Boolean} args.secureOnly - Whether the cookie will be set
     *   as secure only when being written. Defaults to true.
     * @param {String} args.localDomain - The domain we're reading the
     *   cookies from. This will default to a best guess attempt based on
     *   known BuzzFeed domains, while trying not to limit to a particular
     *   subdomain other than stage.
     * @param {String} args.sourceOfTruthDomain - The domain to be used
     *   as the source of truth for the cookies. Will default to buzzfeed.com
     *   or stage.buzzfeed.com for non-prod.
     */
    constructor({
        cookieName,
        daysExpiry,
        env,
        namespace,
        sourceOfTruthDomain,
        throttleTimer = null,
        secureOnly = true,
        localDomain = getLocalCookieDomain(),
    }) {
        // normalise environment variable
        env = env === 'live' ? 'prod' : env;
        this.xDomainCookies = new XDomainCookies({
            sourceOfTruthDomain: sourceOfTruthDomain || getSourceOfTruthCookieDomain(env),
            namespace,
            localDomain,
            env,
        });
        this.cookieName = cookieName;
        this.daysExpiry = daysExpiry;
        this.secureOnly = secureOnly;
        this.throttleTimer = throttleTimer;
        this.inMemoryValue = null;
    }

    get() {
        if (this.throttle) {
            return Promise.resolve(this.inMemoryValue);
        }
        return this.xDomainCookies.get(this.cookieName).then((cookieValue) => {
            this.inMemoryValue = cookieValue;
            this.resetThrottle();
            return cookieValue;
        });
    }

    set(value) {
        this.inMemoryValue = value;
        return this.xDomainCookies.set({
            name: this.cookieName,
            value,
            days: this.daysExpiry,
            secureOnly: this.secureOnly,
        });
    }

    // Private

    resetThrottle() {
        if (this.throttleTimer) {
            this.throttle = setTimeout(() => {
                this.throttle = null;
            }, this.throttleTimer);
        }
    }
}