import client from '../../services/client';
import {
    getUniqueEventName
} from '../../services/util/standalone';
import solid from '../../services/solid/standalone';
import viewportMonitor from '../../services/viewport-monitor';

function _getDefaults() {
    return {
        // default is twice the viewport height
        renderLookahead: client.getViewportHeight() * 2,
        throttleTimeout: 300
    };
}

/**
 * Whether the image is of type GIF
 * @memberOf behavior:viewable
 * @param {HTMLElement} element - The dom element that has the viewable behavior
 * @return {Bool}
 */
function _isGif(element) {
    return element.classList.contains('js-subbuzz-image--gif');
}

/**
 * Calculate the correct amount to lookahead
 * @memberOf behavior:viewable
 * @param {object} config - The element config
 * @param {HTMLElement} element - The dom element that has the viewable behavior
 * @return {Number} the amout to lookahead
 */
function _getRenderLookahead(config, element) {
    // If the html config.renderLookahead includes a number prefixed by x, multiply viewport value
    if (config && config.renderLookahead && config.renderLookahead.toString().match(/^x/)) {
        var multiply = parseFloat(config.renderLookahead.slice(1));
        return client.getViewportHeight() * multiply;
    } else if (config && config.renderLookahead) {
        return config.renderLookahead;
    }

    // This is a very unscientific way of relating bandwidth to screen size
    // It's a temporary fix, whilst we rethink how we post load content
    // TODO: Implement a better solution that takes into account performance metrics (Ian)
    if (_isGif(element)) {
        return solid.isAny(['xs', 'sm']) ? 500 : 1400;
    }

    return _getDefaults().renderLookahead;
}

/**
 * Behavior for view position monitoring.
 */
export default class Viewable {
    constructor(ctx) {
        this.element = ctx.getElement();
        this.config = ctx.getConfig() || {};
        this.broadcast = ctx.broadcast.bind(ctx);

        this._notifySelf = this._notifySelf.bind(this);
        this._notifySelfExit = this._notifySelfExit.bind(this);
    }

    /**
     * Executed when module's _element is in view.
     * @memberOf behavior:viewable
     * @fires viewport-active
     * @return {void}
     */
    _notifySelf() {
        this.broadcast(getUniqueEventName('viewport-active', this.element));
    }

    /**
     * Executed when module's _element leaves the view.
     * @memberOf behavior:viewable
     * @fires viewport-inactive
     * @return {void}
     */
    _notifySelfExit() {
        this.broadcast(getUniqueEventName('viewport-inactive', this.element));
    }

    /**
     * Creates a new viewportMonitor
     * @memberof Viewable
     * @return {void}
     */
    createMonitor() {
        this.monitor = viewportMonitor.create({
            throttleTimeout: typeof this.config.throttleTimeout !== 'undefined' ?
                this.config.throttleTimeout : _getDefaults().throttleTimeout,
        });
    }

    /**
     * Begin monitoring
     * @memberof Viewable
     * @return {void}
     */
    watch() {
        if (this.watching) {
            return;
        }
        /**
         * Deferring start of viewport detection.
         * Prevents a case where modules are already located in the viewport, but have not been initalized yet.
         * As T3 Application init process is always synchronous, this will fire viewport-active events when the initialization is finished.
         */
        this.watching = window.setTimeout(() => {
            this.monitor.add({
                target: this.element,
                renderLookahead: _getRenderLookahead(this.config, this.element),
                callback: this._notifySelf,
                exitCallback: this.config.animated ? this._notifySelfExit : null,
                watchOnce: this.config.animated ?
                    false : typeof this.config.watchOnce !== 'undefined' ? this.config.watchOnce : true,
            });
        }, 0);
    }

    /**
     * Initialize behavior
     * @param {any} [{ mocks = {} }={}]
     * @memberof Viewable
     */
    init() {
        this.createMonitor();
        this.watch();
    }

    destroy() {
        if (this.watching) {
            window.clearTimeout(this.watching);
        }
        this.monitor.remove(this.element);
        this.element = null;
        this.config = null;
    }
}