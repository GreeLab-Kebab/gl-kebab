import {
    throttle
} from 'lodash';

let identifier = 0;
let listeners = {};

/**
 * Listens to scroll event with given throttling.
 * @param {Object} options - customization parameters.
 * @param {Number} options.throttleTimeout - milliseconds to wait after scroll event
 * @param {Element} options.parent - element to listen to scroll event from (defaults to window)
 * before firing a callback.
 * @constructor
 */
class ScrollListener {
    constructor({
        throttleTimeout,
        parent,
        initialTrigger
    }) {
        this.callbacks = {};

        this.add = this.add.bind(this);
        this.remove = this.remove.bind(this);

        this.triggerEvents = ['scroll', 'resize'];
        if (initialTrigger) {
            this.triggerEvents.push('load');
        }
        this.target = parent ? parent : window;
        this._triggerThrottled = throttle(() => this.trigger(), throttleTimeout);
        this.triggerEvents.forEach((ev) => this.target.addEventListener(ev, this._triggerThrottled));
    }
    /**
     * Adds scroll event handler.
     * @param {Function} cb - function to fire on scroll event.
     * @return {Number} - handler identifier.
     */
    add(cb) {
        this.callbacks[++identifier] = cb;
        return identifier;
    }
    /**
     * Removes scroll event handler.
     * @param {Number} id - handler identifier.
     * @return {void}
     */
    remove(id) {
        delete this.callbacks[id];
    }
    /**
     * Triggers scroll event handler.
     * @param {Number} id - handler identifier.
     * @return {void}
     */
    trigger(id) {
        if (this.callbacks.hasOwnProperty(id)) {
            this.callbacks[id]();
        } else {
            for (var key in this.callbacks) {
                if (this.callbacks.hasOwnProperty(key)) {
                    this.callbacks[key]();
                }
            }
        }
    }

    destroy() {
        this.triggerEvents.forEach((ev) => this.target.removeEventListener(ev, this._triggerThrottled));
        delete this.target;
        delete this.callbacks;
        delete this._triggerThrottled;
        delete this.add;
        delete this.remove;
    }
}

export default {
    /**
     * Subscribes to scroll event.
     * @param {Object} options - parameters for scroll subscription.
     * @param {Number} options.throttleTimeout=350 - milliseconds to wait after scroll event
     * before firing a callback.
     * @param {Function} options.callback - function to call on scroll event.
     * @param {Boolean} options.initialTrigger - Flag to tigger callback initialy
     * @return {Number} - handler identifier.
     */
    add({
        throttleTimeout = 350,
        parent,
        callback,
        initialTrigger = true
    }) {
        let listener = listeners[throttleTimeout];
        if (!listener) {
            listener = new ScrollListener({
                throttleTimeout,
                parent,
                initialTrigger
            });
            listeners[throttleTimeout] = listener;
        }

        const id = listener.add(callback);
        if (initialTrigger) {
            listener.trigger(id);
        }
        return id;
    },
    /**
     * Removes scroll event handler.
     * @param {Number} id - handler identifier.
     * @return {void}
     */
    remove(id) {
        for (var key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                listeners[key].remove(id);
            }
        }
    }
};