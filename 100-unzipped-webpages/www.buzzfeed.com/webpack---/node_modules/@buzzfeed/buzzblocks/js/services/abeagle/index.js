import {
    getUserId
} from '@buzzfeed/bf-utils/lib/userid';
import {
    queryStringToObject
} from '@buzzfeed/bf-utils/lib/query-string';
import {
    ABEAGLE_REQUEST_ROUTE,
    ABEAGLE_ROUTE_PREFIX
} from './tracking';
import ajax from '../ajax';
import cookies from '../cookies';
import speedtrack from '../performance';
import {
    isNil
} from 'lodash';

// Array of experiments set by clients via registerExperiments function
let experiments = [];

// Object of form {experimentName: [{request, reject}, {request, reject}], ..}
// Updated when clients request the bucketing for a particular experiment with
// `getExperimentVariant`
let variantPromises = {};

// Object of form {experimentName: bucketedVariantName, ..}
// Used to store the result from abeagle_public
let variants = {};

// Promise for ajax request to abeagle_public
let requestPromise;

// Object to hold errors return by the call to abeagle_public
let experimentErrors = {};

const abFlags = (() => {
    const queryParams = queryStringToObject(window.location.search);
    return queryParams.abflags || queryParams.abdebug;
})();

const cookieDomain = cookies.getBuzzfeedSubdomainOrWildcard(window.location.hostname);

// value to store for unbucketed users
const DEFAULT_VARIANT = null;

/**
 * Sets value in *variants* and resolves all promises for the experiment in
 * variantPromises.
 * @param {String} experiment - experiment name.
 * @param {String} variant - varation name.
 * @return {void}
 */
function resolveVariant(experiment, variant) {
    variants[experiment] = variant;
    if (variantPromises[experiment]) {
        variantPromises[experiment].forEach(promise => promise.resolve(variant));
    }
}

/**
 * Fires control variation for every eligible abtest.
 * @return {void}
 */
function resolveAllToDefault() {
    experiments.forEach(function(experiment) {
        if (experiment.isEligible()) {
            resolveVariant(experiment.name, DEFAULT_VARIANT);
        }
    });
}

/**
 * Set tracked experiment cookie.
 * @param {String} name - name of cookie
 * @param {String} value - value of cookie
 * @return {void}
 */
function setCookie(name, value) {
    const domain = window.location.hostname.replace('www', '');
    // Remove the wildcarded cookie, if it exists.
    // TODO: this is only needed as a temporary measure
    // until the wildcarded abeagle cookies have naturally expired
    cookies.remove(name, `.${domain}`);

    // Production cookies last 14 days. Stage and dev cookies last 1 day
    const days = cookieDomain === `www.${domain}` ? 14 : 1;

    // Set the new cookie
    cookies.set({
        name,
        value,
        days,
        domain: cookieDomain
    });
}


/**
 * Send experiment variation to BFA.
 * @param {String} endpoint - endpoint to send variation
 * @param {Object} data - variation data
 * @return {void}
 */
function track(endpoint, data) {
    window.bfa(endpoint, {
        data
    });
}


/**
 * Proceses variant events.
 * @param {Object} experimentsMap - map of experiment names.
 * @return {void}
 */
function processVariantEvents(experimentsMap) {
    Object.keys(experimentsMap).forEach(experimentName => {
        const versionCookieName = `${experimentName}_version`;
        const experiment = experimentsMap[experimentName];
        let {
            value,
            version,
            error,
            resolved
        } = experiment;

        if (error) {
            let errObj = {
                type: 'ExperimentServerError',
                name: experimentName,
                error: error
            };
            experimentErrors[experimentName] = errObj;
            if (variantPromises[experimentName]) {
                variantPromises[experimentName].forEach(promise => promise.resolve(DEFAULT_VARIANT));
            }
            return;
        }

        // When experiment is resolved with NULL - save 'control' to user cookies.
        if (resolved) {
            value = value || 'control';
        }

        resolveVariant(experimentName, value);

        // At this point NULL value means that a user is not bucketed into any
        // variant.  Nothing should be tracked or saved in that case.  Additionally
        // remove any cookies which may be set for this experiment.
        if (value === null) {
            cookies.remove(experimentName, cookieDomain);
            cookies.remove(versionCookieName, cookieDomain);
            return;
        }

        // Track only if experiment version or value in the response are different
        // from what's stored in cookies
        const isVariantSame = (cookies.get(experimentName) === String(value));
        const isVersionSame = (cookies.get(versionCookieName) === String(version));
        if (isVariantSame && isVersionSame) {
            return;
        }

        setCookie(experimentName, value);
        setCookie(versionCookieName, version);
        track(`${ABEAGLE_ROUTE_PREFIX}/${experimentName}`, {
            experiment: experimentName,
            variation: experiment
        });
    });
}


/**
 * Stores complete abeagle response in _metadata cookie.
 * @param {Array} experimentNames - array with experiments.
 * @param {Object} experimentsMap - map of experiment names.
 * @return {void}
 */
function storeAbeagleResponses(experimentNames, experimentsMap) {
    var experimentsToStore = [];

    experiments.forEach(function(experiment) {
        if (typeof experiment.storeResponse === 'boolean') {
            if (experiment.storeResponse) {
                experimentsToStore.push(experiment.name);
            }
        }
    });

    if (experimentsToStore.length === 0) {
        return;
    }

    experimentNames.forEach(function(experimentName) {
        if (experimentsToStore.indexOf(experimentName) !== -1) {
            var variant = experimentsMap[experimentName];

            if (!variant || variant.error || variant.value === null) {
                resolveVariant(experimentName, DEFAULT_VARIANT);
            } else {
                var cookieName = experimentName + '_metadata';
                var cookieValue = variant;

                cookieValue = JSON.stringify(cookieValue);
                cookieValue = escape(cookieValue);
                if (cookies.get(cookieName) !== cookieValue) {
                    setCookie(cookieName, cookieValue);
                }
            }
        }
    });

}

/**
 * Overrides experiment variations from ABeagle API with user-supplied values.
 * Debugging purposes only.
 * @return {void}
 */
function overrideVariations() {
    experiments.forEach(function(experiment) {
        if (!experiment.isEligible()) {
            return;
        }
        var value = cookies.get(experiment.name);
        resolveVariant(experiment.name, value);
    });
}

function logError(e) {
    if (e instanceof Error) {
        throw e;
    }

    if (window.BZFD.Config.env === 'prod') {
        return;
    }

    switch (e.type) {
        case 'ExperimentNotFound':
            console.log(`Experiment "${e.name}" is not registered`);
            break;
        case 'ExperimentNotEligible':
            console.log(`Experiment "${e.name}" is not eligible`);
            break;
        case 'ExperimentServerError':
            console.log(`Experiment ${e.name} error: ${e.error}`);
            break;
    }
}

// match query parameters like `abeagle_$experiment=$value`, e.g.
// `abeagle_ADSGROUP-380_outbrain_zergnet=outbrain`
function getVariantFromQueryParameters(experimentName) {
    return queryStringToObject(window.location.search)[`abeagle_${experimentName}`];
}

export default {
    registerExperiments(exps = []) {
        experiments = exps;
        requestPromise = null;
    },

    /**
     * Return json data of meta data for all tests names passed
     * @param {Array} experimentNames - list of test names
     * @return {Object}
     */
    getExperimentMetaData(experimentNames) {
        var metaData = {};

        experimentNames.forEach(function(testName) {
            var cookieValue = cookies.get(testName + '_metadata');

            try {
                cookieValue = unescape(cookieValue);
                cookieValue = JSON.parse(cookieValue);
                metaData[testName] = cookieValue;
            } catch (e) {
                return;
            }
        });

        return metaData;
    },

    /**
     * Called by clients. Returns promise of variant value.
     * If the call to abeagle_public hasn't returned, then
     * update variantPromises obj with [{resolve, reject}] array
     *
     * The *options* object contains two options:
     *
     * If *rejectErrors* is true, then return a rejected promise if
     * - Experiment/featureflag doesn't exist
     * - User is ineligible for experiment/featureflag
     * - abeagle returned an error for expeirment/featureflag
     *
     * *defaultVariantIfUnbucketed* allows clients to specify a value other than null
     * to use for unbucketed users. (This is typically "control", the default value)
     *
     * @param {string} experimentName
     * @param {string} options {rejectErrors (bool), defaultVariantIfUnbucketed (string or null)}
     * @returns {Promise}
     **/
    getExperimentVariant(experimentName, {
        rejectErrors = true,
        defaultVariantIfUnbucketed = 'control',
        errorVariant = DEFAULT_VARIANT
    } = {}) {
        const queryParamVariant = getVariantFromQueryParameters(experimentName);
        // if experiment name/variant in query params, use that value
        if (queryParamVariant) {
            return Promise.resolve(queryParamVariant);
        }

        let matchedExperiment = experiments.filter(experiment => experiment.name === experimentName)[0];

        // if abeagle_public returned an error prior to `getExperimentVariant` call,
        // an error will be stored in *experimentErrors*
        let err = experimentErrors[experimentName];
        let result;

        if (!matchedExperiment) {
            err = {
                type: 'ExperimentNotFound',
                name: experimentName
            };
        } else if (!matchedExperiment.isEligible()) {
            err = {
                type: 'ExperimentNotEligible',
                name: experimentName
            };
        }

        if (err) {

            if (rejectErrors === false) {
                this.defaultErrorHandler(err);
                result = Promise.resolve(errorVariant);
            } else {
                result = Promise.reject(err);
            }

        } else if (experimentName in variants) {
            // if abeagle_public returned a variant prior to
            // `getExperimentVariant` call, it will be stored in *variants*
            result = Promise.resolve(variants[experimentName]);

        } else {
            result = new Promise((resolve, reject) => {
                if (!variantPromises[experimentName]) {
                    variantPromises[experimentName] = [{
                        resolve,
                        reject
                    }];
                } else {
                    variantPromises[experimentName].push({
                        resolve,
                        reject
                    });
                }
            });
        }

        // If defaultVariantIfUnbucketed is something other than DEFAULT_VARIANT (null),
        // then replace the null values with defaultVariantIfUnbucketed before returning
        // to the client
        if (defaultVariantIfUnbucketed !== DEFAULT_VARIANT) {
            result = result.then((val) => val === DEFAULT_VARIANT ? defaultVariantIfUnbucketed : val);
        }

        return result;
    },

    /**
     * Called by clients.
     * Returns a promise resolved to true if:
     * - *ffName* has a variant named *onValue*
     *   ABeagle feature flags have a single variant named "on"
     *   But some teams use experiments to act like feature flags,
     *   and the variant used to signify on is often a different value
     * - the user was bucketed into the *onValue* variant
     *
     * Returns a promise resolved to false if:
     * - *ffName* doesn't have a variant named *onValue*
     * - user not bucketed into variant named *onValue*
     * - user not eligible
     * - *ffname* does not exist in abeagle
     * - abeagle returned an error for *ffName*
     *
     * @param {string} ffName, name of experiment/featureflag
     * @param {string} onValue, name of the variant signifying "on"
     * @returns Promise
     **/
    isOn(ffName, onValue = 'on') {
        if (isNil(onValue)) {
            return Promise.reject('onValue cannot be null or undefined');
        }

        return this.getExperimentVariant(ffName, {
                rejectErrors: false
            })
            .then(val => (val === onValue));
    },

    defaultErrorHandler: logError,

    /**
     * Hits abeagle_public endpoint which returns experiment variants for the current user.
     * - filters *experiments* array to return only those experiments where the
     *   current user is eligible
     * - sends client id of the users to abeagle_public
     *
     * If abeagle_public request is successful, process results and store cookies
     * If  abeagle_public request fails: falls back to control variants.
     *
     */
    getVariants() {
        const performanceMetric = 'abeagle.getVariants';
        speedtrack.eventStart(performanceMetric);
        if (abFlags) {
            overrideVariations();
            return Promise.resolve();
        }

        // ABeagle API request should only be sent once
        if (requestPromise) {
            return Promise.resolve();
        }

        const experimentNames = experiments
            .filter(experiment => experiment.isEligible())
            .map(experiment => experiment.name);

        if (!experimentNames.length) {
            return Promise.resolve();
        }

        const startRequestTime = new Date().getTime();
        return getUserId({
            env: BZFD.Config.env
        }).then(userId => {
            requestPromise = ajax.get(`${window.BZFD.Config.abeagle.url}/public/v2/experiment_variants`, {
                    data: {
                        'experiment_names': experimentNames.join(';'),
                        'user_id': userId,
                        'client_id': 'buzz_web'
                    },
                    timeout: 1500
                })
                .then(experimentsMap => {
                    speedtrack.mark(`${performanceMetric}_fetched`);
                    track(ABEAGLE_REQUEST_ROUTE, {
                        responseTime: Date.now() - startRequestTime
                    });
                    processVariantEvents(experimentsMap);
                    storeAbeagleResponses(experimentNames, experimentsMap);
                    speedtrack.eventEnd(performanceMetric);
                })
                .catch(resolveAllToDefault);

            return requestPromise;
        });
    },

    saveExperiments(data) {
        if (typeof data['experimentsMap'] !== 'undefined' && typeof data['experimentNames'] !== 'undefined') {
            processVariantEvents(data.experimentsMap);
            storeAbeagleResponses(data.experimentNames, data.experimentsMap);
        }
    },

    /**
     * Entry point.
     * Processes experiment variants stored in user's cookie,
     * and calls `getVariants`
     * @return {void}
     */
    start() {
        this.getVariants();

        if (abFlags) {
            import ('../ab-flipper')
            .then(function(flipper) {
                flipper.start(experiments);
            });
            return;
        }

        experiments.forEach(experiment => {
            if (!experiment.isEligible()) {
                resolveVariant(experiment.name, DEFAULT_VARIANT);

                return;
            }
            var storedValue = cookies.get(experiment.name);
            if (storedValue) {
                resolveVariant(experiment.name, storedValue);
            }
        });
    },

    /**
     * For tests only
     */
    reset() {
        experiments = [];
        variantPromises = {};
        experimentErrors = {};
        variants = {};
        requestPromise = null;
    }
};