import timing from 'timing.js';
import {
    performanceMapPath,
    customMarkMapPath
} from './mapping';
import {
    isEmpty
} from 'lodash';

// handles the marks added by the `mark()` method
let marks = {};

function sendData(mapPath, data) {
    if (typeof window.bfa !== 'function') {
        if (typeof window.raven !== 'undefined') {
            window.raven.captureException(new Error('Performance tracking issue: BFA is not available'));
        }
        return;
    }

    if (isEmpty(data)) {
        return;
    }

    window.bfa(mapPath, {
        data: data
    });

}

function trackPagePerformance() {
    function onLoad() {
        setTimeout(function() {
            sendData(performanceMapPath, timing.getTimes());
        }, 0);
    }
    if (document.readyState === 'complete') {
        onLoad();
    } else {
        window.addEventListener('load', onLoad);
    }
}

function getTiming(markName, originMarkName) {
    let time = timing.getTimes()[originMarkName];
    let value;

    if (!originMarkName || (marks[originMarkName])) {
        value = window.performance.now() - (marks[originMarkName] || 0);
    } else if (time) {
        value = window.Date.now() - time;
    } else {
        value = null;
    }

    return value;
}

/**
 * SpeedTrack API
 * O&O Web Performance Data Gathering
 * @see https://github.com/buzzfeed/mono/blob/master/qr_speedtrack for available metrics and tags.
 */
export default {

    // Marks Method ---------------------------
    /**
     * Creates:
     * 1. an entry in marks object with current timestamp;
     * 2. a performance.mark(markName) for third parties;
     * Allows a second argument if you want to change the time origin (default: `navigationStart`)
     * @see https://www.w3.org/TR/user-timing/ for recommended mark names
     * @param {String} markName - describes what is being timed.
     * @param {String} originMarkName - (optional) changes time origin.
     * @returns {void}
     * @example speedtrack.mark('mark_foo');
     * @example speedtrack.mark('mark_foo', 'mark_fonts_fully_loaded');
     */
    mark(markName, originMarkName) {
        if (window.performance === undefined) {
            return;
        }

        let markValue = getTiming(markName, originMarkName);
        if (markValue || markValue === 0) {
            marks[markName] = markValue;
            sendData(customMarkMapPath, {
                markName,
                markValue
            });
        } else {
            console.error(`${originMarkName} is not a known event.`);
            return;
        }

        if (window.performance.mark !== undefined) {
            window.performance.mark(markName);
        }
    },


    // Events Methods ---------------------------

    /**
     * Creates:
     * 1. an entry in events object with current timestamp;
     * 2. a performance.mark(eventName) for third parties;
     * @see https://www.w3.org/TR/user-timing/ for recommended mark names
     * @param {String} eventName - describes what is being timed.
     * @returns {void}
     * @example speedtrack.eventStart('foo');
     */
    eventStart(eventName) {
        if (window.performance === undefined) {
            return;
        }

        marks[eventName + '_start'] = window.performance.now();

        if (window.performance.mark !== undefined) {
            window.performance.mark(eventName + '_start');
        }
    },

    /**
     * Creates:
     * 1. an entry in events object with current timestamp;
     * 2. saves the duration of the event in `marks`
     * 3. a performance.mark(eventName) for third parties;
     * @see https://www.w3.org/TR/user-timing/ for recommended mark names
     * @param {String} eventName - describes what is being timed.
     * @returns {void}
     * @example speedtrack.eventEnd('foo');
     */
    eventEnd(eventName) {
        if (window.performance === undefined) {
            return;
        }

        if (marks[eventName + '_start']) {
            marks[eventName + '_end'] = window.performance.now();

            marks[eventName] = marks[eventName + '_end'] - marks[eventName + '_start'];

            sendData(customMarkMapPath, {
                markName: eventName,
                markValue: marks[eventName]
            });
        }

        if (window.performance.mark !== undefined) {
            window.performance.mark(eventName + '_end');
        }
    },

    /**
     * Sends already-measured timings to Datadog.
     * @param {String} eventName - name of the event
     * @param {Int|Float} eventValue - value of the event in ms.
     * @returns {void}
     * @example speedtrack.histrogram('mark_instragam_loaded', 3398);
     */
    histogram(eventName, eventValue) {
        marks[eventName] = eventValue;
        sendData(customMarkMapPath, {
            markName: eventName,
            markValue: marks[eventName]
        });
    },

    start() {
        trackPagePerformance();
    },

};