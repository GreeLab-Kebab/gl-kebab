/**
 * Parameters for viewport detection.
 * @typedef {Object} WatchParams
 * @property {HTMLElement} target - watched element.
 * @property {Number} renderLookahead - the number of pixels to look ahead
 * when detecting viewport position.
 * @property {Function} callback - a function to fire when viewport condition satisfied.
 * @property {Boolean} watchOnce - if the element should be removed from watching
 * after first callback fire.
 */

import {
    getViewPosition
} from '../dom';
import scrollListener from '../scroll-listener';


// namespace for easier testing
const dom = {
    getViewPosition
};


let monitors = {};
let identifier = 0;

class ViewportMonitor {
    constructor({
        throttleTimeout
    }) {
        this.watching = {};

        this.fireCallback = this.fireCallback.bind(this);
        this.trigger = this.trigger.bind(this);
        this.add = this.add.bind(this);
        this.remove = this.remove.bind(this);

        scrollListener.add({
            throttleTimeout,
            callback: this.trigger,
        });
    }
    /**
     * Checks viewport position of the registered element and fires callback if condition satisfied.
     * @param {WatchParams} item - current subscriber.
     * @param {Number} [offset] - offset for viewport position.
     * @return {void}
     */
    fireCallback(item, offset) {
        var pos = dom.getViewPosition(item.target, item.renderLookahead, offset);

        if (pos.isHidden()) {
            return;
        }
        if (pos.isPartiallyInViewport() || pos.isPartiallyInLookahead() || pos.isWithinLookahead()) {
            item.callback();
            item.inViewport = true;
            if (item.watchOnce) {
                this.remove(item.target);
            }
        } else if (item.exitCallback && item.inViewport) {
            item.inViewport = false;
            item.exitCallback();
        }
    }
    /**
     * Scroll event handler. Fires registered callbacks.
     * @param {Number} [offset] - offset for viewport position.
     * @return {void}
     */
    trigger(offset) {
        for (let id in this.watching) {
            if (this.watching.hasOwnProperty(id)) {
                this.fireCallback(this.watching[id], offset);
            }
        }
    }
    /**
     * Watch for an element's position in the viewport
     * @param {WatchParams} params - watching params.
     * @returns {void}
     */
    add(params) {
        this.watching[identifier++] = params;
        this.fireCallback(params);
    }
    /**
     * Stops watching for an element's position in the viewport
     * @param {HTMLElement} elem - watched element.
     * @returns {void}
     */
    remove(elem) {
        if (elem instanceof HTMLElement) {
            for (let id in this.watching) {
                if (this.watching.hasOwnProperty(id) && this.watching[id].target === elem) {
                    delete this.watching[id];
                    break;
                }
            }
        }
    }
}

export default {
    /**
     * Creates viewport monitor instance
     * @param {Object} params - instance parameters.
     * @param {Number} params.throttleTimeout - number of milliseconds before executing callbacks.
     * @return {ViewportMonitor} - monitor instance.
     */
    create({
        throttleTimeout
    }) {
        let monitor = monitors[throttleTimeout];
        if (!monitor) {
            monitor = monitors[throttleTimeout] = new ViewportMonitor({
                throttleTimeout
            });
        }

        return monitor;
    },
    /**
     * Triggers all callbacks of all created monitors.
     * @param {Number} [offset] - offset for viewport position.
     * @return {void}
     */
    triggerAll(offset) {
        for (let key in monitors) {
            if (monitors.hasOwnProperty(key)) {
                monitors[key].trigger(offset);
            }
        }
    }
};