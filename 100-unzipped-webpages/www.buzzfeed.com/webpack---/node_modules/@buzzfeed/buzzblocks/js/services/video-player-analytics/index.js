import {
    debounce
} from 'lodash';

import {
    bfaTrack,
    getScreenOrientation
} from '../util/standalone';
import scrollListener from '../../../js/services/scroll-listener';

const VIEW_SEGMENT_PAUSE_TIMEOUT = 1000;
const SCRUB_DEBOUNCE_RATE = 1000;
const SECS_TO_MS = 1000;
const DUMMY_HLS_INSTANCE = {
    currentLevel: -1,
    streamController: {
        stats: {
            bwEstimate: 'unknown'
        }
    }
};
const getWindow = () => window;

class Analytics {

    /**
     * Create a new Video Analytics instance
     * @param {Element} video - the video element to instrument
     * @param {Object} [config={}] - optional configuration
     */
    constructor(video, config = {}) {
        this.video = video;
        this.config = config;
        this.sessionVars = {};
        this.defaultToBFA();
        this.initVideoAttributes(video);
        this.initSessionVars();
        this.addListeners();
        this.hls = this.config.hls || DUMMY_HLS_INSTANCE;
        this.bufferStartTime = 0;
        this.bufferTotalTime = 0;
        this.bufferCounter = 0;

        this.scrollListenerId = scrollListener.add({
            callback: this.verifyImpression.bind(this)
        });
    }

    /**
     * Set class variables for tracking video state
     */
    initVideoAttributes() {
        this.videoIsMuted = this.video.muted;
        this.videoCurrentTime = this.video.currentTime;
    }

    /**
     * Set tracking attributes that last for whole session
     */
    initSessionVars() {
        this.sessionVars = Object.assign(
            this.sessionVars, {
                'source': 'buzz_web',
                'page_url': this.location,
                'player': 'vps',
                'target': 'video_player',
                'platform': this.platform,
                'player_location': this.playerLocation,
                'video_type': this.currentSrcType,
                'video_title': this.config.videoTitle || 'unknown',
                'position': this.position,
                'dimensions': this.dimensions,
                'play_start_type': this.video.dataset.autoplay === '' ? 'autoplay' : 'click_to_play',
                'length': this.config.videoDuration || 'unknown',
                'author': 'Buzzfeed Video',
                'releasedAt': this.config.releasedAt
            },
            this.resourcePair
        );

        // if all metadata was not ready, set sessionVars again once it is
        this.video.addEventListener('loadedmetadata', this.initSessionVars.bind(this));
    }

    /**
     * Set default tracking callbacks to BFA
     * bfaTrack is a safe noop if BFA does not exist
     */
    defaultToBFA() {
        if (!this.config.track) {
            this.config.track = data => bfaTrack(`track/videoplayer/${data.type}`, {
                data
            });
            this.config.flush = () => bfaTrack(`track/videoplayer/flush`, {});
        }
    }

    /**
     * Adds custom tracking attributes
     * @param {Object} attributes - Attribute key/value pairs
     */
    addCustomAttributes(attributes) {
        this.sessionVars = Object.assign({},
            this.sessionVars,
            attributes
        );
    }

    /**
     * Returns a key/value pair representing the current video:
     * @returns {Object}
     * e.g.
     * video_id: x
     * transcoder_path: y
     */
    get resourcePair() {
        const key = this.config.videoId ? 'video_id' : 'transcoder_path';
        const val = this.config.videoId ? this.config.videoId : this.config.transcoderPath;
        return {
            [key]: val || 'unknown'
        };
    }
    /**
     * Returns the current player location:
     * @returns {String}
     */
    get playerLocation() {
        return this.config.playerLocation;
    }
    /**
     * Returns the current platform:
     * @returns {String}
     */
    get platform() {
        return this.config.platform || 'buzzblocks';
    }
    /**
     * Returns the current window location:
     * @returns {String}
     */
    get location() {
        return this.config.origin || (window.location.origin + window.location.pathname);
    }
    /**
     * Returns the position of this video-player instance
     * as a 1-based index of all video-player instances on the page
     * @returns {Number}
     */
    get position() {
        const videos = Array.prototype.slice.call(document.querySelectorAll('.video-player'));
        return videos.indexOf(this.video) + 1;
    }
    /**
     * Returns the bandwidth of user
     * @returns {Number}
     */
    get bandwidth() {
        if (this.hls && this.hls.streamController && this.hls.streamController.stats) {
            return this.hls.streamController.stats.bwEstimate;
        }
        return 'unknown';
    }
    /**
     * Returns the type of the source chosen by the native player:
     * @returns {String}
     */
    get currentSrcType() {
        const currentSrc = this.video.currentSrc;
        if (!currentSrc) {
            return null;
        }
        if (currentSrc.match(/^blob/)) {
            return 'hls-polyfilled';
        }
        if (currentSrc.match(/m3u8$/)) {
            return 'hls';
        }
        return 'mp4';
    }

    get dimensions() {
        if (this.currentSrcType === 'mp4' && this.video.videoWidth && this.video.videoHeight) {
            return this.video.videoWidth + 'x' + this.video.videoHeight;
        }
        return undefined;
    }

    /**
     * Fires a tracking event
     * @param {string} event - The name of the event.
     * @param {Object} [meta={}] - Optional extra attributes to send.
     */
    track(event, meta = {}) {
        this.config.track(Object.assign({},
            this.sessionVars, {
                'type': event,
                'value': event,
                'video_ts': Math.round(this.video.currentTime * SECS_TO_MS),
                'audio_volume': this.videoIsMuted ? 'muted' : 'unmuted',
                'orientation': getScreenOrientation(),
                'buffer_count': this.bufferCounter,
                'buffer_duration': this.bufferTotalTime,
                'bandwidth': this.bandwidth,
                'hls_level': this.hls.currentLevel
            },
            meta));
    }

    /**
     * Immediately flush any pending events
     */
    flush() {
        this.config.flush();
    }

    /**
     *  Track which parts of the video were watched and for how long
     *  See:
     *  https://github.com/buzzfeed/data-guide/blob/master/guide/schemas/pixiedust/video_player.md
     */
    startNewViewSegment() {
        if (this.segmentStartTime !== undefined) {
            this.track('video_view_segment', {
                'video_ts': Math.round(this.segmentStartTime * SECS_TO_MS),
                duration: Math.round((this.video.currentTime - this.segmentStartTime) * SECS_TO_MS)
            });
        }
        this.segmentStartTime = this.video.currentTime;
    }

    /**
     * Update the total buffer seconds
     */
    updateBuffer() {
        if (this.bufferStartTime) {
            var now = new Date();
            this.bufferTotalTime += Math.round(now - this.bufferStartTime);
            this.bufferStartTime = null;
        }
    }

    /**
     *  The first play event is counted as a 'video_view'
     *  Subsequent plays count as 'resume' events
     */
    onFirstPlay() {
        this.startNewViewSegment();
        this.initSessionVars();
        this.track('video_view');
        this.video.removeEventListener('play', this.listeners['play']);
        this.listeners['play'] = this.onResume.bind(this);
        this.video.addEventListener('play', this.listeners['play']);
    }

    /**
     *  Only track scrubs greater than 1 second
     *  This avoids an issue where HLS.js moves the video forward 43ms on load
     */
    onSeeked() {
        if (Math.abs(this.video.currentTime - this.videoCurrentTime) >= 1) {
            this.startNewViewSegment();
            this.videoCurrentTime = this.video.currentTime;
            this.track('scrub');
        }
    }

    /**
     *  Fires a pause event
     *  Pauses longer than 1 second should trigger a new view segment
     */
    onPause() {
        this.updateBuffer();
        this.viewSegmentTimeout = setTimeout(
            this.startNewViewSegment.bind(this), VIEW_SEGMENT_PAUSE_TIMEOUT
        );
        this.track('pause');
    }

    /**
     * Fires a resume event
     */
    onResume() {
        clearTimeout(this.viewSegmentTimeout);
        this.track('resume');
    }

    /**
     * Fires a waiting event
     * Start a buffer timer and increment counter
     */
    onWaiting() {
        var now = new Date();
        this.bufferStartTime = now;
        this.bufferCounter += 1;
    }

    /**
     * Fires a playing event
     */
    onPlaying() {
        this.updateBuffer();
    }

    /**
     * Fires a mute event
     * Trigger tracking for videos that are not collateral of automute
     */
    onVolumeChange() {
        // only if muted state has changed
        if (this.video.muted !== this.videoIsMuted) {
            // would have the following attribute if it's a casualty of automute
            if (!this.video.hasAttribute('data-automuted')) {
                this.startNewViewSegment(); // order is important here
                this.videoIsMuted = !this.videoIsMuted;
                this.track('mute');
            } else {
                this.videoIsMuted = !this.videoIsMuted;
            }
        }
    }

    /**
     * Verify if the video is visible and trigger impression if yes
     */
    verifyImpression() {
        const requiredVisible = 0.75; // 75% visible
        const rect = this.video.getBoundingClientRect();
        const max = getWindow().innerHeight - rect.height * requiredVisible;
        if (rect.top >= 0 && rect.top < max) {
            this.track('impression');
            scrollListener.remove(this.scrollListenerId);
            this.scrollListenerId = null;
        }
    }

    /**
     * Ends the current view segment and flushes pending events
     */
    onUnload() {
        this.startNewViewSegment();
        this.flush();
    }

    /**
     * Add all event listeners
     */
    addListeners() {
        this.listeners = {};
        this.handlerMap = {
            volumechange: this.onVolumeChange,
            seeked: debounce(this.onSeeked, SCRUB_DEBOUNCE_RATE),
            pause: this.onPause,
            play: this.onFirstPlay,
            playing: this.onPlaying,
            waiting: this.onWaiting
        };
        Object.keys(this.handlerMap).forEach(event => {
            this.listeners[event] = this.handlerMap[event].bind(this);
            this.video.addEventListener(event, this.listeners[event]);
        });
        // If the user navigates away, we want to end the current view segment
        window.addEventListener('beforeunload', this.onUnload.bind(this));
    }
}

export default function addVideoEvents(video, config) {
    return new Analytics(video, config);
}