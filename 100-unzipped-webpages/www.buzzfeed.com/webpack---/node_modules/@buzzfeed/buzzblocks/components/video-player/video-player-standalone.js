import {
    supportsHlsPolyfill,
    supportsHlsNatively,
    polyfillHls
} from '../../js/services/polyfill-hls';

import {
    HLS_CONTENT_TYPE,
    getOrderedRenditions,
    getVideoInfo,
    getPosterUrl
} from '../../js/services/video-player-service';
import addVideoAnalytics from '../../js/services/video-player-analytics';
import addSkin from './video-player-skin/video-player-skin';
import videoKeyboardControls from './video-player-keyboard/video-player-keyboard';
import addAutoplay from './video-player-autoplay/video-player-autoplay';
import addAutomute from './video-player-automute/video-player-automute';
import templateError from './video-player-error/video-player-error.html';
const getElementWidth = element => element.getBoundingClientRect().width;

export default class VideoPlayer {

    /**
     * Creates a new VideoPlayer instance
     * @param {Object} context - the t3 Context
     */
    constructor({
        config,
        container,
        broadcast = () => {}
    }) {
        this.config = config;
        if (!config.videoId && !config.transcoderPath) {
            throw new Error('VideoPlayer - You must supply either a videoId or transcoderPath');
        }
        this.container = container.appendChild(this.wrapper);
        this.broadcast = broadcast;
        this.setPlatformSpecificConfig();
        this.shouldPreload = this.config.preload !== false;
        this.element = this.basicVideoElement;
    }

    /**
     * Creates a base video Element
     * @returns {Element} the video element
     */
    get basicVideoElement() {
        const video = document.createElement('video');
        video.controls = !this.config.hideControls;
        video.preload = this.shouldPreload ? 'auto' : 'metadata';
        video.muted = !!this.config.muted;
        video.loop = !!this.config.loop;
        video.className = 'video-player';
        // playsinline is an iOS-specific attribute to avoid fullscreen by default (iOS 10+ only)
        video.setAttribute('playsinline', '');
        return video;
    }

    /**
     * Creates a video wrapper Element. Used to contain state and styling.
     * @returns {Element} the video wrapper div
     */
    get wrapper() {
        const wrapper = document.createElement('div');
        wrapper.className = 'video-player__wrapper video-player-skin';
        wrapper.dataset.state = 'init';
        return wrapper;
    }

    /**
     * Overwrite configuration for specific platforms
     */
    setPlatformSpecificConfig() {
        // TODO: OOSITE-249 we should drop this kind of mobile detection as soon as possible
        const isAndroid = navigator.userAgent.match(/android/i);
        const isIOS = navigator.userAgent.match(/iphone|ipad|ipod/i);
        const isMobile = isAndroid || isIOS;
        const platformOverrides = {};
        if (isMobile && !this.config.loop) {
            platformOverrides.autoplay = false; // We want to forcibly block autoplay on mobile when not looped
        }
        if (isIOS) {
            platformOverrides.skin = false; // We cant reliably hide native controls e.g. fullscreen exit
        }
        this.config = Object.assign({}, this.config, platformOverrides);
    }

    /**
     * Prepares the video element, ready for appending to DOM
     * @param {Object} [title] - optional video title
     * @param {Object[]} renditions - array of video renditions
     * @param {String} thumbnail_url - video thumbnail image URL
     */
    prepareVideo(videoInfo) {
        const containerWidth = getElementWidth(this.container);
        const {
            title = 'unknown', duration, renditions, thumbnail_url: thumbnailUrl
        } = videoInfo;
        this.videoInfo = videoInfo;
        this.title = title;
        this.duration = duration;
        this.renditions = getOrderedRenditions(containerWidth, renditions);
        this.hasHLSRendition = this.renditions[0].content_type === HLS_CONTENT_TYPE;
        this.config['show_id'] = videoInfo.show_id;
        // For autoplay videos we use `poster_url` which is the first frame, otherwise thumbnail_url
        // which is taken at 3 seconds in to avoid all-black posters.
        const posterUrl = (thumbnailUrl && !this.config.autoplay) ?
            thumbnailUrl :
            this.renditions[0].poster_url;
        this.element.poster = getPosterUrl(posterUrl, containerWidth);
        if (this.config.skin) {
            addSkin({
                video: this.element,
                container: this.container
            });
        }
    }

    /**
     * Starts keyboard event listeners to control the player
     */
    prepareKeyboardControls() {
        this.element.addEventListener('click', () => {
            this.container.classList.remove('video-player-skin--keyboard');
            document.querySelector('.js-play-button').focus();
        });
        this.container.addEventListener('keydown', videoKeyboardControls.bind(this));
    }

    /**
     * Loads HLS.js if required for the current browser
     * @returns {Promise}
     */
    loadHlsPolyfillIfNeeded() {
        if (this.hasHLSRendition && !supportsHlsNatively() && supportsHlsPolyfill()) {
            return polyfillHls({
                video: this.element,
                source: this.renditions[0].url,
                preload: this.shouldPreload
            });
        }
        return Promise.resolve();
    }

    /**
     * Inserts the video into the DOM
     */
    append() {
        this.renditions.forEach(source => {
            const sourceElem = document.createElement('source');
            sourceElem.src = source.url;
            sourceElem.type = source.content_type;
            this.element.appendChild(sourceElem);
        });
        this.container.appendChild(this.element);
    }

    /**
     * Broadcasts a 'video-player-loaded-video' event
     * @param {Object} videoInfo - the videoInfo
     * @returns {Object} videoInfo, for chaining
     */
    broadcastNewVideoLoaded(videoInfo) {
        this.broadcast('video-player-loaded-video', videoInfo);
        return videoInfo;
    }

    /**
     * Load an error message in the video placeholder when it does't load
     */
    loadMessageError() {
        this.container.insertAdjacentHTML('beforeend', templateError.render());
    }

    /**
     * Fetches video info and creates an appropriate player.
     * Called by t3 on application start.
     */
    init() {
        let videoInfo;
        // Use the passed videoInfo object, otherwise fetch one from VPS
        if (this.config.videoInfo) {
            videoInfo = Promise.resolve(this.config.videoInfo);
        } else {
            videoInfo = getVideoInfo({
                videoId: this.config.videoId,
                transcoderPath: this.config.transcoderPath,
                env: this.config.env || window.BZFD.Config.env
            });
        }

        return videoInfo
            .then(this.broadcastNewVideoLoaded.bind(this))
            .then(this.prepareVideo.bind(this))
            .then(this.append.bind(this))
            .then(() => videoKeyboardControls(this))
            .then(this.loadHlsPolyfillIfNeeded.bind(this))
            .then(hls => {
                if (this.config.autoplay) {
                    if (this.config.autoplay === 'simple') {
                        this.element.play();
                    } else {
                        addAutoplay(this.element);
                    }
                    this.element.dataset.autoplay = '';
                }
                if (this.config.automute) {
                    addAutomute(this.element, this.config.muted);
                }

                if (this.config.analytics) {
                    this.analytics = addVideoAnalytics(this.element, {
                        videoId: this.config.videoId,
                        transcoderPath: this.config.transcoderPath,
                        videoDuration: this.duration,
                        releasedAt: this.videoInfo.released_at,
                        videoTitle: this.title,
                        platform: this.config.platform,
                        playerLocation: this.config.playerLocation,
                        origin: this.config.origin,
                        track: this.config.track,
                        flush: this.config.flush,
                        hls
                    });
                }
            })
            .catch(this.loadMessageError.bind(this));
    }
}