import solid from '@buzzfeed/buzzblocks/js/services/solid';
import localization from '@buzzfeed/buzzblocks/js/services/localization';

// unit fields exist to ensure consistent naming between our tags and what BFA
// expects when mapping
const UNIT_FIELDS = {
    id: 'id',
    type: 'type',
    contentCategory: 'contentCategory',
    unit: 'unit',
    unitType: 'unitType',
    unitName: 'unit_name',
    // TODO: Remove `position` once we have transitioned to v2 schema (becomes `position_in_unit`)
    position: 'position',
    positionInUnit: 'position_in_unit',
    dataSource: 'dataSource',
    subUnit: 'subUnit',
    variationId: 'variationId',
};

/**
 * mapIsFeed is used in the condition for createConfigForRoute to determine if
 * a given tracked element is a 'Feed'
 *
 * @param {Object} a src object
 * @returns {bool} if the router is a feed
 */
const mapIsFeed = src => src.l === 'Feed' && src.n === 'FeedItem';

/**
 * bfaTagger should be called within an open element, it will inject two
 * attributes that will prepare it for tracking
 *
 * @param {string} unitType - the name of the unit's type (for added context when tracking)
 * @param {string} unit - the name of the unit (for tracking)
 * @param {Object} item - the item
 * @param {string} unitName - the name of the unit and subunit (for added context when tracking new pixiedust events)
 */
export const bfaTagger = (unitType, unit, item, unitName) => {
    if (!unit) {
        throw new Error('unit must be specified for tracking');
    }

    // variationId is set here:
    // https://github.com/buzzfeed/mono/blob/master/packages/frontend/buzzblocks/js/services/flexpro/index.js#L17
    return `
    data-bfa-impressions="true"
    data-bfa="@a:FeedItem; @e:{ ${UNIT_FIELDS.id}:${item.id},
                                ${UNIT_FIELDS.type}:${item.type || 'buzz'},
                                ${UNIT_FIELDS.contentCategory}:${item.category || ''},
                                ${UNIT_FIELDS.unit}:${unit},
                                ${UNIT_FIELDS.unitType}:${unitType},
                                ${UNIT_FIELDS.unitName}:${unitName},
                                ${UNIT_FIELDS.position}:${item.number || item.position || -1},
                                ${UNIT_FIELDS.positionInUnit}:${item.position},
                                ${UNIT_FIELDS.dataSource}:${item.dataSource || item.data_source},
                                ${UNIT_FIELDS.subUnit}:${item.sub_unit || ''},
                                ${UNIT_FIELDS.variationId}:${item.variationId || ''}
                              };"
  `;
};

/**
 * pixiedustFeedTrackingMapper takes a bfa mapper and sets up click and
 * impression events on feeds
 *
 * @param {Object} mapper (BFA mapper)
 */
export const pixiedustFeedTrackingMapper = mapper => {
    let feedTmpl = mapper.createMapTemplate('feedTmpl');

    // items tracked from page and inferred attributes
    feedTmpl.addMapTo('page_edition', localization.getEdition());
    feedTmpl.addMapTo('page_type').mapFrom('data.page.type');
    feedTmpl.addMapTo('page').mapFrom('data.page.type'); // same as page_type
    feedTmpl.addMapTo('page_url').mapFrom('data.page.uri.path');
    feedTmpl.addMapTo('author').mapFrom('data.page.post.author');
    feedTmpl.addMapTo('author_id').mapFrom('data.page.post.authorId');
    feedTmpl.addMapTo('post_category').mapFrom('data.page.category');
    feedTmpl.addMapTo('mode', solid.isXsmall() || solid.isSmall() ? 'mobile' : 'desktop');

    const data = prop => ev => ev.data[prop];

    // items tracked from the BFA tags on each feed element
    feedTmpl.addMapTo('content_id').mapFrom(src => `${src.data[UNIT_FIELDS.type] || 'buzz'}:${src.data[UNIT_FIELDS.id]}`);
    feedTmpl.addMapTo('content_category').mapFrom(data(UNIT_FIELDS.contentCategory));
    feedTmpl.addMapTo('unit').mapFrom(data(UNIT_FIELDS.unit));
    feedTmpl.addMapTo('unitType').mapFrom(data(UNIT_FIELDS.unitType));
    feedTmpl.addMapTo('position').mapFrom(data(UNIT_FIELDS.position));
    feedTmpl.addMapTo('data_source').mapFrom(data(UNIT_FIELDS.dataSource));
    feedTmpl.addMapTo('sub_unit').mapFrom(data(UNIT_FIELDS.subUnit));
    feedTmpl.addMapTo('variation_id').mapFrom(data(UNIT_FIELDS.variationId));

    let feedClickMapper = mapper.getOrCreateRouter('track/click').createConfigForRoute(mapIsFeed);
    feedClickMapper.applyTemplateByName('feedTmpl');
    feedClickMapper.addMapTo('type', 'unit_click');

    let feedImpressionMapper = mapper.getOrCreateRouter('track/scroll/impression').createConfigForRoute(mapIsFeed);
    feedImpressionMapper.applyTemplateByName('feedTmpl');
    feedImpressionMapper.addMapTo('type', 'unit_impression');
};

/**
 * gaFeedTrackingMapper takes a bfa mapper and sets up click and
 * impression events on feeds
 *
 * @param {Object} mapper (BFA mapper)
 * @param {Bool} impressions (defaults to false, if true will track impressions under "impression" action)
 */
export const gaFeedTrackingMapper = (mapper, impressions = false) => {
    let gaFeedTmpl = mapper.createMapTemplate('gaFeedTmpl');

    gaFeedTmpl.addMapTo('category').mapFrom(src => `${src.data[UNIT_FIELDS.unitType]}:${src.data[UNIT_FIELDS.unit]}`);
    gaFeedTmpl.addMapTo('label').mapFrom(src => `${src.data[UNIT_FIELDS.type] || 'buzz'}:${src.data[UNIT_FIELDS.id]}`);
    gaFeedTmpl.addMapTo('value').mapFrom(src => src.data[UNIT_FIELDS.position]);

    let feedClickMapper = mapper.getOrCreateRouter('track/click').createConfigForRoute(mapIsFeed);
    feedClickMapper.applyTemplateByName('gaFeedTmpl');
    feedClickMapper.addMapTo('action', 'click');

    if (impressions) {
        let feedImpressionMapper = mapper.getOrCreateRouter('track/scroll/impression').createConfigForRoute(mapIsFeed);
        feedImpressionMapper.applyTemplateByName('gaFeedTmpl');
        feedImpressionMapper.addMapTo('action', 'impression');
    }
};