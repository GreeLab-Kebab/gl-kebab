import utils from "./common/bfa_utils.js";
import defs from "./common/bfa_defs.js";
import Router from "./common/bfa_router.js";
import Signal from "signals";
import {
    isString,
    isPlainObject,
    isFunction,
    has,
    isArray,
    get,
    isUndefined,
    keys,
    after,
    defer,
} from "lodash";


"use strict";

/**
 * BF analytics core class
 * @constructor
 */
function BFACore() {
    this._modules = {};
    this._plugins = {};
    this._instances = {};
    this._router = new Router();

    this.inited = new Signal();
    this.active = new Signal();
    this.crashed = new Signal();

    this._inited = false;
    this._active = false;
    this._crashed = false;

    this.crashed.add(function() {
        this._crashed = true;
        this.log.error("CRASHED");
    }, this, Number.MAX_VALUE);

    // subscribe route init
    this._router.sub("bfa/subscribe/{action}/{eventName}", this._subscribe, this, {
        action: ["add", "addOnce", "remove", ],
        eventName: function(value) {
            return isString(value) && value.length > 0;
        },
    });
    this.inited.add(function() {
        this._inited = true;
    }, this, Number.MAX_VALUE);

    this.active.add(function() {
        this._active = true;
    }, this, Number.MAX_VALUE);

    /**
     * Default SandBox constructor
     * @param {BFACore} core - bfa core instance
     * @param {string} instanceId - module instance identifier
     * @param {object} settings - module settings
     * @param {string} moduleId - module identifier
     * @returns {Sandbox} - this
     * @constructor
     */
    this.Sandbox = function(core, instanceId, settings, moduleId) {
        this.instanceId = instanceId;
        this.moduleInited = new Signal();
        this.moduleActive = new Signal();
        this.fillModuleRoute = function(route) {
            return "module/" + instanceId + "/" + route;
        };
        this.subOn = function(pattern, cb, context) {
            core._router.sub(pattern, cb, context);
        };
        this.settings = settings || {};
        this.moduleId = moduleId;
        this.utils = core.utils;
        this.defs = core.defs;
        return this;
    };

    this.construct.dispatch(this);
}

/**
 * logger mock
 * @todo Due to the current initialization lifecycle, nothing will be logged until LoggerPlugin is active.
 * This mock is reassigned inside the LoggerPlugin.
 * The core itself doesn't know if the current env enabled logging until generalSettings plugin is active.
 * Logging errors regardless of environment for now.
 * Production errors are reported to sentry anyway.
 * @type {{error: BFACore.log.error, log: BFACore.log.log,
 * info: BFACore.log.info, warn: BFACore.log.warn, enabled: BFACore.log.enabled}}
 */
BFACore.prototype.log = {
    error: function(msg) {
        /* eslint-disable no-console */
        if (window.console) {
            window.console.error("BFA [ BFACore ] " + msg);
        }
        /* eslint-enable no-console */
    },
    log: function() {},
    info: function() {},
    warn: function() {},
    enabled: function() {},
};

/**
 * On construct event
 */
BFACore.prototype.construct = new Signal();
BFACore.prototype.utils = utils;
BFACore.prototype.defs = defs;

/**
 * Handler for bfa/subscribe/{action}/{eventName} route. Checks that all args are valid, checks for the property with
 * the name specified in params.eventName with type of Signal, calls it with args from dataObj
 * @param {object} dataObj - must contains fn property (type of Function) and context property with specified context
 * @param {object} params - params from router
 * @returns {BFACore} - instance of BFCore
 * @private
 */
BFACore.prototype._subscribe = function(dataObj, params) {
    if (isPlainObject(dataObj) && isPlainObject(params) &&
        this[params.eventName] instanceof Signal &&
        isFunction(dataObj.fn) &&
        dataObj.context) {
        this[params.eventName][params.action](dataObj.fn, dataObj.context);
    }
    return this;
};

/**
 * Registers module in BFA Core
 * @param {function} module - module constructor
 * @param {object} settings - module settings
 * @param {string} moduleId - module identifier (optional)
 * @returns {BFACore} - this
 */
BFACore.prototype.registerModule = function(module, settings, moduleId) {
    // have to be removed when we will support this in the future
    if (this._inited === true) {
        this.log.warn("You can't register module after activation");
        return this;
    }
    settings = settings || {};
    var err = this.utils.checkType("function", module, "module") ||
        this.utils.checkType("object", settings, "settings");
    if (err) {
        throw new TypeError(err);
    }
    if (!isString(moduleId) && isString(module.defaultId)) {
        moduleId = module.defaultId;
    }
    if (!isString(moduleId) || moduleId.length === 0) {
        throw new TypeError("moduleId has to be specified (as third argument or as `id` property of module)" +
            " and must be not empty string");
    }
    if (has(this._modules, moduleId)) {
        this.log.warn("module " + moduleId + " was already registered");
        return this;
    }
    this.push("module/" + moduleId + "/added");
    this._modules[moduleId] = {
        Creator: module,
        settings: settings,
        id: moduleId,
    };
    return this;
};

/**
 * Registers plugin in BFA Core
 * @param {function} Plugin - plugin constructor
 * @param {object} settings - settings
 * @param {string} pluginId - plugin identifier (optional)
 * @returns {BFACore} - this
 */
BFACore.prototype.plugin = function(Plugin, settings, pluginId) {
    // have to be removed when we will support this in the future
    if (this._inited === true) {
        this.log.warn("You can't add plugins after activation");
        return this;
    }
    settings = settings || {};
    var err = this.utils.checkType("function", Plugin, "plugin") ||
        this.utils.checkType("object", settings, "settings");
    if (err) {
        throw new TypeError(err);
    }
    if (!isString(pluginId) && isString(Plugin.defaultId)) {
        pluginId = Plugin.defaultId;
    }
    if (!isString(pluginId) || pluginId.length === 0) {
        throw new TypeError("pluginId has to be specified (as third argument or as `id` property of plugin)" +
            " and must be not empty string");
    }
    if (has(this._plugins, pluginId)) {
        this.log.warn("plugin " + pluginId + " was already registered");
        return this;
    }

    this._plugins[pluginId] = {
        Creator: Plugin,
        instance: null,
        settings: settings,
        id: pluginId,
    };
    return this;
};

/**
 * Activates added plugins
 * @return {Void} - void
 */
BFACore.prototype.activatePlugins = function() {
    if (this._crashed === true) {
        this.log.error("Plugins activation interrupted");
        return;
    }
    // activation started
    // Plugins dependencies resolving functionality based on topological sorting
    var sortedPluginIds = [];
    var visitedPlugins = {};
    var _this = this;

    function visitPlugin(name, ancestors) {
        if (!isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visitedPlugins[name] = true;
        get(_this._plugins[name], "Creator.require", []).forEach(function(dep) {
            if (isUndefined(_this._plugins[dep])) {
                throw new Error("Can't resolve \"" + dep + "\" for \"" + name + "\" plugin");
            }
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency \"" + dep + "\" is required by \"" + name + "\" plugin: " +
                    ancestors.join(" -> "));
            }
            if (visitedPlugins[dep]) return;
            visitPlugin(dep, ancestors.slice(0)); // recursive call
        }, _this);
        if (sortedPluginIds.indexOf(name) < 0) {
            sortedPluginIds.push(name);
        }
    }
    try {
        // ordering plugins ids by dependencies
        this.utils.forOwn(this._plugins, function(plugin) {
            visitPlugin(plugin.id);
        }, this);

        // plugins init process
        for (var i = 0; i < sortedPluginIds.length; i++) {
            var pluginId = sortedPluginIds[i];
            if (this._plugins[pluginId].instance === null) {
                this._plugins[pluginId].instance = new this._plugins[pluginId]
                    .Creator(this, this._plugins[pluginId].settings);
                this.push("plugin/" + pluginId + "/added");
            } else {
                this.log.warn("Plugin " + pluginId + " already added and activated");
            }
        }
    } catch (err) {
        // report the crashed plugin to sentry.io
        if (typeof window.BZFD !== "undefined" &&
            (window.BZFD.Config.env === "live" ||
                window.BZFD.Config.env === "prod") &&
            window.raven) {
            raven.captureException(err);
        }

        this.log.error(err);
        this.log.error("Plugins activation interrupted");
        this.crashed.dispatch();
        return;
    }
}

/**
 * Activates BFA Core (initializes modules and sandboxes). Runs activatePlugins for plugins activation as well.
 * @return {Void} - void
 */
BFACore.prototype.activate = function() {
    if (this._inited === true) {
        this.log.warn("Already initialized");
        return;
    }
    this.activatePlugins();
    if (this._crashed === true) {
        this.log.error("Activation interrupted");
        return;
    }
    var _this = this;

    this.utils.forOwn(this._modules, function(moduleContainer) {
        var instanceId = moduleContainer.Creator.defaultId;
        var err = false;
        if (isString(moduleContainer.settings.instanceId)) {
            instanceId = moduleContainer.settings.instanceId;
        }
        // module's sandbox init process
        var sandboxInst = new this.Sandbox(this, instanceId, moduleContainer.settings, moduleContainer.Creator.defaultId);
        if (isArray(moduleContainer.Creator.require) && moduleContainer.Creator.require.length > 0) {
            // required plugins functionality injection
            for (var index = 0; index < moduleContainer.Creator.require.length; index++) {
                var pluginName = moduleContainer.Creator.require[index];
                if (has(this._plugins, pluginName) &&
                    has(this._plugins[pluginName].instance, "modifySBInstance")) {
                    this._plugins[pluginName].instance.modifySBInstance(sandboxInst);
                } else {
                    err = "Module " + moduleContainer.Creator.defaultId + " require plugin " + pluginName;
                    break;
                }
            }
        }
        if (!err) {
            var moduleInstance = new moduleContainer.Creator(sandboxInst);
            if (has(moduleInstance, "init")) {
                this._instances[instanceId] = {
                    module: moduleInstance,
                    sandbox: sandboxInst,
                };
                this.push("module/" + instanceId + "/added");
            } else {
                err = "Constructor of module " + module.defaultId + " returned not valid object";
            }
        }
        if (err) {
            this.log.error(err);
            this.log.error("Instance " + instanceId + " of module " + module.defaultId + " is not added properly");
        }
    }, this);

    var instancesLength = keys(this._instances).length;
    var initCallback = after(instancesLength, function() {
        _this.inited.dispatch(_this);
    });
    var activeCallback = after(instancesLength, function() {
        _this.active.dispatch(_this);
    });

    // init process
    this.utils.forOwn(this._instances, function(instance) {
        instance.sandbox.moduleInited.addOnce(initCallback);
        instance.sandbox.moduleActive.addOnce(activeCallback);
        defer(instance.module.init);
    }, this);
};

/**
 * Method for events pushing
 * @returns {Void} - void
 */
BFACore.prototype.push = function() {
    this._router.pub.apply(this._router, arguments);
};

export default BFACore;