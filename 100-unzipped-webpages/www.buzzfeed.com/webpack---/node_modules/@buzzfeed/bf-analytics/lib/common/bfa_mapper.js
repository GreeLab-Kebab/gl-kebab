import defs from "./bfa_defs";
import utils from "./bfa_utils";
import {
    isString,
    isUndefined,
    isFunction,
    isArray,
    every,
    get,
    set,
    has,
} from "lodash";

"use strict";

/**
 * Provides functionality for variable/property mapping
 * @param {string} destinationVarPath - destination variable path (for example obj.foo.bar)
 * @param {*} defaultValue - default value
 * @constructor
 */
function BfaMapperMapTo(destinationVarPath, defaultValue) {
    if (isString(destinationVarPath) === false || destinationVarPath.length <= 0) {
        throw new TypeError("\"mapTo\" should be a non empty string");
    }
    if (isUndefined(defaultValue)) {
        defaultValue = null;
    }
    this.destinationVarPath = destinationVarPath;
    this.mappingType = this.mappingTypes.sourcePath;
    this.mappingFrom = undefined;
    this.preFormatters = [];
    this.defaultValue = defaultValue;
}

BfaMapperMapTo.prototype.mappingTypes = {
    sourcePath: 1,
    function: 2,
};

/**
 * Mapping source set up
 * @param {function|string} mapFrom - function (which has to receive source object in arguments and returns a value
 * for mapping) or path to some source object variable
 * @param {array} preFormatters - formatters that are going to be applied on result
 * @returns {BfaMapperMapTo} - this
 */
BfaMapperMapTo.prototype.mapFrom = function(mapFrom, preFormatters) {
    if (isFunction(mapFrom)) {
        this.mappingType = this.mappingTypes.function;
        this.mappingFrom = mapFrom;
    } else
    if (isString(mapFrom) && mapFrom.length > 0) {
        this.mappingType = this.mappingTypes.sourcePath;
        this.mappingFrom = mapFrom;
    } else {
        throw new TypeError("\"mapFrom\" is object of wrong type: " + (typeof mapFrom).toString());
    }
    if (isArray(preFormatters) && every(preFormatters, function(v) {
            return v instanceof Function;
        })) {
        this.preFormatters.push.apply(this.preFormatters, preFormatters);
    }
    return this;
};

/**
 * Method which returns value that has to be mapped to corresponded destination variable
 * @param {object} source - source object
 * @param {object} destination - destination object
 * @param {*} currentContext - mapping context
 * @returns {*|null} - value
 */
BfaMapperMapTo.prototype.map = function(source, destination, currentContext) {
    var result = this.defaultValue;

    if (!isUndefined(this.mappingFrom)) {
        switch (this.mappingType) {
            case this.mappingTypes.function:
                result = this.mappingFrom.call(currentContext, source, destination);
                break;
            case this.mappingTypes.sourcePath:
                result = get(source, this.mappingFrom, this.defaultValue);
                break;
        }
    }
    if (isUndefined(result)) {
        result = this.defaultValue;
    }
    if (this.preFormatters.length > 0) {
        this.preFormatters.forEach(function(formatter) {
            result = formatter.call(currentContext, result);
        });
    }
    set(destination, this.destinationVarPath, result);
    return result;
};

/**
 * Class provides map configuration set up functionality
 * @param {object} options - options
 * @constructor
 */
function BfaMapperMapConfig(options) {
    this.options = options;
    this.mapToCollection = [];
}

/**
 * Method for mapping destination configuration
 * @param {string} destinationVarPath - destination of variable/property for mapping
 * @param {*} defaultValue - default value
 * @returns {BfaMapperMapTo} - instance of BfaMapperMapTo
 */
BfaMapperMapConfig.prototype.addMapTo = function(destinationVarPath, defaultValue) {
    var newMapTo = new BfaMapperMapTo(destinationVarPath, defaultValue);
    this.mapToCollection.push(newMapTo);
    return newMapTo;
};

/**
 * BfaMapperConfig extended with template functionality
 * @param {object} options - options
 * @constructor
 */
function BfaMapperMapConfigExtended(options) {
    BfaMapperMapConfig.call(this, options);
    this.templatesToApply = [];
}

BfaMapperMapConfigExtended.prototype = Object.create(BfaMapperMapConfig.prototype);
BfaMapperMapConfigExtended.prototype.constructor = BfaMapperMapConfigExtended;

/**
 * Applies template (map config that was added as template) by name
 * @param {string} templateName - name of already added template
 * @returns {Void} - void
 */
BfaMapperMapConfigExtended.prototype.applyTemplateByName = function(templateName) {
    if (this.templatesToApply.indexOf(templateName) === -1) {
        this.templatesToApply.push(templateName);
    }
};

/**
 * Model for route function and corresponded map config storing
 * @param {function} routeFunc - function that checks source object and returns true if corresponded map config
 * should be used, false otherwise
 * @param {BfaMapperMapConfig} mapConfig - corresponded map config
 * @constructor
 */
function BfaMapperRoute(routeFunc, mapConfig) {
    if (!routeFunc || !isFunction(routeFunc)) {
        throw new Error("routeFunc should be a function that receives src object as parameter and returns bool");
    }
    if (!mapConfig || !(mapConfig instanceof BfaMapperMapConfig)) {
        throw new Error("mapConfig should be an instance of BfaMapperMapConfig");
    }
    this.routeFunc = routeFunc;
    this.mapConfig = mapConfig;
}

/**
 * Class that provides possibility to use different map configs for different source state
 * @param {string} mapName - mapper router name
 * @param {object} options - options
 * @constructor
 */
function BfaMapperRouter(mapName, options) {
    this.mapName = mapName;
    this.options = options;
    this.routers = [];
    this.defaultMapConfig = null;
}

/**
 * Returns map config which is correspond to source state
 * @param {object} src - source
 * @param {*} currentContext context for route functions
 * @returns {*} - map config object
 */
BfaMapperRouter.prototype.getMapConfig = function(src, currentContext) {
    var resultedMapConfig = null;
    for (var i = 0; i < this.routers.length; i++) {
        var route = this.routers[i];
        if (route.routeFunc.call(currentContext, src) === true) {
            resultedMapConfig = route.mapConfig;
            break;
        }
    }
    if (resultedMapConfig === null) {
        resultedMapConfig = this.defaultMapConfig;
    }
    return resultedMapConfig;
};

/**
 * Creates new map config for specified route function
 * @param {function} routeFunc - have to check source object and return true/false (is current route can be used
 * for mapping)
 * @returns {BfaMapperMapConfig|*} - new mapping config
 */
BfaMapperRouter.prototype.createConfigForRoute = function(routeFunc) {
    var newRoute = new BfaMapperRoute(routeFunc, new BfaMapperMapConfigExtended(this.options));
    this.routers.push(newRoute);
    return newRoute.mapConfig;
};

/**
 * Creates default map config
 * @returns {BfaMapperMapConfig|*} - new default mapping config
 */
BfaMapperRouter.prototype.createDefaultConfig = function() {
    this.defaultMapConfig = new BfaMapperMapConfigExtended(this.options);
    return this.defaultMapConfig;
};

/**
 * @classdesc BfaMapper provides flexible mapping functionality
 * @class
 */
function BfaMapper() {
    this.mapRouters = {};
    this.mapTemplates = {};
    this._utils = {
        utils: utils,
        defs: defs,
    };
}

/**
 * Method for adding utility functions, which is providing possibility to use added utilities
 * inside mapFrom functions: this[utilityName]
 * @param {string} utilityName - name of utility property
 * @param {*} utility - object, function, variable
 * @returns {BfaMapper} - instance of current mapper
 */
BfaMapper.prototype.addUtility = function(utilityName, utility) {
    if (!this.validateName(utilityName)) {
        throw new TypeError("`utilityName` have to be not empty string");
    }
    if (has(this._utils, utilityName)) {
        throw new Error("utility with " + utilityName + " already exists");
    }
    this._utils[utilityName] = utility;
    return this;
};

/**
 * Returns already added instance / create new instance of map config class by name
 * @param {string} mapName - name of map config
 * @param {object} options - options
 * @returns {null|BfaMapperMapConfigExtended|*} - returns instance of map config class
 */
BfaMapper.prototype.getOrCreateMap = function(mapName, options) {
    if (!this.validateName(mapName)) {
        throw new TypeError("mapName must be a not empty string");
    }
    if (this.mapRouters[mapName]) {
        return this.mapRouters[mapName].defaultMapConfig;
    }
    var newMapRouter = new BfaMapperRouter(mapName, options);

    this.mapRouters[mapName] = newMapRouter;
    return newMapRouter.createDefaultConfig();
};

/**
 * Checks if map with specified name is exists
 * @param {string} mapName - map name
 * @returns {bool} - true if mapConfig with specified name is exists, false otherwise
 */
BfaMapper.prototype.isExists = function(mapName) {
    return has(this.mapRouters, mapName);
};

/**
 * Returns already added instance / create new instance of map router class by name
 * @param {string} routedMapName - name of map router
 * @param {object} options - options
 * @returns {null|BfaMapperMapConfigExtended|*} - returns instance of map router class
 */
BfaMapper.prototype.getOrCreateRouter = function(routedMapName, options) {
    if (!this.validateName(routedMapName)) {
        throw new TypeError("`routeName` should be not empty string");
    }
    if (has(this.mapRouters, routedMapName)) {
        return this.mapRouters[routedMapName];
    }
    var newMapRouter = new BfaMapperRouter(routedMapName, options);
    this.mapRouters[routedMapName] = newMapRouter;
    return newMapRouter;
};

/**
 * Returns already added instance / create new instance of map config class by name (this map config can be reused
 * inside another map config)
 * @param {string} templateName - name of map config
 * @param {object} options - options
 * @returns {null|BfaMapperMapConfigExtended|*} - returns instance of map config class
 */
BfaMapper.prototype.createMapTemplate = function(templateName, options) {
    if (!this.validateName(templateName)) {
        throw new TypeError("`templateName` should be not empty string");
    }
    if (has(this.mapTemplates[templateName])) {
        return this.mapTemplates[templateName];
    }
    var newMapConfig = new BfaMapperMapConfig(options);
    this.mapTemplates[templateName] = newMapConfig;
    return newMapConfig;
};

BfaMapper.prototype.validateName = function(name) {
    if (isString(name) === false || name.length <= 0) {
        return false;
    }
    return true;
};
/**
 * Maps data from a source to a destination. Uses the map config / router with a name which was specified in arguments
 * @param {string} mapName - name of the map configuration / router
 * @param {object} source - source object
 * @param {object} destination - destination object
 * @returns {object} - returns destination
 */
BfaMapper.prototype.map = function(mapName, source, destination) {
    var _this = this;
    if (isUndefined(destination) || destination === null) {
        destination = {};
    }
    if (isUndefined(source) || source === null) {
        return destination;
    }
    if (!has(this.mapRouters, mapName)) {
        return destination;
    }
    var mapConfig = this.mapRouters[mapName].getMapConfig(source, _this._utils);
    if (mapConfig === null) {
        return destination;
    }
    var mapToCollection = mapConfig.mapToCollection;
    if (mapToCollection.length > 0) {
        mapToCollection.forEach(function(mapToObj) {
            mapToObj.map(source, destination, _this._utils);
        });
    }
    var templatesToApply = mapConfig.templatesToApply;
    if (templatesToApply.length > 0) {
        templatesToApply.forEach(function(templateName) {
            if (has(_this.mapTemplates, templateName)) {
                var templateMapToColl = _this.mapTemplates[templateName].mapToCollection;
                templateMapToColl.forEach(function(mapToObj) {
                    mapToObj.map(source, destination, _this._utils);
                });
            }
        });
    }
    return destination;
};
/**
 * Formatters collection
 * @type {{strToLowerCase: BfaMapper.formatters.strToLowerCase,
 * strCutTo255Characters: BfaMapper.formatters.strCutTo255Characters}}
 */
BfaMapper.prototype.formatters = {
    strToLowerCase: function(val) {
        return isString(val) ? val.toLowerCase() : val;
    },
    strCutTo255Characters: function(val) {
        return isString(val) && val.length > 255 ? val.substr(0, 255) : val;
    },
    strToInt: function(val) {
        try {
            return parseInt(val);
        } catch (err) {
            return val;
        }
    },
};


/**
 * Provides functionality for variable/property mapping to an array element
 * @param {string} destinationVarPath - destination array path (for example obj.foo.bar)
 * @param {*} defaultValue - default value
 * @constructor
 */
function BfaMapperMapToArray(destinationVarPath, defaultValue) {
    if (isString(destinationVarPath) === false || destinationVarPath.length <= 0) {
        throw new TypeError("\"mapTo\" should be a non empty string");
    }
    if (isUndefined(defaultValue)) {
        defaultValue = null;
    }
    this.destinationVarPath = destinationVarPath;
    this.mappings = [];
    this.defaultValue = defaultValue;
}

BfaMapperMapToArray.prototype.mappingTypes = {
    sourcePath: 1,
    function: 2,
};

/**
 * Mapping source set up
 * @param {function|string} mapFrom - function (which has to receive source object in arguments and returns a value
 * for mapping) or path to some source object variable
 * @param {array} preFormatters - formatters that are going to be applied on result
 * @returns {BfaMapperMapTo} - this
 */
BfaMapperMapToArray.prototype.mapFrom = function(mapFrom, preFormatters) {
    var mapping = {
        mappingFrom: mapFrom,
        preFormatters: [],
    };
    if (isFunction(mapFrom)) {
        mapping.mappingType = this.mappingTypes.function;
    } else
    if (isString(mapFrom) && mapFrom.length > 0) {
        mapping.mappingType = this.mappingTypes.sourcePath;
    } else {
        throw new TypeError("\"mapFrom\" is object of wrong type: " + (typeof mapFrom).toString());
    }
    if (isArray(preFormatters) && every(preFormatters, function(v) {
            return v instanceof Function;
        })) {
        mapping.preFormatters.push.apply(this.preFormatters, preFormatters);
    }

    this.mappings.push(mapping);
    return this;
};

/**
 * Method which fills destination object with values from source according to configured mappings
 * @param {object} source - source object
 * @param {object} destination - destination object
 * @param {*} currentContext - mapping context
 * @returns {*|null} - returns nothing
 */
BfaMapperMapToArray.prototype.map = function(source, destination, currentContext) {
    var _this = this;
    var destField = get(destination, this.destinationVarPath);
    if (!destField) {
        destField = [];
    }
    if (!isArray(destField)) {
        throw new TypeError("\"Destination\" is an object of wrong type: " + (typeof destField).toString() +
            ". Array is expected");
    }

    this.mappings.forEach(function(mapping) {
        var result = _this.defaultValue;
        if (!isUndefined(mapping.mappingFrom)) {
            switch (mapping.mappingType) {
                case _this.mappingTypes.function:
                    result = mapping.mappingFrom.call(currentContext, source, destination);
                    break;
                case _this.mappingTypes.sourcePath:
                    result = get(source, mapping.mappingFrom, _this.defaultValue);
                    break;
            }
        }
        if (isUndefined(result)) {
            result = _this.defaultValue;
        }
        if (mapping.preFormatters.length > 0) {
            mapping.preFormatters.forEach(function(formatter) {
                result = formatter.call(currentContext, result);
            });
        }
        destField.push(result);
    });

    set(destination, this.destinationVarPath, destField);
};

/**
 * Method for mapping destination configuration
 * @param {string} destinationVarPath - destination of variable/property for mapping
 * @param {*} defaultValue - default value
 * @returns {BfaMapperMapToArray} - instance of BfaMapperMapToArray
 */
BfaMapperMapConfig.prototype.addMapToArray = function(destinationVarPath, defaultValue) {
    var newMapTo = new BfaMapperMapToArray(destinationVarPath, defaultValue);
    this.mapToCollection.push(newMapTo);
    return newMapTo;
};

export default BfaMapper;