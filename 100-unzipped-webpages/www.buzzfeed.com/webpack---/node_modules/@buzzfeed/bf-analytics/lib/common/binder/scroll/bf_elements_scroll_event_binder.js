"use strict";
/**
 * Implements elements scroll binder. Handles the position of the scroll by predefined with
 * configuration HTML elements that were passed. Results are represented as percentage of passed elements
 * that calculated as ratio: passed / expected * 100. This mode is usually used for pages with AJAX loaders.
 * @param {object} options Object with all the configuration parameters such as mode, bounds, etc.
 * @param {string} executable Function that should be invoked with position calculation results
 * if scroll event triggered. Results of calculation represented as BFEventInfo class.
 * @constructor
 */
function ElementsScrollBinder(options, executable) {
    this.options = options || {};
    this.executable = executable;
    this.points = [];

    /**
     * Initialization method. Executes preparation of checkpoints.
     * @returns {Function} Returns handler.
     */
    this.init = function() {
        this.fillCheckPoints();
    };

    /**
     * Handler for the 'onscroll' event. Tracks the position of scroll on the page according to the
     * checkpoints and sends data to the BFA. Results are represented as BFEventInfo.
     * @returns {Function} Returns handler.
     */
    this.track = function() {
        if (!this.options.elementMode.element || !this.options.elementMode.expected) {
            return;
        }

        // 1px added to handle 100% scroll on iphone
        var currentScroll = window.pageYOffset + document.documentElement.clientHeight + 1;
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        var clientTop = document.documentElement.clientTop || document.body.clientTop || 0;
        var elements = document.querySelectorAll(this.options.elementMode.element);

        var passedElementsCount = 0;
        var i;
        for (i = 0; i < elements.length; i++) {
            var elTop = elements[i].getBoundingClientRect().top + scrollTop - clientTop;
            if (elTop <= currentScroll) {
                passedElementsCount++;
            }
        }
        var currentPercentage = passedElementsCount / this.options.elementMode.expected * 100;

        var anchor = null;
        for (i = 0; i < this.options.bottomBounds.length; i++) {
            anchor = document.querySelector(this.options.bottomBounds[i]);
            if (anchor) {
                break;
            }
        }
        if (anchor) {
            var anchorPosition = anchor.getBoundingClientRect().top + scrollTop - clientTop;
            if (currentScroll >= anchorPosition && currentPercentage < 100) {
                currentPercentage = 100;
            }
        }
        // dirty hack [end]

        for (i = 0; i < this.options.checkpoints.length; i++) {
            if (this.points[i].percentage <= currentPercentage && !this.points[i].passed) {
                this.points[i].passed = true;
                var trackingInfo = ["track/scroll/post", {
                    t: "scroll",
                    n: "post",
                    d: this.points[i].percentage.toString(),
                }, ];
                if (this.executable && window[this.executable] instanceof Function) {
                    window[this.executable].apply(this, trackingInfo);
                }
            }
        }
    };

    /**
     * Fills the checkpoints for current module and mark them as not passed.
     * @returns {Function} Returns handler.
     */
    this.fillCheckPoints = function() {
        for (var i = 0; i < this.options.checkpoints.length; i++) {
            this.points.push({
                percentage: this.options.checkpoints[i],
                passed: false,
            });
        }
    };
}

export default ElementsScrollBinder;