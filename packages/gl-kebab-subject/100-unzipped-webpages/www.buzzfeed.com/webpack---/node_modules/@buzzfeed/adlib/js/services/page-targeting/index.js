import {
    isArray,
    mergeWith,
    values
} from 'lodash';
import abeagle from '@buzzfeed/buzzblocks/js/services/abeagle';
import solid from '@buzzfeed/buzzblocks/js/services/solid/standalone';
import {
    getSessionId,
    getUserId
} from '@buzzfeed/bf-utils';
import {
    queryStringToObject
} from '@buzzfeed/bf-utils/lib/query-string';
import gdpr from '../gdpr';
import bzfd from '../bzfd';
import ads from '../../../core/ads';


const DFP_KEYWORD_PARAM = 'dfp-keyword';

function getExperimentVariant(experiment, abeagleOptions = {}) {
    // defaults
    let options = {
        defaultVariantIfUnbucketed: null,
        rejectErrors: false
    };
    abeagleOptions = Object.assign(options, abeagleOptions);
    return abeagle.getExperimentVariant(experiment, abeagleOptions);
}

function trimExperimentKey(expTargetKey) {
    if (expTargetKey.length <= 40) {
        return expTargetKey;
    }
    // substr the last -<variant> to keep intact
    // and shorten the actual experiement name
    const variantIndex = expTargetKey.lastIndexOf('-');
    const variantStr = expTargetKey.substring(variantIndex);
    const lengthDiff = expTargetKey.length - 40;
    let shortenTargetKey = expTargetKey.substring(0, variantIndex - lengthDiff);
    // if the last character is a - or _, remove it
    shortenTargetKey = shortenTargetKey.replace(/(-|_){1}$/, '');
    return shortenTargetKey + variantStr;
}


const abtestsLazy = {
    get awarenessBillboard() {
        const expName = 'ADSGROUP-1015_awareness_billboard';
        return getExperimentVariant(expName).then((variant) => `${expName}-${variant}`);
    },

    get lazyLoadPrefetch() {
        const prefetchExpName = 'ADS-1141-prefetch3';
        // desktop
        if (solid.isAny(['md', 'lg'])) {
            return Promise.resolve(`${prefetchExpName}-desktop`);
        }
        // mweb targeting
        return getExperimentVariant('ADS-1141-prefetch3', {
            defaultVariantIfUnbucketed: 'nobucket',
            errorVariant: 'nobucket'
        }).then(variant => `${prefetchExpName}-${variant}`);
    },

    get displayCardInline() {
        const expName = 'ADS-1351_promo-inline-display-cards';
        return getExperimentVariant(expName)
            .then((variant) => `ADS-1351-inline-vid-native-${variant}`);
    },

    get civicScienceTest() {
        const expName = 'ADS-1367_civicscience';
        return getExperimentVariant(expName, {
            defaultVariantIfUnbucketed: 'nobucket',
            errorVariant: 'nobucket'
        }).then((variant) => `ADS-1367_civicscience-${variant}`);
    }

};

function getDFPKeyword() {
    const queryParams = queryStringToObject(window.location.search);
    return decodeURIComponent(queryParams[DFP_KEYWORD_PARAM] || '').split(',');
}

/**
 * Retreive new PD session ID value to be passed to ad request for optimizations and analysis
 * @returns promise with session id string or empty string when no consent is given
 */
function _getSessionId() {
    return Promise.all([gdpr.hasConsented(), getSessionId({
            env: bzfd.env
        })])
        .then(([adConsent, sessionId]) => {
            if (!adConsent) {
                return '000000-noconsent';
            }
            return sessionId || '';
        });
}

/**
 * Retrieve unhashed user id for DFP revenue analysis by user
 * @returns promise with user id string or empty string when no consent is given
 */
function _getUserId() {
    return Promise.all([gdpr.hasConsented(), getUserId({
            env: bzfd.env
        })])
        .then(([adConsent, userId]) => {
            if (!adConsent) {
                return '000000-noconsent';
            }
            return userId;
        });
}

function getCommonTargeting() {
    // the same as `Object.values`, but with IE support
    const abtests = values(abtestsLazy);
    return Promise.all(abtests)
        .then((vals) => {
            // make a flattened array and leave out `null`s
            let pageTargeting = {
                abtest: []
                    .concat(...vals)
                    .filter(v => v)
                    .map(trimExperimentKey)
            };
            if (ads.poe) {
                pageTargeting.poe = ads.poe;
            }
            const adopsTarget = getDFPKeyword();
            if (adopsTarget.length > 0) {
                pageTargeting[DFP_KEYWORD_PARAM] = adopsTarget;
            }
            return pageTargeting;
        })
        .then((pageTargeting) => {
            // pass page targeting and get userid and session id asynchronously
            return Promise.all([_getUserId(), _getSessionId()])
                .then(([userId, sessionId]) => {
                    if (userId) {
                        pageTargeting.cuid = userId.toString();
                    }
                    if (sessionId) {
                        pageTargeting.cvid = sessionId;
                    }
                    return pageTargeting;
                });
        });
}

/**
 * Defines page-level custom targeting parameters common to all xpagers.
 * @see https://developers.google.com/doubleclick-gpt/reference#googletag.PubAdsService_setTargeting
 */
export default {
    /**
     * @param {Object|Promise} [additionalTargeting] - object containing additional targeting params
     * (or a promise that resolves with such an object)
     * that will be merged with common targeting params
     * @returns {Object} - object whose keys will be treated as custom targeting keys (e.g. `abtest`)
     * and respective values as custom targeting parameters
     */
    getPageTargeting(additionalTargeting = {}) {
        return Promise.resolve(getCommonTargeting())
            .then(targeting => Promise.all([targeting, additionalTargeting]))
            .then(([targeting, additionalTargetingValue]) => {
                /* eslint-disable consistent-return */
                function mergeArrays(objValue, srcValue) {
                    if (isArray(objValue)) {
                        return objValue.concat(srcValue);
                    }
                }
                /* eslint-enable consistent-return */
                return mergeWith(targeting, additionalTargetingValue, mergeArrays);
            });
    },
    getDFPKeyword,
    trimExperimentKey
};