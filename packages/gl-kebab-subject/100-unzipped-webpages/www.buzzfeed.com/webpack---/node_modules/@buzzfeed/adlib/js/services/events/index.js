/**
 * Simple event manager
 * @class
 *
 * (Implemented as an old-style constructor function instead of a class
 * so it can be used as a mixin too)
 */
export function EventManager() {
    this._listening = {};
}

/**
 * Attaches the callback that will be invoked whenever the event is fired
 * with the arguments passed to `trigger`.
 * The callback will be invoked once per event even if it was added multiple times
 * @param {String} event - event name
 * @param {Function} callback - handler function
 */
EventManager.prototype.on = function(event, callback) {
    if (!(event in this._listening)) {
        this._listening[event] = new Set();
    }
    this._listening[event].add(callback);
};

/**
 * Attaches the callback that will be invoked when the event is fired and then removed
 * @param {String} event - event name
 * @param {Function} callback - handler function
 * @returns {Function} - wrapper that can be passed to `off` to detach the handler
 */
EventManager.prototype.once = function(event, callback) {
    const self = this;

    function once() {
        self.off(event, once);
        callback(...arguments);
    }
    this.on(event, once);
    return once;
};

/**
 * Removes a previously attached callback for the event
 * @param {String} event - event name
 * @param {Function} callback - handler function
 */
EventManager.prototype.off = function(event, callback) {
    if (!(event in this._listening)) {
        return;
    }

    this._listening[event].delete(callback);
    if (this._listening[event].size === 0) {
        delete this._listening[event];
    }
};

/**
 * Synchronously invokes callbacks for the given event.
 * The arguments will be passed along to the event callbacks
 * @param {String} event - event name
 * @param {...*} arg - arguments to be passed to the handlers
 */
EventManager.prototype.trigger = function(event, ...args) {
    if (!(event in this._listening)) {
        return;
    }

    this._listening[event].forEach((callback) => {
        try {
            callback(...args);
        } catch (error) {
            console.error(error);
        }
    });
};

EventManager.prototype.fire = EventManager.prototype.trigger;

/**
 * Removes all listeners
 */
EventManager.prototype.destroy = function() {
    delete this._listening;
};

/**
 * Extends the object with custom events functionality
 * @param {Object} target - object to extend
 */
EventManager.mixInto = function mixinEvents(target) {
    Object.assign(target, EventManager.prototype);
    EventManager.call(target);
};


/**
 * Singleton for ads-related events that don't need to be publically visible
 */
export const privateEvents = new EventManager();

/**
 * Singleton for public app events.
 * Needs a binding for the environment the ads run in (T3, React, etc.)
 * in order to recieve and emit public events
 */
export const publicEvents = new EventManager();