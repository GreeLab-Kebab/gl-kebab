import {
    merge,
    sample
} from 'lodash';
import bzfd from '@buzzfeed/buzzblocks/js/services/bzfd';
import {
    AdFormat
} from '../base/format';


class AdFormatBuzz extends AdFormat {
    /**
     * If the SCA response format changes, it should be enough to adjust this method
     * and not have to change templates
     */
    getBuzzData() {
        const buzz = this.ad.buzz;
        const advertiser = buzz.header.users
            .filter((user) => user.username === buzz.username)
            .map((user) => {
                return {
                    'displayName': user.display_name,
                    'url': `${bzfd.webRoot}/${user.username}`,
                    'avatar': user.user_image
                };
            })[0];

        let clickThroughUrl = this.ad.clickThroughUrl ? this.ad.clickThroughUrl : buzz.url;
        // use global `BF_DFP_REDIRECTS` temporaryly until we migrate DFP templates to use native templates for buzzes
        const dfpClickTracker = this.ad.dfpClickTracker || (window.BF_DFP_REDIRECTS || {})[this.config.wid];
        // prepend the tracker here so we don't have to do it in each template
        if (dfpClickTracker) {
            clickThroughUrl = `${dfpClickTracker}${encodeURIComponent(clickThroughUrl)}`;
        }

        const data = {
            'id': buzz.id,
            'title': buzz.name,
            'titleOriginal': buzz.name, // keep original title in case it gets overwritten with a flexpro variation title
            'description': buzz.ad_blurb,
            'url': clickThroughUrl,
            'category': buzz.category,
            'images': buzz.images, // standard, small, big, dblbig, wide, dblwide
            'promotionType': buzz.user_type.replace(/^f_/, ''), // f_ad, f_partner, f_sponsorship, f_other
            'advertiser': advertiser
        };
        const variation = this.pickVariation(buzz.active_experiment);
        merge(data, variation);
        return data;
    }

    /**
     * Randomly chooses a flexpro variation if available
     */
    pickVariation(experiment = {}) {
        const variations = (experiment || {}).variations || [];
        if (variations.length === 0) {
            return {};
        }
        const variation = sample(variations);
        const {
            id,
            title,
            thumbnail
        } = variation;
        let variationData = {};
        variationData.flexproVariation = id;

        if (title) {
            variationData.title = title;
        }

        if (thumbnail) {
            variationData.images = {
                'big': thumbnail.url,
                'dblbig': thumbnail.url,
                'wide': thumbnail.wide_url,
                'dblwide': thumbnail.wide_url
            };
        }

        return variationData;
    }

    getTemplateData() {
        const data = merge({}, this.ad);
        data.buzz = this.getBuzzData();
        data.slot = this.config;
        return data;
    }
}

AdFormatBuzz.formatType = 'buzz';


export {
    AdFormatBuzz
};