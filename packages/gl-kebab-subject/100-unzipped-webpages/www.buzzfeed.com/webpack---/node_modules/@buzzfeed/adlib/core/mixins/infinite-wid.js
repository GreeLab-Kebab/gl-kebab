import {
    forEach,
    partialRight
} from 'lodash';
import ads from '../ads';
import widRegistry from '../../js/services/wid-registry';


function updateConfig(config, widInitial, widUnique, targeting) {
    forEach(config, (value, key) => {
        if (key === 'wid' && String(value) === String(widInitial)) {
            config[key] = widUnique;
        } else if (typeof value === 'object' && value !== null) {
            updateConfig(value, widInitial, widUnique, targeting);
        }
        if (key === 'targeting') {
            Object.assign(value, targeting);
        }
    });
}

function updateId(el, widInitial, widUnique) {
    el.id = el.id.replace(widInitial, widUnique);
}

function updateClasses(el, classNames, widInitial, widUnique) {
    classNames.forEach((className) => {
        const hasClass = el.classList.contains(className);
        el.classList.remove(className);
        if (hasClass) {
            el.classList.add(className.replace(widInitial, widUnique));
        }
    });
}


function infiniteWid() {
    return {
        /**
         * Updates the wid so it's unique across all ad units on the page
         *
         * @param {Object} options
         * @param {Boolean} [options.sameIfFirst = false] - whether to keep wid unchanged in the case
         *   when it's not in `widRegistry` yet (i.e. not used by any other module on the page)
         *   defaults to false, can be overridden in derived classes
         *   (primary use-case is components that can receive userwidget ads).
         *   When using `sameIfFirst: true`, make sure the module element's id is *not* hardcoded in template
         *   because it will mess up T3's internal module setup
         *   (as it uses ids to keep track of module instances, behaviors, T3 and DOM events, etc.),
         *   which will prevent T3 from initializing "infinite" instances of the module
         * @param {String} [options.separator = '-'] - a symbol inserted between initial wid and unique suffix
         */
        makeInfiniteWid({
            sameIfFirst = false,
            separator = '-'
        } = {}) {
            if (!this.config.isInfinite || !this.isFirstInit()) {
                return;
            }
            const widInitial = this.config.wid;
            const unique = widRegistry.getUnique(widInitial, {
                startFrom: sameIfFirst ? 0 : 1
            });

            if (unique === 0) {
                return;
            }
            const widUnique = `${widInitial}${separator}${unique}`;

            const updateConfigBound = partialRight(
                updateConfig,
                // pass `infinite_index` targeting param to DFP
                widInitial, widUnique, {
                    'infinite_index': unique
                }
            );
            const updateIdBound = partialRight(
                updateId,
                widInitial, widUnique
            );
            const updateClassesBound = partialRight(
                updateClasses, [
                    `js-ad-${widInitial}`, `js-ad-format-${widInitial}`, `js-ad-slot-${widInitial}`,
                    `ad-wireframe-${widInitial}`, `ad-fade-${widInitial}` // userwidget classes
                ], widInitial, widUnique
            );

            updateConfigBound(this.config);

            // patch config JSON so that all behaviors and nested modules use the updated wid when they initialize
            this.element.querySelectorAll('script[type="text/x-config"]').forEach((configEl) => {
                const config = JSON.parse(configEl.textContent);
                updateConfigBound(config);
                configEl.textContent = JSON.stringify(config);
            });

            // can be this.element or a nested element
            const bfWidget = (
                /^BF_WIDGET_/.test(this.element.id) ? this.element : this.element.querySelector(`#BF_WIDGET_${widInitial}`)
            );
            if (bfWidget) {
                // safe update this.element's id as long as the instance is not initialized by T3 yet
                // (i.e. before `init` is called),
                // because T3 uses element ids to keep track of module instance's behaviors, events, etc.
                updateIdBound(bfWidget);
            }

            const slot = this.element.querySelector(`#${ads.getSlotContainerId(widInitial)}`);
            if (slot) {
                updateIdBound(slot);
            }

            // used by userwidget and programmatic ads
            const slotWrapper = this.element.querySelector(`#bf-item-${widInitial}-1`);
            if (slotWrapper) {
                updateIdBound(slotWrapper);
            }

            updateClassesBound(this.element);
            this.element.querySelectorAll('*').forEach((el) => updateClassesBound(el));
        }
    };
}


export {
    infiniteWid
};