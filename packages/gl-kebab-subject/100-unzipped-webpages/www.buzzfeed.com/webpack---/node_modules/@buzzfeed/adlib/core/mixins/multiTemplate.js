import prepareTemplate from '@buzzfeed/buzzblocks/js/services/nunjucks-env';


/**
 * Use this mixin when DFP can serve various kinds of native (and possibly userwidget) content/template in this slot.
 *
 * There should be at least one nested module (subclass of `AdFormat`) per each possible content variation.
 * A sub-module should specify what type of content it's suited for as `formatType` property.
 * The type must match `type` property defined in DFP template.
 * There are two ways to add a sub-module to a component:
 * - to include it in the component's template (the usual way for userwidget sub-modules)
 * - to use the `formats` module property.
 *   To do so, specify the content type as the object's key
 *   and the sub-module's template (or a list of templates) as the value.
 * When the content is loaded (i.e. when `ad-content-ready` event is recieved),
 * the mixin first inserts matching sub-module templates (if it finds any)
 * and then broadcasts a `ad-data-loaded` message along with the content data.
 * Every nested module listens to that event and either:
 * - destroys itself if the content's `type` differs from what it's suited for
 * - or proceeds with the data received
 *
 * This mixin depends on the `ad-content-notifier` behavior
 */
const multiTemplate = function(proto) {
    return {
        setup() {
            this.element.classList.add('ad-flexible');
            this.on(`ad-content-ready-${this.config.wid}`, this.handleAdContentLoaded);
            proto.setup.call(this);
        },

        /**
         * Gets called when ad data (native or userwidget) is loaded
         * Broadcasts `ad-data-loaded` message to nested modules
         */
        handleAdContentLoaded({
            data: ad
        }) {
            this.ad = ad;
            this.stopContentListening();
            let matchingTemplates = (this.formats || {})[ad.type] || [];
            // support for a single template or array of templates
            if (!Array.isArray(matchingTemplates)) {
                matchingTemplates = [matchingTemplates];
            }
            matchingTemplates.forEach((template) => {
                const format = prepareTemplate(template).render({
                    'slot': this.config,
                    ad
                });
                this.element.insertAdjacentHTML('beforeend', format);
            });
            this.context.application.startAll(this.element);
            this.context.application.broadcast(`ad-data-loaded-${this.config.wid}`, ad);
        },

        /**
         * Associates ad formats with component
         * Use in conjunction with `getFormatDefinition` of the formats you're adding
         * @param {...Object} format - ad format type and module template
         * @param {String} format.type - ad format type (`type` property defined in DFP template)
         * @param {String} format.template - compiled template that contains the format module element
         */
        attachFormats(...formats) {
            this.formats = this.formats || {};
            formats.forEach(({
                type,
                template
            }) => {
                if (!(type in this.formats)) {
                    this.formats[type] = [];
                }
                this.formats[type].push(template);
            });
        },

        stopContentListening() {
            this.off(`ad-content-ready-${this.config.wid}`, this.handleAdContentLoaded);
        },

        destroy() {
            this.stopContentListening();
            proto.destroy.call(this);
        },
    };
};


export {
    multiTemplate
};