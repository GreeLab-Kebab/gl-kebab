import {
    getUserId,
    loadScript
} from '@buzzfeed/bf-utils';
import {
    encode as hashidsEncode
} from '@buzzfeed/bf-utils/lib/hashing';
import {
    queryStringToObject,
    urlQueryToObject
} from '@buzzfeed/bf-utils/lib/query-string';
import abeagle from '@buzzfeed/buzzblocks/js/services/abeagle';
import localization from '@buzzfeed/buzzblocks/js/services/localization';
import speedtrack from '@buzzfeed/buzzblocks/js/services/performance';
import permutive from '@buzzfeed/buzzblocks/js/services/permutive';
import solid from '@buzzfeed/buzzblocks/js/services/solid/standalone';
import webview from '@buzzfeed/buzzblocks/js/services/webview';
import backfillAdvertisers from '../js/config/backfill-advertisers';
import bzfd from '../js/services/bzfd';
import {
    EventManager,
    publicEvents
} from '../js/services/events';
import pageTargeting from '../js/services/page-targeting';
import {
    PrebidInitializer
} from '../js/services/prebid';
import prebidUnit from '../js/services/prebid-ad-unit';
import {
    AmazonInitializer
} from '../js/services/amazon';
import gdpr from '../js/services/gdpr';
import {
    notifyDataDog,
    notifyError
} from '../js/services/datadog'; // @todo Remove the circular reference
import {
    thumbnailReady
} from '../js/services/thumbnail-ready';
import sizeUtils from '../js/services/size';
import adLightning from '../js/services/ad-lightning';
import bounceX from '../js/services/bouncex';
import adRizer from '../js/services/ad-rizer';
import moat from '../js/services/moat';
import {
    getReferrer
} from '../js/services/referrer';
import scrollSubscription from '../js/services/scroll-subscription';
import AdError from './error';
import adomik from '../js/services/adomik';
import arbvark from '../js/services/arbvark';

import {
    DFP_NETWORK,
    ZONE1_BFO,
    ZONE1_BFNEWS
} from './constants';

/* for backward compatibility
@todo ADS-1188 - Remove when all xpagers import the bindings on their own */
import '../bindings/t3';

/**
 * Service with some general widely used functions
 * @module
 */

/**
 * Ad slot configuration
 * @typedef {Object} AdSlotParameters
 * @property {Number} wid - widget id (examples: 13, 42)
 * @property {String} adPos - ad position (examples: 'bigstory', 'awareness')
 * @property {String} adType - ad type (examples: 'promotion', 'awareness')
 * @property {Number[]|'fluid'} [size='fluid'] - slot size (width and height, or 'fluid')
 * @property {Object} [targeting={}] - slot targeting options
 */

/**
 * @typedef {Object} GPTSlotRenderEndedEv
 * @see https://developers.google.com/doubleclick-gpt/reference#googletageventsslotrenderendedevent
 */

/**
 * @typedef {Object} GPTSlotOnloadEv
 * @see https://developers.google.com/doubleclick-gpt/reference#googletag.events.SlotOnloadEvent
 */


// namespace for easier testing
const util = {
    loadScript,
    queryStringToObject
};


const GPTSrc = 'https://securepubads.g.doubleclick.net/tag/js/gpt.js';


const _customTargeting = {
    'getPageTargeting': () => null,
    'getSlotTargeting': () => null
};


function _getSlotContainerId(wid) {
    return `div-gpt-ad-${wid}`;
}

function _getSlotContainer(wid) {
    return document.getElementById(_getSlotContainerId(wid));
}


/**
 * type {Promise} - resolved when GPT, Prebid (Libs are both) script is loaded, rejected when it failed to load
 */
let _initializing;


/**
 * type {Promise} - resolved when check for ad blockers is finished
 */
var _checkingAdBlock;

const _eventManager = new EventManager();

let _slots = {};

/**
 * Store slot status information
 * displayed: Promise that googletag.display() has been called
 * prepared: Promise that slot has been "prepared" (defined, displayed, and refreshed)
 */
let _slotStatus = {};

/**
 * Will be overridden if the feature flag is on
 * @todo Remove when the feature flag is switched on
 */
let _useNewAdCallStructure = false;

/**
 * Executes the associated handler functions (assigned earlier with `addSlotRenderEndedHandler`)
 * when `slotRenderEnded` GPT event is fired for particular slot
 * @param {GPTSlotRenderEndedEv} event - GPT event object
 */
function _onSlotRenderEnded(event) {
    /* this is for backward compatibility with T3 event manager
    @todo ADS-1188 - Remove when xpager components' calls are updated */
    event.data = event;

    // wrap the handler into try/catch and log exceptions because GPT intercepts all exceptions
    // and only shows them in Publisher console, but not in browser console,
    // which can give you a hard time debugging
    try {
        const wid = String(event.slot.getTargeting('wid'));
        const slot = _getSlotContainer(wid);
        if (!slot || !wid) {
            window.raven && window.raven.captureMessage('onSlotRenderEnded error', {
                tags: {
                    gptEvent: event
                }
            });
            return;
        }
        _eventManager.trigger(`slotRenderEnded-${wid}`, event);
    } catch (err) {
        console.error(err);
        throw err;
    }
}

/**
 * Executes the associated handler functions (assigned earlier with `addSlotOnloadHandler`)
 * when `slotOnload` GPT event is fired for particular slot
 * @param {GPTSlotRenderEndedEv} event - GPT event object
 */
function _onSlotLoad(event) {
    /* this is for backward compatibility with T3 event manager
    @todo ADS-1188 - Remove when xpager components' calls are updated */
    event.data = event;

    // wrap the handler into try/catch and log exceptions because GPT intercepts all exceptions
    // and only shows them in Publisher console, but not in browser console,
    // which can give you a hard time debugging
    try {
        const wid = String(event.slot.getTargeting('wid'));
        const slot = _getSlotContainer(wid);
        if (!slot || !wid) {
            window.raven && window.raven.captureMessage('onSlotLoad error', {
                tags: {
                    gptEvent: event
                }
            });
            return;
        }
        _eventManager.trigger(`slotOnload-${wid}`, event);
    } catch (err) {
        console.error(err);
        throw err;
    }
}


function _initGPT() {
    const performanceMetric = 'ads.GPT';
    speedtrack.eventStart(performanceMetric);
    return util.loadScript(GPTSrc).then(
        () => {
            speedtrack.eventEnd(performanceMetric);
            return _configureGPT();
        },

        () => {
            speedtrack.eventEnd(performanceMetric);
            console.error('GPT failed to initialize');
            return Promise.reject(new AdError('GPT failed to initialize'));
        }
    );
}

/**
 * Always set PPID unless consent has been explicitly denied.
 * PPID will be ignored by dfp if ad personalization is deactivated.
 * https://support.google.com/dfp_premium/answer/2880055?hl=en
 * @returns promise with alpha-numeric PPID string or empty string when no consent is given
 */
function _getPPID() {
    return Promise.all([gdpr.hasConsented(), getUserId({
            env: BZFD.Config.env
        })])
        .then(([adConsent, userId]) => {
            if (!adConsent) {
                return '';
            }
            return hashidsEncode(userId);
        });
}

/**
 * console.logs google consent settings if ads-debug is right query param
 * @returns {String} - ads-debug query param value
 */
function debugConsent() {
    const debugSetting = urlQueryToObject(window.location.search)['ads-debug'];
    if (/googleconsent/.test(debugSetting) && arguments.length > 0) {
        console.log('>> [google consent]', ...arguments);
    }
    return debugSetting;
}
/**
 * quick function to set NonPersonalized ads
 * setting = 0 -> re-activates ad personalization
 * setting = 1 -> deactivates ad personalization
 * @param {*} setting
 */
function _setNonPersonalization(setting) {
    const googletag = window.googletag;
    debugConsent(
        'non-personalization =',
        setting ? 'YES' : 'NO (personalized ads)'
    );
    googletag.cmd.push(() => {
        googletag.pubads().setRequestNonPersonalizedAds(setting);
    });
}
/**
 * Check for changes with consent and update preference with dfp
 * @returns promise
 */
function _checkConsent() {
    const debugSetting = debugConsent();
    // For debugging and forcing a setting
    // ads-debug=googleconsent -> shows the setting from GDPR CMP
    // ads-debug=googleconsent-on -> forces personalization
    // ads-debug=googleconsent-off -> forces non-personalized

    if (/googleconsent(-on|-off)/.test(debugSetting)) {
        if (/-on/.test(debugSetting)) {
            _setNonPersonalization(0);
        } else {
            _setNonPersonalization(1);
        }
        return Promise.resolve(true);
    }

    return gdpr.hasConsentedGoogle()
        .then((googleConsent) => {
            // adConsent will be true if no consent required
            let setting = googleConsent ? 0 : 1;
            _setNonPersonalization(setting);
        })
        .catch(() => _setNonPersonalization(1));
}

/**
 * Initializes `googletag` global reference and applies GPT configuration
 */
function _configureGPT() {
    window.googletag = window.googletag || {};
    window.googletag.cmd = window.googletag.cmd || [];
    const googletag = window.googletag;

    return Promise.all([
            pageTargeting.getPageTargeting(_customTargeting.getPageTargeting()),
            _getLazyLoadSettings(),
            _getPPID(),
            permutive.checkIsOn(),
        ])
        .then(([pgTargeting = {}, lazyLoadSettings, ppid, permutiveOn]) => {
            googletag.cmd.push(() => {
                Object.keys(pgTargeting || {}).forEach((param) => {
                    const value = pgTargeting[param];
                    // force all values to be < 40 if a string
                    const targetingValues = [].concat(value).map((v) => {
                        if (typeof v === 'string') {
                            return v.substring(0, 40);
                        }
                        return v;
                    });
                    googletag.pubads().setTargeting(param, targetingValues);
                });

                // disableInitialLoad allows correct targeting from header bids
                // ^ also necessary for GDPR checking
                googletag.pubads().disableInitialLoad();
                googletag.pubads().enableAsyncRendering();
                if (!lazyLoadSettings || lazyLoadSettings.withSRA) {
                    googletag.pubads().enableSingleRequest();
                }
                googletag.pubads().addEventListener('slotRenderEnded', _onSlotRenderEnded);
                googletag.pubads().addEventListener('slotOnload', _onSlotLoad);
                if (lazyLoadSettings) {
                    delete lazyLoadSettings.withSRA;
                    googletag.pubads().enableLazyLoad(lazyLoadSettings);
                }
                if (ppid) {
                    googletag.pubads().setPublisherProvidedId(ppid);
                }
                if (permutiveOn && googletag.pubads().getTargeting('permutive').length === 0) {
                    const kvs = localStorage.getItem('_pdfps');
                    googletag.pubads().setTargeting('permutive', kvs ? JSON.parse(kvs) : []);
                }
                googletag.enableServices();
            });
        });
}

/**
 * Inspects URL query parameters and
 * returns a modifier that needs to be applied to ad slot path (if any)
 * @returns {String} - modifier to ad slot path (empty string if none)
 */
function _getAdTestSite() {
    let testParams = {
        'adtest': 'test',
        'giraffe_test': 'giraffe_test',
        'adops_giraffe': 'adops_giraffe',
        'ads_qa': 'ads_qa'
    };
    let queryParams = queryStringToObject(window.location.search);
    for (let test in testParams) {
        if (test in queryParams) {
            return testParams[test];
        }
    }
    return '';
}

/*
 * ADS-1141 - new experiement split, only for mweb
 * if desktop => fetch 1000, render 200 (default; experiment not eligible)
 * if mweb && exp OFF => null (off = not eligible/not bucketed)
 * if mweb && exp ON CONTROl => null (same as off)
 * if mweb && exp ON EARLY => fetch 200, render 100
 * if mweb && exp ON LATE => fetch 100, render 50
 */
function _getLazyLoadSettings() {
    // desktop
    if (solid.isAny(['md', 'lg'])) {
        return Promise.resolve({
            fetchMarginPercent: 1000,
            renderMarginPercent: 200,
            withSRA: true
        });
    }
    return abeagle.getExperimentVariant('ADS-1141-prefetch3', {
            rejectErrors: false,
            defaultVariantIfUnbucketed: 'control',
            errorVariant: 'control'
        })
        .then(variant => {
            // control & unbucketed have the same settings (no change)
            // but we differentiate them in page-targeting to keep track in GAM
            if (variant === 'control') {
                return null;
            }
            const isEarly = variant === 'early';
            return {
                fetchMarginPercent: isEarly ? 200 : 100,
                renderMarginPercent: isEarly ? 100 : 50,
                withSRA: true
            };
        });
}


const _isUnitTest = () => typeof window.describe === 'function' && typeof window.expect === 'function';
const _isAdsServiceTest = () => (window.BZFD || {}).isAdsServiceTest;

const ads = {
    AdError: AdError,
    // TODO: update xpagers to use /services/thumbnail-ready, instead of linking to this version
    thumbnailReady: thumbnailReady,

    /**
     * Getter for point of entry used in ad targeting
     * @returns {String} point of entry, or null
     */
    get poe() {
        if (webview.isMobileApp()) {
            return webview.isIOS() ? 'bfapp_ios.fallback' : 'bfapp_android.fallback';
        }
        if (webview.isNewsApp() || webview.isNews2App()) {
            return webview.isIOS() ? 'newsapp_ios.fallback' : 'newsapp_android.fallback';
        }
        return null;
    },

    /**
     * @param {Function} options.customTargetingPage - function that returns
     * object with page-level DFP targeting options (either a promise or a value)
     * @param {Function} options.customTargetingSlot - function that
     * accepts {AdSlotParameters} and
     * returns object with slot-level DFP targeting options (either a promise or a value)
     */
    configure({
        customTargetingPage,
        customTargetingSlot
    }) {
        if (typeof customTargetingPage === 'function') {
            _customTargeting.getPageTargeting = customTargetingPage;
        }
        if (typeof customTargetingSlot === 'function') {
            _customTargeting.getSlotTargeting = customTargetingSlot;
        }
    },

    /**
     * Loads GPT script if need be
     * @returns {Promise} - resolved when GPT script is loaded or failed to load
     */
    init() {
        if (_initializing) {
            return _initializing;
        }

        let test = _getAdTestSite();
        // show the specific ADOPS_TARGET value
        // if w/ adops_giraffe for example, "adops_giraffe + <keyword>"
        test += (test ? ' + ' : '') + pageTargeting.getDFPKeyword();
        if (test) {
            document.body.insertAdjacentHTML('beforeend', `
        <div class="ad-test-label fill-yellow-lighter xs-text-5 bold xs-p1 xs-ml1 xs-t0 xs-z4 xs-fixed">
          ${test}
        </div>
      `);
        }

        const flag143 = abeagle.isOn('ADSGROUP-143_new_ad_calls_structure')
            .then((isOn) => _useNewAdCallStructure = isOn);

        function safeInitDependency(name, dep) {
            const performanceMetric = `ads.${name}`;
            speedtrack.eventStart(performanceMetric);
            return dep.init().then(
                (result) => {
                    speedtrack.eventEnd(performanceMetric);
                    return result;
                },
                (error) => {
                    speedtrack.eventEnd(performanceMetric);
                    notifyError(name, error);
                    return null;
                }
            );
        }

        _initializing = scrollSubscription.check()
            .then(isSubscribed => {
                if (isSubscribed) {
                    // The user has opted out of ads using Scroll
                    // so we load Scroll's JS and then abort the ad load process
                    scrollSubscription.addClassName();
                    safeInitDependency('scroll', scrollSubscription);
                    throw new AdError('Opted out of ads via scroll.com');
                }
            })
            .then(flag143)
            /*
             * ADS-1120 - ad rizer put before GPT for now because we
             * are just trying them out. Need to revist based on partnership
             * This does not block! If it errors out, we continue regardless.
             */
            .then(() => safeInitDependency('ad_rizer', adRizer))
            /** GPT is a critical dependency */
            .then(_initGPT)
            .then(gpt => {
                /**
                 * Dependencies that *should* block ad calls until loaded go here.
                 * We should load as many of them as possible,
                 * a failure in any of them should not interrupt others AND core ads functionality
                 * (which GPT is sufficient for)
                 */
                const blockingDeps = Promise.all([
                    safeInitDependency(
                        'prebid',
                        new PrebidInitializer(bzfd, prebidUnit)
                    ),
                    safeInitDependency('amazon', new AmazonInitializer(bzfd)),
                    safeInitDependency('ad_lightning', adLightning),
                    safeInitDependency('moat', moat)
                ]);

                /**
                 * Dependencies that *should not* block ad calls go here
                 */
                safeInitDependency('arbvark', arbvark);
                safeInitDependency('bounce_x', bounceX);
                safeInitDependency('scroll', scrollSubscription);
                return blockingDeps.then(([prebid, amazon]) => ({
                    gpt,
                    prebidServices: [prebid, amazon]
                }));
            });

        return _initializing;
    },

    /**
     * Loads everything needed for ads early.
     * Call on application init if you want the libs to load even earlier than the first ad unit would load them
     * @returns {Promise}
     */
    start() {
        return this.init()
            .catch((reason) => {
                if (!(reason instanceof AdError)) {
                    notifyError('init', reason);
                    return Promise.reject(reason);
                }
                return Promise.resolve();
            });
    },

    /**
     * Makes GPT create slot
     * The primary facility consumer modules are going to need.
     * @param {AdSlotParameters} options - ad slot configuration
     * @returns {Promise} - resolved when ad slot is created and widget is rendered;
     * rejected with `AdError` instance if any of chained inner functions rejects (see their doc for details)
     *
     * When handling promise rejection in `catch`, always check whether its reason is an instance of `AdError`,
     * otherwise real errors may be suppressed!
     */
    prepareSlot(options) {
        const {
            wid
        } = options;
        this.createAdSlotContainer(wid);
        let slotId = this.getSlotContainerId(wid);
        if (!_slotStatus[slotId] || !_slotStatus[slotId]['prepared']) {
            _slotStatus[slotId] = {};
            _slotStatus[slotId]['prepared'] = this.init().then(({
                prebidServices
            }) => {
                return Promise.resolve(_customTargeting.getSlotTargeting(options))
                    .then((slotTargeting) => this.defineSlot(options, slotTargeting))
                    .then(() => this.requestHeaderBid(prebidServices, options))
                    .then(_checkConsent);
            });
        }
        return _slotStatus[slotId]['prepared'];
    },

    /**
     * Render ad unit.
     * @param {AdSlotParameters} options - ad slot configuration
     * @returns {Promise} - resolved when ad slot is created and widget is rendered;
     */
    renderWidget(options) {
        // force unit tests to fail if they don't mock this function properly
        if (_isUnitTest() && !_isAdsServiceTest()) {
            throw new Error(
                'Unit tests should not make real ad calls! ' +
                'You should mock `render` method of your ad component or `ads.renderWidget` function'
            );
        }
        return this.prepareSlot(options)
            .then(() => this.display(options));
    },

    /**
     * This logic is highly complicated, please add test cases when you make changes!
     *
     * Builds ad slot path
     * @param {AdSlotParameters} options - ad slot configuration
     * @returns {String} - ad slot path
     */
    buildAdCall(options) {
        let {
            adPos,
            adType,
            zone1
        } = options;
        let dfpNetwork = `/${DFP_NETWORK}/`;

        if (zone1) {
            dfpNetwork += zone1;
        } else {
            dfpNetwork += ZONE1_BFO;
        }

        let lang = localization.getRawPageLanguage();
        if (lang === 'es') {
            let edition = localization.getEdition();
            if (edition === 'es-es') {
                lang = 'sp';
            } else if (edition === 'es-mx') {
                lang = 'mx';
            }
        }

        let page = ads.getAdCallCategory(options);
        let platform = ads.getAdCallPlatform(options);
        let test = _getAdTestSite();

        let type = '';
        if (options.advertiserContext && _useNewAdCallStructure) {
            type = 'partner';
        } else if (/^awareness/.test(adPos) || /^awareness/.test(adType)) {
            type = 'awareness';
        } else if (/^infinite_post/.test(adPos)) {
            type = 'recirc';
            options.advertiserContext = false;
        } else if (
            adType === 'ex' &&
            zone1 !== ZONE1_BFNEWS &&
            page !== 'giftguide'
        ) {
            // for Ad Exchange on BFO
            type = 'ex';
        }

        if (options.advertiserContext && !_useNewAdCallStructure) { // ad post
            type = 'partnerpost';
            if (webview.isMobileApp()) {
                platform = 'mobile';
            }
            if (lang === 'ja') {
                type = `ja.${type}`;
            }
        }

        let path = [test, type, platform].filter((item) => item).join('.'); // `filter` will omit all empty values

        if (options.advertiserContext && !_useNewAdCallStructure) {
            return `${dfpNetwork}.${path}/${page}`;
        }

        return `${dfpNetwork}.${path}/${lang}/${page}/${adPos}`;
    },

    /**
     * Get platform for use in constructing ad call
     * @param {String} options - ad slot configuration
     * @returns {String}
     */
    getAdCallPlatform(options) {
        let platform = solid.isAny(['xs', 'sm']) ? 'mobileweb' : 'desktop';
        if (webview.isMobileApp()) {
            platform = 'bfapp_ios';
            if (webview.isAndroid()) {
                platform = 'bfapp_android';
            }
        }
        if (options.adPos === 'thumb-header') {
            platform = 'desktop';
        }
        if (options.advertiserContext && platform === 'desktop' && !_useNewAdCallStructure) {
            platform = '';
        }
        return platform;
    },

    /**
     * Get category / vertical for use in constructing ad call
     * @param {AdSlotParameters} options - ad slot configuration
     * @returns {String}
     */
    getAdCallCategory(options) {
        let {
            adPos,
            zone1
        } = options;
        let page = (bzfd.pageSection || bzfd.pageCategory || bzfd.pageName || 'home').toLowerCase();

        // Advertiser pages
        if (options.advertiserContext) {
            if (_useNewAdCallStructure) {
                page = 'partner';
            } else {
                page = 'advertiser';
                if (/^(bigstory|subbuzz|quiz)/.test(adPos)) {
                    page = `${page}/${adPos}`;
                }
            }
            // BFN's `sections` work like bpager/feedpager
            // This should catch non-BFN migrated news pages (e.g., non-en editions
        } else if (/news/.test(page) && zone1 !== ZONE1_BFNEWS) {
            page = 'news';
            // As-is
        } else if ((/(As\/?Is)/i).test(bzfd.pageSection)) {
            page = 'asis';
            // Pages with filters
        } else if (bzfd.pageFilter) {
            // feeds where filters can be switched, e.g. shopping, quizzes, life
            if (Object.keys(bzfd.pageFilters || {}).length > 0) {
                page = `${page}-${bzfd.pageFilter}`;
                // feeds that technically use filters, but they can't be switched, e.g. verticals, etc.
            } else if (!/^(archive|badge)$/.test(page)) { // filters on /archive are not very useful (e.g. 2018 or 2018/01)
                page = bzfd.pageFilter;
            }
            // BFN feedpager verticals
        } else if (/section/.test(page)) {
            page = bzfd.pageSection;
            // Search page
        } else if (/\/search$/.test(window.location.pathname)) {
            page = 'search';
        }

        // Omit any problem characters and hyphenate
        page = page.replace(/&/g, '').replace(/\s+/g, '-');

        return page;
    },

    /**
     * Makes GPT create ad slot. Checks whether the slot has been created earlier (in the page <head>)
     * @param {AdSlotParameters} options - ad slot configuration
     * @param {Object} [slotTargeting={}] - additional slot targeting
     * @returns {Promise} - resolved when the slot is created by GPT
     */
    defineSlot(options, slotTargeting = {}) {
        let {
            wid,
            size = 'fluid',
            targeting = {}
        } = options;
        const googletag = window.googletag;
        Object.assign(targeting, slotTargeting);
        const poe = ads.poe || getReferrer();
        const page = ads.getAdCallCategory(options);
        return this.init()
            .then(() => {
                return new Promise((resolve) => {
                    googletag.cmd.push(() => {
                        let slot = googletag.defineSlot(
                            ads.buildAdCall(options),
                            size,
                            _getSlotContainerId(wid)
                        );
                        Object.keys(targeting).forEach((key) => {
                            slot.setTargeting(key, [].concat(targeting[key]));
                        });

                        let pageSections = bzfd.allPageSections.map(section => section.toLowerCase().replace(/\/+/g, ''));
                        if (pageSections.length) {
                            slot.setTargeting('section', pageSections);
                        }

                        let slugifiedCMSTags = ads.getSlugifiedCMSTags();
                        if (slugifiedCMSTags.length) {
                            slot.setTargeting('cms_tag', slugifiedCMSTags);
                        }

                        if (poe) {
                            slot.setTargeting('poe', poe);
                        }

                        if (page) {
                            slot.setTargeting('zone3', page);
                        }

                        adomik.init()
                            .then((isActive) => {
                                if (isActive) {
                                    slot.setTargeting('ad_group', adomik.randomAdGroup()).setTargeting('ad_h', (new Date()).getUTCHours());
                                }
                            });

                        slot.setTargeting('destination', ads.getDestinationTargets());
                        slot.addService(googletag.pubads());
                        _slots[wid] = slot;
                        resolve(slot);
                    });
                });
            });
    },

    getDestinationTargets() {
        let targets = [bzfd.destination]; // always target destination
        if (bzfd.isAsIs) { // as/is destination
            if (bzfd.pageFilter === null) {
                targets.push('asishomepage');
            } else if (!bzfd.isBPage && bzfd.pageFilter) { // ex: bf.com/asis/style
                targets.push(`${bzfd.pageFilter}feed`);
            }
        } else if (bzfd.isHomePage) { // destination hps
            targets.push(`${bzfd.destination}homepage`);
        } else if (bzfd.isFeedpager || bzfd.isFeed) { // feeds/verticals
            let page = (bzfd.pageName || bzfd.pageSection || bzfd.pageCategory);
            const isSection = /section/.test(page);
            const isTag = /tag/.test(page);
            const isVertical = /vertical/.test(page);
            const isBadge = /badge/.test(page);

            if (isSection) {
                page = bzfd.pageSection;
            } else if (isTag || isVertical || isBadge) {
                page = bzfd.pageFilter;
                if (isBadge) {
                    targets.push('badgefeed');
                }
            }
            if (page === 'buzz') { // becomes "buzzfeed" -_-;
                page = 'buzztag';
            }
            if (page) {
                targets.push(`${page.toLowerCase()}feed`);
            }
        }
        return targets;
    },

    /**
     * Displays ad slot.
     * @see https://developers.google.com/doubleclick-gpt/reference#googletag.display
     If eligible for header bidding, defer displaying until prebid callback
     * @param {Object} options
     */
    display(options) {
        const {
            wid
        } = options;
        let slotId = this.getSlotContainerId(wid);
        if (!_slotStatus[slotId]['displayed']) {
            _slotStatus[slotId]['displayed'] = this.init()
                .then(() => {
                    const googletag = window.googletag;
                    googletag.cmd.push(() => {
                        googletag.display(_getSlotContainerId(wid));
                        googletag.pubads().refresh([_slots[wid]], {
                            changeCorrelator: false
                        });
                    });
                });
        }
        return _slotStatus[slotId]['displayed'];
    },

    /**
     * forces GPT to reload the ad slot when this is called
     * @param  {Object} - the slot config
     * @return {void}
     */
    forceRefresh(options) {
        const {
            wid
        } = options;
        let slotId = this.getSlotContainerId(wid);
        if (!_slotStatus[slotId]['displayed']) {
            this.display(options);
        } else {
            window.googletag.pubads().refresh([_slots[wid]], {
                changeCorrelator: false
            });
        }
    },

    /**
     * Force trigger of slotRenderEnded event for ads rendered without DFP.
     * @param {Number} wid - widget id
     * @param {Object} data - ad event
     */
    triggerSlotRenderEnded(wid, data) {
        _eventManager.trigger(`slotRenderEnded-${wid}`, data);
    },

    /**
     * Creates an element that GPT uses to render the slot; simply exits if the element already exists.
     * Adds `ad-slot-invisible` class to created element to prevent it from taking any space (useful for native ads);
     * remove it programmaticaly or pre-create the `div-gpt-ad-` element in template if it's not what you need
     * @param {Number} wid - widget id
     */
    createAdSlotContainer(wid) {
        let id = _getSlotContainerId(wid);
        document.querySelectorAll(`.js-ad-${wid}`).forEach((adElement) => {
            // if the container already exists, do nothing
            if (!adElement || adElement.querySelector(`#${id}`)) {
                return;
            }
            // create ad slot container
            const slotMarkup = `
        <div id="${id}" class="js-ad-slot js-ad-slot-${wid} ad-slot ad-slot-invisible"></div>
      `;
            const configScript = adElement.querySelector('script:first-child');
            if (configScript) {
                configScript.insertAdjacentHTML('afterend', slotMarkup);
            } else {
                adElement.insertAdjacentHTML('afterbegin', slotMarkup);
            }
        });
    },

    /**
     * Applies collapsing animation to unit container
     * @param {Number} wid - widget id
     */
    collapse(wid) {
        /* @todo ADS-1188 - Use `privateEvents` when components are updated */
        publicEvents.trigger(`ad-wireframe-collapse-start-${wid}`);
    },

    /**
     * Adds handler for `slotRenderEnded` GPT event
     * @param {Number} wid - widget id
     * @param {Function} handler - callback to execute when event is fired;
     * a {GPTSlotRenderEndedEv} object is passed to callback function
     */
    addSlotRenderEndedHandler(wid, handler) {
        _eventManager.on(`slotRenderEnded-${wid}`, handler);
    },

    /**
     * Detaches handler for `slotRenderEnded` GPT event
     * @param {Number} wid - widget id
     * @param {Function} handler - handler previously assigned with `addSlotRenderEndedHandler`
     */
    removeSlotRenderEndedHandler(wid, handler) {
        _eventManager.off(`slotRenderEnded-${wid}`, handler);
    },

    /**
     * Adds handler for `slotOnload` GPT event
     * @param {Number} wid - widget id
     * @param {Function} handler - callback to execute when event is fired;
     * a {GPTSlotOnloadEv} object is passed to callback function
     */
    addSlotOnloadHandler(wid, handler) {
        _eventManager.on(`slotOnload-${wid}`, handler);
    },

    /**
     * Detaches handler for `slotOnload` GPT event
     * @param {Number} wid - widget id
     * @param {Function} handler - handler previously assigned with `addSlotOnloadHandler`
     */
    removeSlotOnloadHandler(wid, handler) {
        _eventManager.off(`slotOnload-${wid}`, handler);
    },

    /**
     * helper function for updating the correlator
     * TODO: maybe should be an event for future use?
     */
    updateCorrelator() {
        window.googletag = window.googletag || {};
        const googletag = window.googletag;

        try {
            if (googletag.pubadsReady) {
                googletag.pubads().updateCorrelator();
            }
        } catch (err) {
            window.raven && window.raven.captureMessage('updateCorrelator error', {
                tags: {
                    pubadsReady: googletag.pubadsReady || false,
                    catchErr: err
                }
            });
        }
    },

    /**
     * Checks whether the slot is empty
     * Returns `true` for unfilled slots
     * @param {GPTSlotRenderEndedEv} gptEv
     * @returns {Boolean}
     */
    isEmpty(gptEv) {
        const {
            size,
            isEmpty
        } = gptEv;
        // unfilled slots do not report size
        return isEmpty || size === null || size === undefined;
    },

    /**
     * Checks whether the slot is backfilled or filled with a real ad
     * Returns `false` for unfilled slots
     * @param {GPTSlotRenderEndedEv} gptEv
     * @returns {Boolean}
     */
    isBackfillSlot(gptEv) {
        if (ads.isEmpty(gptEv)) {
            return false;
        }
        const {
            advertiserId
        } = gptEv;
        if (!advertiserId || gptEv.isBackfill) {
            return true;
        }
        return backfillAdvertisers.indexOf(String(advertiserId)) > -1;
    },

    /**
     * Checks whether the slot is filled with programmatic (Ad Exchange) ad or creative
     * Slots whose size matches pre-defined programmatic sizes, including prebid 1x1 size
     * (see `BZFD.Config.ads.programmaticSizes`), are considered programmatic;
     * slots with sizes bigger than 15x15 are considered programmatic too;
     * Unfilled slots are considered non-programmatic
     * @todo: We should have a list of advertiser ids associated with programmatic orders to lookup
     * @param {GPTSlotRenderEndedEv} gptEv
     * @param {Array} [requestedSize=[]] - array of sizes passed to ad call
     * @returns {Boolean}
     */
    isProgrammaticSlot(gptEv, requestedSize = []) {
        if (ads.isEmpty(gptEv)) {
            return false;
        }
        const {
            size
        } = gptEv;
        const [width, height] = size;

        // 1x1 can represent either a research pixel or prebid creative,
        // need to figure out which case it is
        if (sizeUtils.isEqual(size, bzfd.adSizes.RESEARCH_PIXEL) && sizeUtils.contains(requestedSize, size)) {
            return false;
        }
        // (assumption) prebid units send through ads as 1x1 first - SITE-5441 patch
        if (width === 1 && height === 1) {
            return true;
        }

        // sometimes slots' rendered sizes differ from the sizes requested
        // (e.g. requested 300x250 size may render as 375x250)
        return sizeUtils.isProgrammatic(size, {
            strict: false
        });
    },

    /**
     * Checks whether the slot iframe has actual content or just transfers data
     * by analyzing the size of the served creative.
     * Assumes creatives whose sizes match programmatic sizes, including 1x1 prebid size
     * (see `BZFD.Config.ads.programmaticSizes`),
     * and fluid native videos (0x0 size) have content to display,
     * other creatives simply transfer data to components
     * @param {GPTSlotRenderEndedEv} gptEv
     * @param {Array} [requestedSize=[]] - array of sizes passed to ad call
     * @returns {Boolean}
     */
    isIframeContent(gptEv, requestedSize = []) {
        if (ads.isEmpty(gptEv)) {
            return false;
        }
        const {
            size
        } = gptEv;
        const [width, height] = size;

        // 0x0 size is a special case that seems to indicate fluid native video creatives (although it's not documented)
        if (width === 0 && height === 0) {
            return true;
        }

        if (ads.isProgrammaticSlot(gptEv, requestedSize)) {
            return true;
        }

        return false;
    },
    /**
     * returns the rendered ad's size
     * @param {GPTSlotRenderEndedEv} gptEv
     * @param {Object} options - any other items needed to id ad
     * @returns {width, height}
     */
    getRenderedAdSize(gptEv, options) {
        if (ads.isEmpty(gptEv)) {
            return {};
        }
        const {
            size
        } = gptEv;
        let [width, height] = size || [1, 1]; // for undefined
        if (width === 1 && width === height) {
            const {
                wid
            } = options;
            const adSlotContainer = document.getElementById(_getSlotContainerId(wid));
            const adIframe = adSlotContainer.querySelector('iframe');
            width = adIframe.offsetWidth;
            height = adIframe.offsetHeight;
        }
        return {
            width,
            height
        };
    },
    /**
     * Detects adblock software
     * @returns {Promise} - resolved with boolean representing whether or not adblock is being used
     */
    detectAdBlock() {
        if (scrollSubscription.isEnabled) {
            return Promise.resolve(true);
        }

        if (_checkingAdBlock) {
            return _checkingAdBlock;
        }
        _checkingAdBlock = util.loadScript('//www.buzzfeed.com/static/js/advertiser/ads.js')
            // AdBlock is DISABLED if we CAN download ads.js file
            .then(() => Promise.resolve(false))
            // AdBlock is ENABLED if we CAN'T download ads.js file
            .catch(() => Promise.resolve(true));
        return _checkingAdBlock;
    },

    /**
     * Sends metric to Google Analytics / Pixiedust via bfa
     * @param {String} eventName - name of the metric (example: 'click')
     * @param {Object} eventData - event info formatted for gaMapping / pixiedustMapping
     * @returns {void}
     */
    notifyBFA(eventName, eventData) {
        if (!window.bfa || !eventName || !eventData || typeof eventData !== 'object' || !eventData.l) {
            return;
        }
        let eventUrl;
        if (eventName === 'click') {
            eventUrl = `track/click/${eventData.l}`;
        } else if (eventName === 'scroll') {
            eventUrl = 'track/scroll/impression';
        } else {
            return;
        }
        window.bfa(eventUrl, eventData);
    },

    /**
     * coordinate prebid & amazon requests + targeting
     * @param {Array<BidRequester>} bidRequesters
     * @param {AdSlotParameters} options - ad slot configuration
     * @param  {Promise<Void>}
     */
    requestHeaderBid(bidRequesters, options) {
        let requests = bidRequesters
            .filter((requester) => requester)
            .map((requester) => requester.requestBid(ads, options));
        return Promise.all(requests).then((targeters) => {
            targeters.forEach((targeter) => {
                if (targeter) {
                    targeter.setTargeting();
                }
            });
        });
    },

    getSlotContainer(wid) {
        return _getSlotContainer(wid);
    },

    getSlotContainerId(wid) {
        return _getSlotContainerId(wid);
    },

    /**
     * @returns {Array} - CMS tags, lowercased and with whitespace replaced with underscores
     */
    getSlugifiedCMSTags() {
        // TODO: is there a standard 'slugify' function we should be using here?
        return bzfd.cmsTags.map(tag =>
            tag.toLowerCase().replace(/\s+/g, '_'));
    },
};

export default ads;


(() => {
    // prevent unit tests from making network requests
    // (cannot be achieved with a mock because this runs earlier than mocks are applied)
    if (_isUnitTest()) {
        return;
    }

    // if scroll enabled, don't bother detecting ad block
    if (scrollSubscription.isEnabled) {
        notifyDataDog('blocked-scroll');
        return;
    }

    ads.detectAdBlock().then((isBlocked) => {
        if (isBlocked) {
            // A classname unrelated to blocking.
            document.body.classList.add('has-lego');
        }
        notifyDataDog(isBlocked ? 'blocked' : 'allowed');
    });
})();


/**
 * Called in SCA JSONP response (when a call to userwidget script is redirected there)
 * in order to pass data to ad units
 * and let them render branded post templates with the data received
 * @todo SITE-5837 - Remove the callback
 */
window.BZFD.Config.ads.handleBrandedBuzzData = (wid, {
    buzzes
}) => {
    const buzz = buzzes[0].buzz;
    const data = {
        type: 'buzz',
        wid,
        buzzId: buzz.id,
        buzz
    };

    window.postMessage({
        'action': 'loaded',
        'source': 'dfpNativeTemplate',
        'data': data
    }, '*');
};