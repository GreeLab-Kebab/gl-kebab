"use strict";

/**
 * Implements pixels scroll binder. Handles the position of the scroll by amount of pixels that were passed.
 * Results are represented as percentage of passed pixels to height of the page between top of the page and
 * defined with config bottom bound. Calculated as ratio: passed pixels / height * 100. This mode is usually
 * used for pages without AJAX loaders.
 * @param {object} options Object with all the configuration parameters such as mode, bounds, etc.
 * @param {string} executable Function that should be invoked with position calculation results
 * if scroll event triggered. Results of calculation represented as BFEventInfo class.
 * @constructor
 */
function PixelsScrollBinder(options, executable) {
    this.options = options || {};
    this.executable = executable;
    this.points = [];

    /**
     * Initialization method. Executes preparation of checkpoints.
     * @returns {Function} Returns handler.
     */
    this.init = function() {
        this.fillCheckPoints();
    };

    /**
     * Handler for the 'onscroll' event. Tracks the position of scroll on the page according to the
     * checkpoints and sends data to the BFA. Results are represented as BFEventInfo.
     * @returns {Function} Returns handler.
     */
    this.track = function() {
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        var clientHeight = document.documentElement.clientHeight + 1; // 1px added to handle 100% scroll on iphone
        var clientTop = document.documentElement.clientTop || document.body.clientTop || 0;
        var currentScroll = scrollTop + clientHeight;
        var currentPercentage = 0;

        var i;
        var anchor;
        for (i = 0; i < this.options.bottomBounds.length; i++) {
            anchor = document.querySelector(this.options.bottomBounds[i]);
            if (anchor) {
                break;
            }
        }
        if (anchor) {
            var anchorPosition = anchor.getBoundingClientRect().top + scrollTop - clientTop;
            if (currentScroll >= anchorPosition && currentPercentage < 100) {
                currentPercentage = 100;
            }
            if (currentScroll <= anchorPosition) {
                currentPercentage = currentScroll / anchorPosition * 100;
            }
        }

        for (i = 0; i < this.options.checkpoints.length; i++) {
            if (this.points[i].percentage <= currentPercentage && !this.points[i].passed) {
                this.points[i].passed = true;
                var trackingInfo = ["track/scroll/post", {
                    t: "scroll",
                    n: "post",
                    d: this.points[i].percentage.toString(),
                }, ];
                if (this.executable && window[this.executable] instanceof Function) {
                    window[this.executable].apply(this, trackingInfo);
                }
            }
        }
    };

    /**
     * Fills the checkpoints for current module and mark them as not passed.
     * @returns {Function} Returns handler.
     */
    this.fillCheckPoints = function() {
        for (var i = 0; i < this.options.checkpoints.length; i++) {
            this.points.push({
                percentage: this.options.checkpoints[i],
                passed: false,
            });
        }
    };
}

export default PixelsScrollBinder;