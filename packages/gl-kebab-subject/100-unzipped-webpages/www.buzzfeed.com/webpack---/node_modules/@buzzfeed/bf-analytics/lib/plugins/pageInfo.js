import Signal from "signals";
import {
    defaultsDeep,
    isPlainObject,
    merge,
    cloneDeep,
    set,
} from "lodash";
import utils from "../common/bfa_utils";

/**
 * Page Info plugin
 * @module  plugins/pageInfo
 * @exports pageInfo
 */

"use strict";

/**
 * @classdesc
 * Plugin which works with a `page` data and handles routes connected to it (update, set).
 * Supported routes:
 * "general/page/set" (page info object as dataObj),
 * "general/page/update" (page info object as dataObj),
 * "general/page/ready" (page info object as dataObj).
 * Extends Core with:
 * _getPageInfo method - returns copy of actual page info,
 * _onPageReady method - subscribes specified callback on page info ready event.
 * Extends Sandbox with:
 * getPageInfo method - returns copy of actual page info,
 * onPageChanged method - subscribes specified callback on page info changed event,
 * onPageReady method - subscribes specified callback on page info ready event.
 * @memberof module:plugins/pageInfo
 * @param {BFACore} core - bfa core instance
 * @param {object} settings - settings that will be merged with default page info on init step
 * @returns {{modifySBInstance: modifySBInstance}} - object with modifySBInstance method
 * @constructor
 */
function PageInfoPlugin(core, settings) {
    settings = settings || {};
    this.defaultSettings = {
        readyOnFirstUpdate: true,
        isReady: false,
        pageInfo: {
            uri: _getURIData(),
        },
    };
    _cleanUrl();
    this.pageReady = new Signal();
    this.pageChanged = new Signal();
    this.settings = defaultsDeep(settings, this.defaultSettings);
    var _this = this;
    core._router.sub("general/page/{action}", function(dataObj, routeVars) {
        if (routeVars.action === "ready") {
            if (!this.isReady) {
                this.isReady = true;
                this.pageReady.dispatch();
            }
            return;
        }
        if (!isPlainObject(dataObj)) {
            core.log.warn("page info must be a plain object");
            return;
        }

        switch (routeVars.action) {
            case "set":
                this.settings.pageInfo = merge({
                    uri: _getURIData(),
                }, dataObj);
                break;
            case "update":
            default:
                this.settings.pageInfo = merge(this.settings.pageInfo, dataObj);
                break;
        }
        this.pageChanged.dispatch();
        if (!this.settings.isReady && this.settings.readyOnFirstUpdate) {
            this.settings.isReady = true;
            this.pageReady.dispatch();
        }
    }, this, {
        action: ["ready", "update", "set", ],
    });

    /**
     * Parse current URL and return object with its parts
     * @return {Object} - object with URL parts mostly taken from `document.location`
     * @private
     */
    function _getURIData() {
        return {
            href: document.location.href.replace(/\/p\/\.[0-9a-zA-Z]+\//, "/"),
            host: document.location.host,
            path: document.location.pathname.replace(/^\/p\/\.[0-9a-zA-Z]+\//, "/"),
            search: document.location.search,
            hash: document.location.hash,
            protocol: document.location.protocol,
        };
    }

    /**
     * Removes `bfseed` param from query string
     * @returns {void}
     * @private
     */
    function _cleanUrl() {
        if (!window.history || !window.history.replaceState || !document.location.search) {
            return;
        }
        const toBeRemoved = ["bfseed", ];
        const qsValues = utils.queryStringToObject(document.location.search);
        const newQs = Object.keys(qsValues)
            .filter(key => {
                if (toBeRemoved.indexOf(key) === -1) {
                    return true;
                }
                set(window, `BZFD.Context.page.${key}`, qsValues[key]);
                return false;
            })
            .map(key => typeof qsValues[key] === "undefined" ?
                encodeURIComponent(key) :
                `${encodeURIComponent(key)}=${encodeURIComponent(qsValues[key])}`
            )
            .join("&");

        try {
            window.history.replaceState(null, null, `?${newQs}${document.location.hash}`);
        } catch (err) {
            if (window.raven) {
                window.raven.captureException(err);
            }
        }
    }

    function _onPageReady(cb, context) {
        if (_this.settings.isReady === true) {
            cb.call(context);
        }
        _this.pageReady.add(cb, context);
    };

    function _getPageInfo() {
        return cloneDeep(_this.settings.pageInfo);
    };
    core._onPageReady = function(cb, context) {
        _onPageReady(cb, context);
    };
    core._getPageInfo = function() {
        return _getPageInfo();
    };
    return {
        modifySBInstance: function(sandboxInstance) {
            sandboxInstance.getPageInfo = function() {
                return _getPageInfo();
            };
            sandboxInstance.onPageReady = function(cb, context) {
                _onPageReady(cb, context);
            };
            sandboxInstance.onPageChanged = function(cb, context, once) {
                _this.pageChanged[once ? "addOnce" : "add"](cb, context);
            };
        },
    };
}
PageInfoPlugin.defaultId = "pageInfo";
export default PageInfoPlugin;