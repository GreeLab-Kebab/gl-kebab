import EventInfo from "../common/bfa_eventinfo.js";
import {
    defaults,
    isUndefined,
    has,
    isString,
} from "lodash";

/**
 * Debug tracker plugin
 * @module  plugins/debugTracker
 * @requires plugins/generalSettings
 * @requires plugins/logger
 * @exports debugTracker
 */

"use strict";
var debugTrackerAppenderTypes = {
    logger: "loggerAppender",
    sessionStorage: "sessionStorageAppender",
};
/**
 * @classdesc
 * DebugTracker plugin. Serialize and store data objects (for example mapped in modules) to session storage and
 * log them to console for testing/debugging. Depends on BFA mode.
 * Extends SandBox with:
 * debugTracker instance with trackEvent method
 * Extends BFA Core with:
 * createDebugTracker method - returns debugTracker for instanceId that has to be specified as first argument
 * @memberof module:plugins/debugTracker
 * @param {BFACore} core - instance of bfa core
 * @param {Object} settings - plugin settings
 * @returns {{modifySBInstance: modifySBInstance}} - plugin public instance
 * @constructor
 */
function DebugTrackerPlugin(core, settings) {
    settings = settings || {};
    this.defaultSettings = {
        storageKeyName: "bfa_debugStore",
        appendersConfig: {},
    };
    this.defaultSettings.appendersConfig[core.defs.bfaMode.develop] = [debugTrackerAppenderTypes.logger, ];
    this.defaultSettings.appendersConfig[core.defs.bfaMode.test] = [debugTrackerAppenderTypes.sessionStorage,
        debugTrackerAppenderTypes.logger,
    ];
    this.settings = defaults(settings, this.defaultSettings);
    this._bfaMode = core._generalSettings.mode;

    function generalSettingsChangeHandler() {
        this._bfaMode = core._generalSettings.mode;
    }
    core._onGeneralSettingsChange.add(generalSettingsChangeHandler, this);
    var _this = this;
    this[debugTrackerAppenderTypes.sessionStorage] = {
        trackEvent: function(unitId, eventInfo, dataObject) {
            var bfaStoreSerialized = sessionStorage.getItem(_this.settings.storageKeyName);
            var bfaStoreObject;
            if (bfaStoreSerialized === null) {
                bfaStoreObject = {
                    pageHref: document.location.href,
                };
            } else {
                bfaStoreObject = JSON.parse(bfaStoreSerialized);
            }
            if (isUndefined(bfaStoreObject[unitId])) {
                bfaStoreObject[unitId] = [];
            }
            /* eslint-disable */
            bfaStoreObject[unitId].push({
                "eventType": eventInfo.t,
                "eventName": eventInfo.n,
                "eventLocation": eventInfo.l,
                "eventDescription": eventInfo.d,
                "dataObject": dataObject,
            });
            /*eslint-enable */
            sessionStorage.setItem(_this.settings.storageKeyName, JSON.stringify(bfaStoreObject));
        },
    };

    this[debugTrackerAppenderTypes.logger] = {
        trackEvent: function(unitId, eventInfo, dataObject) {
            this.logger.event(unitId, eventInfo, dataObject);
        },
    };
    this[debugTrackerAppenderTypes.logger].logger = core.createLogger("DebugTracker_" +
        debugTrackerAppenderTypes.logger);
    /***
     * Method for tracking event data from specified module to corresponded appenders
     * @param {BFEventInfo} eventInfo -  event info object
     * @param {Object} dataObject - object with data that have to be sent from module (mapped/completed data)
     * @return {*} - void
     */
    function trackEvent(eventInfo, dataObject) {
        if (eventInfo instanceof EventInfo && dataObject) {
            if (!has(_this.settings.appendersConfig, _this._bfaMode)) {
                return;
            }
            var appenders = _this.settings.appendersConfig[_this._bfaMode];
            for (var i = 0; i < appenders.length; i++) {
                if (!has(_this, appenders[i])) {
                    continue;
                }
                _this[appenders[i]].trackEvent(this.instanceId, eventInfo, dataObject);
            }
        } else {
            core.log.warn("DebugTracker: can't store event data for " + this.instanceId + ": not valid arguments")
        }
    }

    /**
     * Creates debugTracker instance for specified instanceId
     * @param {string} instanceId - id of instance that is using debugTracker
     * @returns {{instanceId: *, trackEvent: trackEvent}} - object that provides access to debugTracker functionality
     * @private
     */
    function createDebugTracker(instanceId) {
        if (!isString(instanceId) || instanceId === "") {
            throw new Error("Error occurred on _createDebugTracker call: instanceId arg has to be not empty string");
        }
        return {
            instanceId: instanceId,
            trackEvent: trackEvent,
        };
    };
    core.createDebugTracker = createDebugTracker;
    return {
        modifySBInstance: function(sandboxInstance) {
            sandboxInstance.debugTracker = createDebugTracker(sandboxInstance.instanceId);
        },
    };
}

/**
 * defaultId property required for initialization
 * @type {string}
 */
DebugTrackerPlugin.defaultId = "debugTracker";
DebugTrackerPlugin.require = ["generalSettings", "logger", ];
DebugTrackerPlugin.debugTrackerAppenderTypes = debugTrackerAppenderTypes;

export default DebugTrackerPlugin;