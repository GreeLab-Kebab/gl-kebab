import crossroads from "crossroads";
import {
    isString,
    slice,
    startsWith,
    cloneDeep,
    isEmpty,
    isFunction,
    isObject,
    has,
} from "lodash";

"use strict";

/**
 * BFARouter class. Currently wraps `crossroads` router.
 * @constructor
 */
function BFARouter() {
    // main router initializing
    this._router = crossroads.create();
    this._routes = {};

    // default router"s settings
    this._router.normalizeFn = crossroads.NORM_AS_OBJECT;
    this._router.ignoreState = true;
    // greedy = true - means that all suitable routs will be called not only first one (by default)
    this._router.greedy = true;
    this._routes = [];
}

/**
 * Publishes arguments to route (route value must be passed as the first argument)
 * @param {string} route - route value (for example "/track/page/view")
 * @returns {BFARouter} - this
 */
BFARouter.prototype.pub = function(route) {
    if (isString(route)) {
        var args = slice(arguments, 1);
        var data;
        // tricky solution, as we support only one `default argument` that connected with crossroads solution
        // so if someone send more than two args (route, and dataObj) we combine them to array
        // if someone send only one route we are sending empty object
        if (args.length === 1) {
            data = args[0];
        } else if (args.length > 1) {
            data = args;
        }
        this._router.parse(route, [data, ]);
    }
    return this;
};

/**
 * Some hacky method/solution (we must clone event info objects before sending them to subscribers)
 * @param {string} route - route pattern
 * @param {function} cb - callback function
 * @param {*} context - context
 * @return {function} - modified callback
 */
BFARouter.prototype.modifySubCB = function(route, cb, context) {
    if (startsWith(route, "track/")) {
        return function() {
            cb.apply(context, cloneDeep(Array.prototype.slice.call(arguments)));
        };
    }
    return cb;
};

/**
 * Subscribes on route
 * @param {string} route - route value
 * @param {function} cb - callback
 * @param {*} context - context in which callback must be ran
 * @param {object} rules - additional rules
 * @param {boolean} once - subscribes only once true/false
 * @returns {BFARouter} - this
 */
BFARouter.prototype.sub = function(route, cb, context, rules, once) {
    if (!isString(route) || isEmpty(route)) {
        this.log.error("`route` must be not empty string");
        return this;
    }
    if (!isFunction(cb)) {
        this.log.error("`cb` must be a function");
        return this;
    }
    if (rules && !isObject(rules)) {
        this.log.error("`rules` must be an object or not specified");
        return this;
    }
    // has to be discussed
    var modCb = this.modifySubCB(route, cb, context);
    var subTypeName = once ? "addOnce" : "add";
    if (!has(this._routes, route) && !rules) {
        this._routes[route] = this._router.addRoute(route);
        this._routes[route].matched[subTypeName](modCb, context);
    } else {
        if (rules) {
            var tmpRoute = this._router.addRoute(route);
            tmpRoute.rules = rules;
            tmpRoute.matched[subTypeName](modCb, context);
        } else {
            this._routes[route].matched[subTypeName](modCb, context);
        }
    }
    return this;
};

/**
 * logger mock
 * @type {{error: BFARouter.log.error, log: BFARouter.log.log, info: BFARouter.log.info,
 * warn: BFARouter.log.warn, enabled: BFARouter.log.enabled}}
 */
BFARouter.prototype.log = {
    error: function() {},
    log: function() {},
    info: function() {},
    warn: function() {},
    enabled: function() {},
};

export default BFARouter;