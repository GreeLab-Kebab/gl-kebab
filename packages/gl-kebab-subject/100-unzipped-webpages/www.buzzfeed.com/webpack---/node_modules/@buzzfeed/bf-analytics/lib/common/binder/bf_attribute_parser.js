"use strict";
/**
 * Represents attribute parser for BFAnalytics data binder
 * @param {object} config Configuration data for "data-bfa" attribute parser
 * @constructor
 */
function BFAttributeParser(config) {
    this.defaultConfig = {
        start: "@",
        end: ";",
        separator: ":",
        objectPropertySeparator: ",",
        objectStart: "{",
        objectEnd: "}",
        arrayStart: "[",
        arrayEnd: "]",
        parts: {
            action: "a",
            description: "d",
            location: "l",
            data: "e",
            options: "o",
        },
    };

    this.config = config || this.defaultConfig;

    /**
     * Function that begins the cain of parsing process.
     * @param {HtmlElement} element Element which attribute should be parsed.
     * @returns {*} Returns array with "action", "location", "description", "data"
     */
    this.parse = function(element) {
        var result = {};
        var attribute = element.getAttribute("data-bfa");
        if (attribute === null || attribute === "") {
            result = {
                action: "",
                location: "",
                description: "",
                data: {},
                options: {},
            };
        } else {
            result = this.processAttribute(attribute);
        }
        if (result.location === "") {
            result.location = this.findLocation(element.parentElement);
        }

        result.action = this.grabDataSource(result.action);
        result.location = this.grabDataSource(result.location);
        result.description = this.grabDataSource(result.description);
        return result;
    };

    /**
     * Parse text value of "data-bfa" attribute.
     * @param {string} attribute Attribute"s value that should be parsed.
     * @returns {{action: string, location: string, description: string, data: string}} Returns "action", "location",
     * "description", "data" values in one object
     */
    this.processAttribute = function(attribute) {
        var collector = [];
        for (var part in this.config.parts) {
            if (this.config.parts.hasOwnProperty(part)) {
                var idx = attribute.indexOf(this.config.start + this.config.parts[part] + this.config.separator);
                if (idx > -1) {
                    collector.push({
                        part: part,
                        idx: idx,
                    });
                }
            }
        }

        collector = collector.sort(function(a, b) {
            return a.idx < b.idx ? -1 : a.idx === b.idx ? 0 : 1;
        });

        var result = {
            action: "",
            location: "",
            description: "",
            data: "",
            options: "",
        };
        for (var i = 0; i < collector.length; i++) {
            if (i < collector.length - 1) {
                result[collector[i].part] = attribute.substring(collector[i].idx, collector[i + 1].idx);
            } else {
                result[collector[i].part] = attribute.substring(collector[i].idx);
            }
        }

        for (var key in result) {
            if (result.hasOwnProperty(key)) {
                result[key] = result[key]
                    .replace(this.config.start + this.config.parts[key] + this.config.separator, "")
                    .trim();
                if (result[key][result[key].length - 1] === this.config.end) {
                    result[key] = result[key].substring(0, result[key].length - 1);
                }
            }
        }

        result.data = this.convertToObject(result.data);
        result.options = this.convertToObject(result.options);
        return result;
    };

    /**
     * Function that searches the element which contains location value.
     * @param {HtmlElement} element Element from which search would be started to the top of DOM tree.
     * @returns {string} Returns location value.
     */
    this.findLocation = function(element) {
        while (element !== null && element.getAttribute) {
            var attr = element.getAttribute("data-bfa");
            if (attr !== null && attr !== "") {
                var result = this.processAttribute(attr);
                if (result.location === "") {
                    element = element.parentElement;
                    continue;
                }
                return result.location;
            } else {
                element = element.parentElement;
            }
        }
        return "";
    };

    this.objectParseMode = {
        propertyName: 1,
        propertyValue: 2,
        propertyArray: 4,
    };

    /**
     * Converts "data" part value to object
     * @param {string} value Text value of "data" part of "data-bfa" attribute
     * @returns {{}} Returns value as an object
     */
    this.convertToObject = function(value) {
        var resultedObj = {};
        value = value.trim().replace("\"", "").replace("'", "");

        if (typeof value !== "string" ||
            value.indexOf(this.defaultConfig.objectStart) !== 0 ||
            value.indexOf(this.defaultConfig.objectEnd) !== value.length - 1) {
            return resultedObj;
        }
        var currentPropertyName = "";
        var currentPropertyValue = "";
        var currentArrayValue = "";
        var parseMode = this.objectParseMode.propertyName;
        for (var i = 1; i < value.length - 1; i++) {
            // if separator and mode is property name parsing we should recheck wich kind of prop value are next array or
            // usual value
            if (value[i] === this.defaultConfig.separator &&
                parseMode === this.objectParseMode.propertyName) {
                if (value[i + 1] && value[i + 1] === this.defaultConfig.arrayStart) {
                    parseMode = this.objectParseMode.propertyArray;
                    i++;
                } else {
                    parseMode = this.objectParseMode.propertyValue;
                }
                continue;
            }

            switch (parseMode) {
                // Array parsing
                case this.objectParseMode.propertyArray:
                    if (!currentPropertyValue) {
                        currentPropertyValue = [];
                    }
                    // if array end element we should add array to property and reset all vars
                    if (value[i] === this.defaultConfig.arrayEnd) {
                        currentPropertyValue.push(currentArrayValue.trim());
                        resultedObj[currentPropertyName.trim()] = currentPropertyValue;
                        currentPropertyName = "";
                        currentArrayValue = "";
                        currentPropertyValue = "";
                        parseMode = this.objectParseMode.propertyName;
                        break;
                    }
                    // if separator we should add value to array and reset array value
                    if (value[i] === this.defaultConfig.objectPropertySeparator) {
                        currentPropertyValue.push(currentArrayValue);
                        currentArrayValue = "";
                        break;
                    }
                    currentArrayValue += value[i];
                    break;
                    // property value parsing
                case this.objectParseMode.propertyValue:
                    //if separator or last char before obj close symbol we should save value and reset vars
                    if (value[i] === this.defaultConfig.objectPropertySeparator || i === value.length - 2) {
                        resultedObj[currentPropertyName.trim()] = (currentPropertyValue +
                            (value[i] !== this.defaultConfig.objectPropertySeparator ? value[i] : "")).trim();
                        currentPropertyName = "";
                        currentPropertyValue = "";
                        parseMode = this.objectParseMode.propertyName;
                    } else {
                        currentPropertyValue += value[i];
                    }
                    break;
                    // property name parsing
                case this.objectParseMode.propertyName:
                    if (value[i] !== this.defaultConfig.objectPropertySeparator) {
                        currentPropertyName += value[i];
                    }
                    break;
            }
        }
        return resultedObj;
    };

    /**
     * Function related for invocation of data-source functions.
     * @param {string} value Value of the data-bfa attribute"s part.
     * @returns {string} Result of data-source invokation. If data-source is unavailable than returns plain
     * provided value in argument.
     */
    this.grabDataSource = function(value) {
        if (value.indexOf("source:") > -1) {
            var funcFullName = value.replace("source:", "").trim();
            if (funcFullName && window) {
                var context = window;
                var namespaces = funcFullName.split(".");
                var funcName = namespaces.pop();

                for (var i = 0; i < namespaces.length; i++) {
                    context = context[namespaces[i]];
                }
                var func = context[funcName];
                if (func) {
                    return func();
                }
            }
        }
        return value;
    };
}

/**
 * Attribute parser module of Buzzfeed analytics event binder.
 */
export default BFAttributeParser;