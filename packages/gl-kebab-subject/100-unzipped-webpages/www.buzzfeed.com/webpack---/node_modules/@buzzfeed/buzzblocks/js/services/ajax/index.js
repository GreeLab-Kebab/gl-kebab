/**
 * Bare minimum fetch polyfill in 500 bytes.
 * @see https://github.com/developit/unfetch
 */
import fetch from 'unfetch';
import {
    instrument
} from '../metrics';
/**
 * A simple JSONP implementation
 * @see https://github.com/webmodules/jsonp
 */
import jsonp from 'jsonp';

/**
 * Converts object to query string params.
 * @param {Object} obj - target object.
 * @return {string} - query string.
 */
function toQueryString(obj) {
    const res = [];
    for (const key in obj) {
        if (!obj.hasOwnProperty(key)) {
            continue;
        }
        const value = obj[key];
        if (value !== null && value !== '' && typeof value !== 'undefined') {
            res.push(key + '=' + value);
        }
    }
    return res.join('&');
}

/**
 * Creates a promise, which is rejected after a specified timeout.
 * @param {Number} timeout - number of milliseconds to wait until promise is rejected.
 */
function rejectOnTimeout(timeout) {
    return new Promise((_, reject) => {
        setTimeout(() => reject({
            type: 'timeout',
            msg: `${timeout}ms timeout exceeded`
        }), timeout);
    });
}

function errorHandler({
    url
}) {
    return err => {
        instrument('xhr', err.type || 'error', {
            url,
            status: err.status || 0
        });
        return Promise.reject(err);
    };
}

/**
 * Promisifies the jsonp implementation
 * @param {String} requestUrl - the request url to be passed to jsonp.
 * @return {Promise} - a promise resolved with the response.
 */
function fetchWithJsonp(requestUrl) {
    return new Promise((resolve, reject) => {
        jsonp(requestUrl, (err, response) => {
            if (err) {
                return reject(err);
            }
            return resolve(response);
        });
    });
}

/**
 * Checks response status code.
 * Resolves when status code is within 200-300 range.
 * Rejects otherwise.
 * @param {Response} response - response object.
 */
function status(response) {
    if (response.ok) {
        return Promise.resolve(response);
    } else {
        return Promise.reject({
            type: 'error',
            status: response.status,
            statusText: response.statusText
        });
    }
}

/**
 * Converts response to JSON.
 * @param {Response} response - response object.
 */
function toJson(response) {
    return response.json();
}

/**
 * Converts response to plain text.
 * @param {Response} response - response object.
 */
function toText(response) {
    return response.text();
}

/**
 * Add a param to `url` to have it bypass Basic auth requirements on stage.
 * @param {String} url
 */
function authBypassWrapper(url) {
    if (BZFD.Config.env !== 'dev') {
        return url;
    }

    const hash = 'eca385331012a621bc93fcda0a953a97';
    const char = url.indexOf('?') > -1 ? '&' : '?';

    return url + char + hash;
}

export default {
    /**
     * Performs a GET request to a specified endpoint.
     * @param {String} url - resource URL.
     * @param {Object} options - request options.
     * @param {Object} [options.data={}] - request parameters, are being included in the URL.
     * @param {String} [options.type=json] - expected response type.
     * @param {Object} [options.params={}] - additional fetch parameters.
     * @param {Boolean} [options.skipAuth=false] - flag to add basic auth bypass token to the resource URL.
     * @param {Number} [options.timeout] - maximum time in milliseconds for a request to complete.
     * @return {Promise} - a promise resolved with the response body.
     */
    get(url, {
        type = 'json',
        data = {},
        params = {},
        skipAuth,
        timeout
    } = {}) {
        if (!url) {
            return Promise.reject('URL parameter is required');
        }

        let result;
        const options = Object.assign({
            credentials: 'same-origin'
        }, params);

        let requestUrl = url;

        const queryString = toQueryString(data);
        if (queryString) {
            requestUrl += (requestUrl.indexOf('?') > -1 ? '&' : '?') + queryString;
        }

        if (skipAuth) {
            requestUrl = authBypassWrapper(requestUrl);
        }

        switch (type) {
            case 'json':
                result = fetch(requestUrl, options).then(status).then(toJson);
                break;
            case 'text':
                result = fetch(requestUrl, options).then(status).then(toText);
                break;
            case 'jsonp':
                result = fetchWithJsonp(requestUrl);
                break;
            default:
                result = Promise.reject(`Unsupported type ${type}`);
        }

        return (timeout ? Promise.race([rejectOnTimeout(timeout), result]) : result)
            .catch(errorHandler({
                url
            }));
    },

    /**
     * Performs a POST request to a specified endpoint.
     * @param {String} url - resource URL.
     * @param {Object} options - request options.
     * @param {Object} options.data - request parameters, are being included in the request body.
     * @param {String} [options.type=json] - expected response type.
     * @param {String} [options.params={}] - additional fetch parameters.
     * @param {Boolean} [options.skipAuth=false] - flag to add basic auth bypass token to the resource URL.
     * @param {Boolean} [options.raw=false] - flag to disable converting request parameters to query string key value pairs.
     * @param {Number} [options.timeout] - maximum time in milliseconds for a request to complete.
     * @return {Promise} - a promise resolved with the response body.
     */
    post(url, {
        data,
        type = 'json',
        params = {},
        skipAuth = false,
        raw = false,
        timeout
    } = {}) {

        if (!url) {
            return Promise.reject('URL parameter is required');
        }

        if (!data) {
            return Promise.reject('Can not send POST request without data');
        }

        if (skipAuth) {
            url = authBypassWrapper(url);
        }

        let result;
        const options = Object.assign({
            headers: {
                'Content-type': 'application/x-www-form-urlencoded'
            },
            credentials: 'same-origin'
        }, params);

        options.method = 'POST';
        options.body = raw ? data : toQueryString(data);

        switch (type) {
            case 'json':
                result = fetch(url, options).then(status).then(toJson);
                break;
            case 'text':
                result = fetch(url, options).then(status).then(toText);
                break;
            default:
                result = Promise.reject(`Unsupported type ${type}`);
        }

        return (timeout ? Promise.race([rejectOnTimeout(timeout), result]) : result)
            .catch(errorHandler({
                url
            }));
    }
};