import client from '../client';
/**
 * Finds the closest parent that matches a selector.
 * @see https://github.com/ForbesLindesay/closest
 */
import closest from 'closest';

/**
 * Polyfills the `classList` functionality in IE
 */
function _patchClassList() {
    // polyfill the whole `classList` on SVG elements
    (function() {
        if (document.createElementNS('http://www.w3.org/2000/svg', 'g').classList instanceof DOMTokenList) {
            return;
        }
        try {
            Object.defineProperty(
                SVGElement.prototype,
                'classList',
                Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList') ||
                Object.getOwnPropertyDescriptor(Element.prototype, 'classList')
            );
        } catch (exc) {}
    })();

    // polyfill multiple arguments to `add` and `remove`
    (function() {
        try {
            const test = document.createElement('div');
            test.classList.add('foo', 'bar');
            if (test.classList.contains('bar')) {
                return;
            }
            const add = DOMTokenList.prototype.add;
            const remove = DOMTokenList.prototype.remove;
            DOMTokenList.prototype.add = function(...tokens) {
                tokens.forEach((token) => add.call(this, token));
            };
            DOMTokenList.prototype.remove = function(...tokens) {
                tokens.forEach((token) => remove.call(this, token));
            };
        } catch (exc) {}
    })();
}
_patchClassList();


function _patchNodeList() {
    if (!NodeList.prototype.forEach) {
        NodeList.prototype.forEach = Array.prototype.forEach;
    }
}
_patchNodeList();


export {
    closest
};

/**
 * Subscribes to `transitionend` event, returns a promise that is resolved when
 * animations on all requested properties have finished.
 * Note that the event will not fire (and so the promise will not resolve)
 * if the final property value is the same as initial
 * or if the transition is aborted before it's completed:
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions#Detecting_the_start_and_completion_of_a_transition
 * @param {Element} element - element to be animated
 * @param [options.properties=[]] - array of CSS properties being animated
 * @return {Promise} - promise that is resolved with `TransitionEvent` when animation completes;
 * the promise has additional method `unsubscribe` to remove the event listener
 */
export function detectTransitionEnd(element, {
    properties = ['any']
} = {}) {
    const transitionendEvents = ['transitionend', 'webkitTransitionEnd', 'mozTransitionEnd', 'oTransitionEnd'];
    const resolvers = {};
    const transitions = [];
    properties.forEach((prop) => {
        let resolve;
        const promise = new Promise((r) => resolve = r);
        transitions.push(promise);
        resolvers[prop] = resolve;
    });

    function listener(ev) {
        if ('any' in resolvers) {
            resolvers.any(ev);
            return;
        }
        if (ev.propertyName in resolvers) {
            resolvers[ev.propertyName](ev);
        }
    }
    transitionendEvents.forEach((ev) => element.addEventListener(ev, listener));
    const transition = Promise.all(transitions);
    transition.unsubscribe = function() {
        transitionendEvents.forEach((ev) => element.removeEventListener(ev, listener));
    };
    transition.then(transition.unsubscribe);
    return transition;
}

/**
 * Returns module's config script
 * @param {HTMLElement} element - module's element
 * @param {Boolean} returnElement - whether to return string or HTMLElement
 * @returns {String|HTMLElement} module's config script
 */
export function getModuleConfig(element, returnElement) {
    const configScript = element.querySelector('script');
    if (returnElement) {
        return configScript;
    }
    return configScript ? JSON.parse(configScript.text) : null;
}

export function getViewPosition(el, lookahead, viewportOffset) {
    var rect = el.getBoundingClientRect();
    var viewportHeight = client.getViewportHeight();
    lookahead = lookahead || 0;
    viewportOffset = viewportOffset || 0;

    var lookaheadRange = {
        top: 0 - lookahead,
        bottom: viewportHeight + lookahead,
    };
    var elementPosition = {
        top: rect.top - viewportOffset,
        bottom: rect.bottom - viewportOffset,
    };

    return {
        isHidden: function() {
            return !el.offsetParent;
        },

        isWithinViewport: function() {
            return elementPosition.top >= 0 && elementPosition.bottom <= viewportHeight;
        },

        isWithinLookahead: function() {
            return elementPosition.top >= lookaheadRange.top &&
                elementPosition.bottom <= lookaheadRange.bottom;
        },

        isPartiallyInViewport: function() {
            return (elementPosition.top >= 0 && elementPosition.top <= viewportHeight) ||
                (elementPosition.bottom > 0 && elementPosition.bottom < viewportHeight);
        },

        isPartiallyInLookahead: function() {
            if (elementPosition.top > 0) {
                return elementPosition.top < lookahead + viewportHeight;
            }
            if (elementPosition.bottom > 0) {
                return true;
            }
            return Math.abs(elementPosition.bottom) < lookahead;
        },
        isNearBottom: function() {
            return parseInt(rect.bottom, 10) <= lookahead;
        },
    };
}

export default {
    /**
     * Converts string to DOM nodes.
     * @param {String} string - input HTML string.
     * @returns {NodeList} - list of DOM nodes.
     */
    stringToHTML(string) {
        var container = document.createElement('div');
        container.innerHTML = string;
        return container.childNodes;
    },

    /**
     * Turns a NodeList into a proper array and returns the array.
     * @param {NodeList} nodeList - NodeList to turn into array
     * @returns {Element[]}
     */
    arrayFromNodeList(nodeList) {
        return [].slice.call(nodeList);
    },

    /**
     * Allows a function to be execute over a list of nodes, a node, or a string
     * which will be converted to a node
     * @param {String|NodeList|HTMLElement[]} content - content to be added
     * @param {Function} fn - Function to execute, takes a HTMLElement as an argument
     * @returns {Object} - service object
     */
    withNodeList(content, fn) {
        if (typeof content === 'string') {
            content = this.stringToHTML(content);
        }

        if (content instanceof HTMLElement) {
            content = [content];
        }

        if (content instanceof NodeList || Array.isArray(content)) {
            Array.prototype.slice.call(content).forEach(el => fn(el));
        }
        return this;
    },

    /**
     * Insert content, specified by the parameter, to the end of parent element.
     * @param {HTMLElement} parent - element to add content to
     * @param {String|NodeList|HTMLElement[]} content - content to be added
     * @returns {Object} - service object
     */
    append(parent, content) {
        if (typeof content === 'undefined') {
            content = parent;
            parent = document.body;
        }
        let fn = (el) => parent.appendChild(el);
        return this.withNodeList(content, fn);
    },

    /**
     * Prepend content into the parent after the nth child
     * @param {HTMLElement} parent - element to add content to
     * @param {String|NodeList|HTMLElement[]} content - content to be added
     * @param {Integer} nth - Position to insert after
     * @returns {Object} - service object
     */
    prepend(parent, content, nth = 0) {
        if (typeof content === 'undefined') {
            content = parent;
            parent = document.body;
        }
        let child = parent.children[nth];
        let fn = (el) => parent.insertBefore(el, child);
        return this.withNodeList(content, fn);
    },

    /**
     * Remove elements from DOM
     * @param {...Element} element - elements that need to be removed
     * @returns {Element[]} - array of removed elements
     */
    remove(...elements) {
        let removed = [];
        elements.forEach((el) => {
            if (!(el instanceof Element) || !el.parentNode) {
                return;
            }
            removed.push(el.parentNode.removeChild(el));
        });
        return removed;
    },

    /**
     * Returns child nodes of the element, that match selector.
     * @param {HTMLElement|String} element - parent element.
     * @param {String} selector - filter for child elements.
     * @returns {HTMLElement[]} - matched elements.
     */
    find(element, selector) {
        return Array.prototype.slice.call(element.querySelectorAll(selector));
    },

    /**
     * Returns first child node of the `element`, that match `selector`.
     * @param {HTMLElement|String} element - parent element.
     * @param {String} selector - filter for child element.
     * @returns {HTMLElement} - matched element
     */
    findOne(element, selector) {
        return element.querySelector(selector);
    },

    /**
     * Gets the first element that matches the selector.
     * Tests the element itself and traverses up through its ancestors.
     * @param {HTMLElement} element - starting element.
     * @param {String} selector - selector to match elements against.
     * @returns {HTMLElement[]} - matched elements.
     */
    closest(element, selector) {
        // third argument is a flag to test the target element itself
        return closest(element, selector, true);
    },

    /**
     * Adds class to specified element(s).
     * @param {HTMLElement|HTMLElement[]} elements - target node(s).
     * @param {String} className - class name to add. Multiple classes are separated by space.
     * @returns {void}
     */
    addClass(elements, className) {
        if (!Array.isArray(elements)) {
            elements = [elements, ];
        }
        let classNames = className.split(' ');
        elements.forEach(
            // not using `el.classList.add(...classNames)` as it's not supported by IE
            el => classNames.forEach((cls) => el.classList.add(cls))
        );
    },

    /**
     * Removes class from specified element(s).
     * @param {HTMLElement|HTMLElement[]} elements - target node(s).
     * @param {String} className - class name to remove. Multiple classes are separated by space.
     * @returns {void}
     */
    removeClass(elements, className) {
        if (!Array.isArray(elements)) {
            elements = [elements, ];
        }
        let classNames = className.split(' ');
        elements.forEach(
            // not using `el.classList.remove(...classNames)` as it's not supported by IE
            el => classNames.forEach((cls) => el.classList.remove(cls))
        );
    },

    /**
     * Determine whether any of elements are assigned the given class.
     * @param {HTMLElement|HTMLElement[]} elements - target node(s).
     * @param {String} className - class name to check.
     * @returns {Boolean} - whether any of elements are assigned the given class.
     */
    hasClass(elements, className) {
        if (!Array.isArray(elements)) {
            elements = [elements, ];
        }

        return elements.some(el => el.classList.contains(className));
    },

    /**
     * Add or remove one or more classes from each element in the set of matched elements.
     * @param {HTMLElement|HTMLElement[]} elements - target element(s).
     * @param {String} className - one or more class names (separated by spaces).
     * @param {Boolean} state - determines whether the class should be added or removed
     * @return {void}
     */
    toggleClass(elements, className) {
        if (!Array.isArray(elements)) {
            elements = [elements, ];
        }

        if (typeof elements === 'string') {
            // @todo this route should not be used
            elements = this.find(elements);
        }

        className.split(' ').forEach(name => elements.forEach(el => el.classList.toggle(name)));
    },

    /**
     * Returns `true` if the element would be selected by the specified selector string; otherwise, returns `false`
     * @param {Element} element - element to test
     * @param {String} selector - selector to apply
     * @param {Boolean} whether element matches selector
     */
    matches: (() => {
        const elProto = Element.prototype;
        const matches = (
            elProto.matches ||
            elProto.webkitMatchesSelector ||
            elProto.mozMatchesSelector ||
            elProto.msMatchesSelector ||
            function(selector) {
                return [].indexOf.call(document.querySelectorAll(selector), this) > -1;
            }
        );
        return (element, selector) => matches.call(element, selector);
    })(),

    getViewPosition,

    /**
     * Adds event listener.
     * @param {EventTarget} target - target for event listening.
     * @param {String} ev - event name. Multiple event names are separated by space.
     * @param {Object} data - object containing data that the callback can use.
     * @param {Function} handler - event handler.
     * @return {void}
     */
    on(target, ev, data, handler) {
        if (typeof data === 'function' && typeof handler === 'undefined') {
            handler = data;
            data = null;
        }

        ev.split(' ').forEach(e => target.addEventListener(e, handler));
    },

    /**
     * Adds event listener.
     * @param {EventTarget} target - target for event listening.
     * @param {String} ev - event name. Multiple event names are separated by space.
     * @param {Object} data - object containing data that the callback can use.
     * @param {Function} handler - event handler.
     * @return {Function} handler wrapper to pass to `dom.off` if need be
     */
    one(target, ev, data, handler) {
        const self = this;
        if (typeof data === 'function') {
            handler = data;
            data = null;
        }

        const once = function(e) {
            handler.call(this, e);
            self.off(target, ev, once);
        };

        self.on(target, ev, once);

        // in case the event didn't fire and removing the listener manually is needed
        return once;
    },

    /**
     * Removes event listener.
     * @param {EventTarget} target - target for event listening.
     * @param {String} ev - event name. Multiple event names are separated by space.
     * @param {Function} handler - event handler.
     * @return {void}
     */
    off(target, ev, handler) {
        ev.split(' ').forEach(e => target.removeEventListener(e, handler));
    },

    /**
     * Triggers event listener.
     * Fails silently if document.createEvent or event.initEvent are not available
     * @param {EventTarget} target - target for event listening.
     * @param {String} ev - event name. Multiple event names are separated by space.
     * @return {void}
     */
    trigger(target, ev) {
        if (document.createEvent) {
            ev.split(' ').forEach(e => {
                let event = document.createEvent('Event');
                if (event.initEvent) {
                    event.initEvent(e, false, true);
                    target.dispatchEvent(event);
                }
            });
        }
    },

    /**
     * Hide `el` element.
     * @param {HTMLElement} el - element to hide
     * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
     * @returns {Object} service object for chaining
     */
    hide(el, selector) {
        var element = selector ? this.find(el, selector) : el;
        this.addClass(element, 'js-hidden');
        return this;
    },

    /**
     * Display `el` element.
     * @param {HTMLElement} el - element to show
     * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
     * @returns {Object} service object for chaining
     */
    show(el, selector) {
        var elements = selector ? this.find(el, selector) : el;
        if (this.hasClass(elements, 'js-hidden')) {
            this.removeClass(elements, 'js-hidden');
        } else {
            if (!Array.isArray(elements)) {
                elements = [elements];
            }
            elements.forEach(elem => this.setStyle(elem, {
                display: 'block'
            }));
        }
        return this;
    },

    /**
     * Returns value of data in given element.
     * @param {HTMLElement|String} element - element.
     * @param {String} str - name of data parameter.
     * @returns {String} - value of data-attr.
     */
    getData(element, str) {
        if (typeof element === 'string') {
            element = this.stringToHTML(element)[0];
        }
        return element.getAttribute(`data-${str}`);
    },

    /**
     * Sets value for data in given element.
     * @param {HTMLElement|String} element - element.
     * @param {String} str - name of data parameter.
     * @param {String} val - value of data parameter.
     * @returns {Bool} - TRUE if success, FALSE on error
     */
    setData(element, str, val) {
        if (typeof element === 'string') {
            element = this.stringToHTML(element)[0];
        }
        element.setAttribute(`data-${str}`, val);
        return true;
    },

    /**
     * @description Gets value of specific style property
     * @param {HTMLElement} el - Element to get style property for
     * @param {String} styleName - Style property key
     * @returns {String} - Style property value
     */
    getStyle(el, styleName) {
        return el.style[styleName];
    },

    /**
     * @description Sets styles on an element
     * @param {HTMLElement} el - Element to set style for
     * @param {Object} styles An object which maps CSS style names to values
     * @returns {Object} - service object
     */
    setStyle(el, styles) {
        for (let key in styles) {
            if (styles.hasOwnProperty(key)) {
                el.style[key] = styles[key];
            }
        }
        return this;
    },

    /**
     * Get the value of an attribute for `el` element
     * @param {HTMLElement} el - Element to get attribute from
     * @param {String} attributeName - The name of the attribute to get.
     * @returns {String} - attribute value
     */
    getAttr(el, attributeName) {
        return el.getAttribute(attributeName);
    },

    /**
     * Set one or more attributes for `el` element
     * @param {HTMLElement} el - Element to set attributes for
     * @param {Object} attributes - An object of attribute-value pairs to set.
     * @returns {Object} - service object
     */
    setAttr(el, attributes) {
        for (let key in attributes) {
            if (attributes.hasOwnProperty(key)) {
                el.setAttribute(key, attributes[key]);
            }
        }
        return this;
    },

    /**
     * Delete an attribute for `el` element
     * @param {HTMLElement} el - Element to delete attributes for
     * @param {Object} attributeName - the name of the attribute to rename.
     * @returns {Object} - service object
     */
    removeAttr(el, attributeName) {
        el.removeAttribute(attributeName);
        return this;
    },

    /**
     * Indicates whether a specified element has a specified attribute or not.
     * @param {HTMLElement} el - target element.
     * @param {String} attributeName - the name of the attribute to check.
     * @return {Boolean} - result.
     */
    hasAttr(el, attributeName) {
        return el.hasAttribute(attributeName);
    },

    /**
     * Get text of `el` element or its child(if `selector` is set)
     * @param {HTMLElement} el - element to set text to
     * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
     * @returns {String} text of element
     */
    getText(el, selector) {
        var element = selector ? this.findOne(el, selector) : el;
        return element ? element.textContent : '';
    },

    /**
     * Set text for `el` element or its child(if `selector` is set)
     * @param {HTMLElement} el - element to set text to
     * @param {String} text - text to be set
     * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
     * @returns {Object} service for chaining
     */
    setText(el, text, selector) {
        var element = selector ? this.findOne(el, selector) : el;
        if (element) {
            element.textContent = text;
        }
        return this;
    },

    /**
     * Set HTML for `el` element or its child(if `selector` is set)
     * @param {HTMLElement} el - element to set text to
     * @param {String} html - HTML to be set
     * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
     * @returns {Object} service for chaining
     */
    setHTML(el, html, selector) {
        var element = selector ? this.findOne(el, selector) : el;
        if (element) {
            element.innerHTML = html;
        }
        return this;
    },

    /**
     * Get parent elements filtered by slector
     * @param {HTMLElement} el - element to search parents for
     * @param {String} selector - selector to match parent elements against
     * @returns {HTMLElement[]} - matched elements.
     */
    parent(el, selector) {
        return closest(el, selector);
    },

    getModuleConfig,

    /**
     * Creates HTML element.
     * @param {String} tag - tag name for the HTML element.
     * @param {Object} [attributes] - map of attribute names/values for the element.
     * @return {*|Element} - new HTML element.
     */
    createElement(tag, attributes) {
        var el = document.createElement(tag);
        this.setAttr(el, attributes);
        return el;
    },

    /**
     * Scrolls specified HTML element into view.
     * @param {HTMLElement} element - target HTML element.
     * @param {Number} [delay] - time in ms before scroll occurs.
     * @return {void}
     */
    scrollIntoView(element, delay) {
        const self = this;
        if (delay) {
            setTimeout(function() {
                self.scrollIntoView(element);
            }, delay);
        } else if (element.scrollIntoView) {
            element.scrollIntoView();
        } else {
            window.scrollTo(0, element.offsetTop);
        }
    },

    offset(el, selector) {
        var element = selector ? this.findOne(el, selector) : el;
        if (!element) {
            return {};
        }

        return {
            top: element.offsetTop,
            left: element.offsetLeft
        };
    },

    /**
     * Returns the size of element.
     * @param {HTMLElement} element - normalized dom element.
     * @returns {Object} - size of element {width, height}
     */
    size(element) {
        return {
            width: element.offsetWidth,
            height: element.offsetHeight
        };
    },

    detectTransitionEnd,
};