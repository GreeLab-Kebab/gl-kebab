import {
    throttle,
    debounce
} from 'lodash';
import {
    requestFullscreen,
    addFullscreenChangeListener,
    exitFullscreen,
    isFullscreen
} from '../../../js/services/polyfill-fullscreen/index';
import template from './video-player-skin.html';

const CONTROLS = [
    'muteButton', 'currentTime', 'duration', 'fullscreenButton',
    'playButton', 'progressBar', 'progressHandle', 'progressPlayed'
];
const CONTROLS_AUTOHIDE_MS = 2000;

class VideoPlayerSkin {

    /**
     * Creates a new VideoPlayerSkin instance
     * @param {Object} context - the t3 Context
     */
    constructor({
        video,
        container
    }) {
        this.video = video;
        this.controls = {};
        this.container = container;
        try {
            this.container.insertAdjacentHTML('beforeend', template.render());
            this.setElementReferences();
            this.initUIState();
            this.show();
        } catch (e) {
            // TODO: instrument this silent fail
            return;
        }
        this.video.controls = false;
        this.addListeners();
    }

    /**
     * Collects references to the custom element nodes
     * For use by the event handlers
     */
    setElementReferences() {
        const controlHandlers = {
            muteButton: {
                clickHandler: this.onMuteToggle
            },
            fullscreenButton: {
                clickHandler: this.onFullscreenButtonClick
            },
            progressBar: {
                clickHandler: this.onManualProgressUpdate,
                mousedownHandler: this.onProgressMouseDown,
                touchstartHandler: this.onProgressMouseDown
            },
            playButton: {
                clickHandler: this.onPlayToggle,
            }
        };
        if (!this.container) {
            throw new Error('VPS Custom UI - Did not find container');
        }
        CONTROLS.forEach(name => {
            const element = this.container.querySelector(`[data-name="${name}"]`);
            if (!element) {
                throw new Error(`VPS Custom UI - Did not find ${name}`);
            }
            this.controls[name] = Object.assign({
                element
            }, controlHandlers[name]);
        });
    }

    /**
     * Make any changes to the skin state necessary to represent the initial video state
     */
    initUIState() {
        // video could load in muted state
        if (this.video.muted) {
            this.container.dataset.muted = '';
        }
        this.container.dataset.autohide = '';
    }

    /**
     * Show the custom controls
     */
    show() {
        const controlsContainer = this.container.querySelector('[data-name="customUI"]');
        if (!controlsContainer) {
            throw new Error(`VPS Custom UI - Did not find element with [data-name="customUI"]`);
        }
        controlsContainer.removeAttribute('hidden');
    }

    /**
     * Toggle mute status
     */
    onMuteToggle() {
        this.video.muted = !this.video.muted;
        this.onSetMuteData();
    }

    /**
     * Toggle mute data
     */
    onSetMuteData() {
        if (this.video.muted) {
            this.container.dataset.muted = '';
        } else {
            this.container.removeAttribute('data-muted');
        }
    }

    /**
     * Toggle playing status
     */
    onPlayToggle() {
        if (this.video.paused) {
            this.video.play();
        } else {
            this.video.dataset.userPaused = '';
            this.video.pause();
        }
    }

    /**
     * Update the UI elements to represent the provided time
     * @param {Number} time - the time to update the UI to
     */
    updateProgressUI(time) {
        const duration = isNaN(this.video.duration) ? 0 : this.video.duration;
        const playedPercent = time / duration * 100;
        // update time labels
        this.controls.currentTime.element.textContent = this.secondsToTimeStamp(time);
        this.controls.duration.element.textContent =
            `-${this.secondsToTimeStamp(duration - time)}`;
        // update progress elements
        this.controls.progressHandle.element.style.left = `${playedPercent}%`;
        this.controls.progressPlayed.element.style.width = `${playedPercent}%`;
    }

    /**
     * Triggered by the timeupdate event listener
     */
    onAutoProgressUpdate() {
        if (!this.adjustingProgress) {
            if (!isNaN(this.video.currentTime)) {
                this.updateProgressUI(this.video.currentTime);
            }
        }
    }

    /**
     * Triggered by user interaction with the progress bar
     * @param {Event} e - the native browser event
     */
    onManualProgressUpdate(e) {
        if (!this.adjustingProgress) {
            return;
        }
        const eventX = (e.changedTouches && e.changedTouches[0].clientX) || e.clientX;
        const barOffset = this.controls.progressBar.element.getBoundingClientRect().left;
        const barWidth = this.controls.progressBar.element.clientWidth;
        const progress = (eventX - barOffset) / barWidth;
        const boundedProgress = Math.max(Math.min(progress, 1), 0);
        const boundedTime = this.video.duration * boundedProgress;
        this.updateProgressUI(boundedTime);
        this.video.currentTime = boundedTime;
    }

    /**
     * Triggered by mousedown and touchdown events
     */
    onProgressMouseDown() {
        this.adjustingProgress = true;
    }

    /**
     * Triggered by a global mouseup or touchend event
     * @param {Event} e - the native browser event
     */
    onMouseUp(e) {
        this.onManualProgressUpdate(e);
        this.adjustingProgress = false;
    }

    /**
     * Sets [data-autohide] attribute when mouse has not moved
     * in the last CONTROLS_AUTOHIDE_MS milliseconds
     */
    addControlsAutoHideListener() {
        const debouncedHideControls = debounce(() => {
            this.container.dataset.autohide = '';
        }, CONTROLS_AUTOHIDE_MS);
        this.container.addEventListener('mousemove', () => {
            this.container.removeAttribute('data-autohide');
            debouncedHideControls();
        });
    }

    /**
     * Update the data-state attribute for the player
     * @param {String} value - the new state
     */
    updateStateAttribute(value) {
        this.container.dataset.state = value;
    }

    /**
     * Toggle Fullscreen status
     */
    onFullscreenButtonClick() {
        if (isFullscreen()) {
            exitFullscreen();
        } else {
            requestFullscreen(this.container);
        }
    }

    /**
     * Triggered on onFullscreenChange event
     * We have a separate listener to tell if we really entered fullscreen
     * as the user is able to cancel it.
     */
    onFullscreenChange() {
        if (isFullscreen()) {
            this.container.dataset.fullscreen = '';
        } else {
            this.container.removeAttribute('data-fullscreen');
        }
    }

    /**
     * Delegate an event on the player to the appropriate handler
     * @param {Event} e - the native browser event
     */
    delegate(e) {
        const targetControl = this.controls[e.target.dataset.name];
        if (targetControl && targetControl[`${e.type}Handler`]) {
            return targetControl[`${e.type}Handler`].call(this, e);
        }
        // Default a click anywhere on the video to play/pause
        if (e.type === 'click' && e.target === this.video) {
            return this.onPlayToggle();
        }
        return null;
    }

    // NOTE: this method will overflow for times greater than 24 hours
    secondsToTimeStamp(seconds) {
        seconds = Math.max(seconds, 0); // IE can have a negative currentTime
        const isoString = new Date(seconds * 1000).toISOString();
        let timePart = isoString.substr(11, 8); // 00:00:00;
        if (seconds < 3600) {
            timePart = timePart.substr(3, 5); // 00:00
        }
        return timePart.replace(/^0+(\d:)/, '$1'); // strip more than 1 leading 0
    }

    /**
     * Add all listeners to the custom DOM
     */
    addListeners() {
        // *** Delegated Listeners ***
        this.container.addEventListener('click', this.delegate.bind(this));
        this.container.addEventListener('mousedown', this.delegate.bind(this));
        this.container.addEventListener('touchstart', this.delegate.bind(this));

        // *** Video Event Listeners ***
        this.video.addEventListener('waiting', this.updateStateAttribute.bind(this, 'loading'));
        this.video.addEventListener('playing', this.updateStateAttribute.bind(this, 'playing'));
        this.video.addEventListener('pause', this.updateStateAttribute.bind(this, 'paused'));
        this.video.addEventListener('timeupdate', throttle(this.onAutoProgressUpdate.bind(this), 50));
        this.video.addEventListener('volumechange', this.onSetMuteData.bind(this));
        // IE does not correctly fire 'playing' after a seek, so we use the following two listeners
        this.video.addEventListener('seeking', () => {
            if (this.container.dataset.state !== 'init') {
                this.updateStateAttribute('loading');
            }
        });
        this.video.addEventListener('seeked', () => {
            if (this.container.dataset.state !== 'init') {
                this.updateStateAttribute(this.video.paused ? 'paused' : 'playing');
            }
        });
        this.addControlsAutoHideListener();

        // *** Global Listeners ***
        document.addEventListener('mouseup', this.onMouseUp.bind(this));
        document.addEventListener('touchend', this.onMouseUp.bind(this));
        document.addEventListener('mousemove', this.onManualProgressUpdate.bind(this));
        document.addEventListener('touchmove', this.onManualProgressUpdate.bind(this));
        addFullscreenChangeListener(this.onFullscreenChange.bind(this));
    }
}

export default function addSkin({
    video,
    container
}) {
    return new VideoPlayerSkin({
        video,
        container
    });
}