import dom from '../dom';
import {
    throttle
} from 'lodash';

export default class ScrollingCarousel {
    /**
     * Takes an element which should be a container of the carousel
     * @param {Object} - DOM object
     */
    constructor(elem) {
        this.elem = elem;
        this.content = dom.findOne(elem, '.js-carousel-content');
        this.items = dom.find(elem, '.js-carousel-item');
        this.wrapper = dom.findOne(elem, '.js-carousel-wrapper');
    }

    /**
     * Performs some modifications to the items and container, so that
     * all item heights match, and the width is no longer than it needs
     * to be.
     */
    setSizes() {
        if (!this.items) {
            return false;
        }

        // Determine the greatest height of all items
        var itemMaxHeight = 0;
        this.items.forEach(item => {
            if (itemMaxHeight < item.offsetHeight) {
                itemMaxHeight = item.offsetHeight;
            }
        });

        this.items.forEach(item => {
            item.style.height = itemMaxHeight + 'px';
        });

        // Determine what the width should be
        if (this.items.length) {
            var itemMargin = 0;
            if (this.items[0] instanceof Element && typeof getComputedStyle !== 'undefined') {
                let itemStyle = getComputedStyle(this.items[0]);
                itemMargin = parseInt(itemStyle.marginLeft, 10) + parseInt(itemStyle.marginRight, 10);
            }

            let itemWidth = this.items[0].offsetWidth;
            let contentWidth = this.items.length * (itemWidth + itemMargin);
            this.content.style.width = contentWidth + 'px';
        }
        return true;
    }

    /**
     * If a carousel has been initialized before it is visible (perhaps during an AB test)
     * then the sizes need to be reset.
     */
    resetSizes() {
        if (!this.items) {
            return;
        }
        // We need to reset the height to auto before recalculating
        // (as it will be set to 0px if measured when not visible)
        this.items.forEach(item => {
            item.style.height = 'auto';
        });
        this.setSizes();
    }

    /**
     * Binds wrapper scroll event so we can determine the active page
     * @returns {void}
     */
    initPages() {
        if (!this.wrapper || !this.items) {
            return;
        }
        this.wrapper.onscroll = throttle(this.onScrollCarousel.bind(this), 200);
    }

    /**
     * Moves activeClass to .js-carousel-page that is currently active in carousel
     * @returns {void}
     */
    onScrollCarousel(e) { // eslint-disable-line
        const activeClass = 'js-carousel-page--active';
        const activePage = this.elem.querySelector(`.${activeClass}`);
        if (!this.items || !activePage) {
            return;
        }
        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];
            if (item.getBoundingClientRect().left >= 0) {
                const newActive = this.elem.querySelector(`.js-carousel-page[data-page="${i + 1}"]`);
                if (newActive) {
                    dom.removeClass(activePage, activeClass);
                    dom.addClass(newActive, activeClass);
                }
                return;
            }
        }
    }
}