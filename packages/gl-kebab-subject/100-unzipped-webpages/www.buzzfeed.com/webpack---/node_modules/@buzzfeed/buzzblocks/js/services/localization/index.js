import {
    isString
} from 'lodash';
import cookies from '../cookies';
import templateEngine from '../template-engine';

const localization = window.BZFD.Context.page.localization;
const translations = localization.translations || {};
const editions = {
    de: ['de'],
    en: ['au', 'ca', 'in', 'uk', 'us'],
    es: ['es', 'mx'],
    fr: ['fr'],
    ja: ['jp'],
    pt: ['br'],
};

export default {
    /**
     * Constructs a canonical edition for site_component_api.
     * For NON-EN posts picks language and country directly from Buzz API response.
     * For EN posts picks a most suitable language for user's country cookie,
     *   unless {useCountryCookie: false} is passed
     * Defaults to en-us.
     * @param {Boolean} [options.useCountryCookie=true] - whether or not to use user's country cookie when edition is ambiguous
     * @return {String} - edition string.
     */
    getEdition(options = {}) {
        const optionsDefault = {
            useCountryCookie: true
        };
        if (isString(options)) { // for backward compatibility with calls of form `localization.getEdition('feedpager')`
            options = (options === 'feedpager') ? {
                useCountryCookie: false
            } : {};
        }
        options = Object.assign({}, optionsDefault, options);

        let edition = localization.country;
        let [language, country = ''] = edition.split('-');

        if (localization.language === 'en' && options.useCountryCookie) {
            let userEdition = cookies.get('country');
            if (!userEdition) {
                userEdition = country || 'us';
            }
            [language, country] = userEdition.split('-');

            if (!country && language !== 'es') {
                country = language;
                language = Object.keys(editions).filter(e => editions[e].indexOf(language) !== -1)[0];
            }
        }

        if (editions[language] && editions[language].indexOf(country) !== -1) {
            return `${language}-${country}`;
        }

        // Special case for a mix of es-es and es-mx
        if (language === 'es') {
            return 'es';
        }

        return 'en-us';
    },

    getRawPageLanguage() {
        return Object.keys(editions).indexOf(localization.language) !== -1 ?
            localization.language :
            'en';
    },

    /**
     * Gets current page locale ISO code.
     * @return {String} - current page locale ISO code.
     */
    getPageLocale() {
        return localization.locale;
    },

    /**
     * Gets the country cookie that the user is bucketed or geolocated in
     * @return {String} - user country from cookie or 'us' as fallback.
     */
    getUserCountry() {
        return cookies.get('country') || 'us';
    },

    /**
     * Get translation
     * @param {String} key - the translation key.
     * @param {Object} data - data to be passed to the template
     * @param {String} delimiters - symbols in the templates to delimit data e.g. lodash `<%= %>`
     * @return {String} - localized translation.
     */
    getTranslation(key, data, delimiters) {
        if (!translations[key]) {
            throw new Error('Missing translation ' + key + ' for ' + this.getRawPageLanguage());
        }

        let compilationOptions = delimiters ? {
            delimiters
        } : {};

        return templateEngine.renderString(translations[key], data, compilationOptions);
    },

    /**
     * Get translation string
     * @param {String} key - the translation key.
     * @return {String} - localized translation.
     */
    getTranslationStr(key) {
        return translations[key] || '';
    },

    /**
     * Gets localized date time format template.
     * @return {String} - localized date time template.
     */
    getDateFormatTemplate() {
        switch (localization.language) {
            case 'de':
                return '{{D}}. {{MM}} {{Y}}, {{H}}:{{m}} Uhr';
            case 'es':
                return '{{D}} de {{MM}} de {{Y}}, {{h}}:{{m}} {{a}}';
            case 'fr':
                return '{{D}} {{MM}}, {{Y}} &agrave; {{H}} h {{m}}';
            case 'ja':
                return '{{Y}}/{{M}}/{{DD}} {{H}}:{{m}}';
            case 'pt':
                return '{{D}} de {{MM}} de {{Y}}, {{h}}:{{m}} {{a}}';
            default: //en
                return '{{MM}} {{D}}, {{Y}}, at {{h}}:{{m}} {{a}}';
        }
    }
};