import {
    Application
} from 't3js';
import scrollListener from '../../services/scroll-listener';
import solid from '../../services/solid/standalone';
import stickyRegistry from '../../services/sticky-registry';
import {
    getUniqueEventName
} from '../../services/util/standalone';


export const behaviorName = 'stick-to-top';
export const name = behaviorName;
export const initEvent = `${behaviorName}--init`;
export const stateEvent = `${behaviorName}--state`;


export default class Sticky {
    constructor(context) {
        this.context = context;
        this.element = context.getElement();
        const configDefaults = {
            breakpoints: ['ALL'],
            positionMode: 'top'
        };
        this.config = { ...configDefaults,
            ...context.getConfig('stickToTop')
        };
        this.isInitialized = false;
        this.canStick = true;
        this.isFixed = false;
        this.onmessage = {
            [getUniqueEventName(initEvent, this.element)]: this.initSticky
        };
    }

    get stickyRegistryOpts() {
        const priority = (
            ('priority' in this.config) ? this.config.priority : stickyRegistry.defaultPriorities.normal
        );
        return {
            priority
        };
    }

    init() {
        if (!this.config.initOnMsg) {
            this.initSticky();
        }
    }

    initSticky(options) {
        /* Don't initialize more than once */
        if (this.isInitialized) {
            return;
        }
        this.isInitialized = true;

        this.config = { ...this.config,
            ...options
        };

        this.element.classList.add('xs-relative', 'sticky');

        /* blank element will be inserted in place of the element
        so that the parent height does not change when the element is removed from document flow.
        The code assumes that the element height will not change */
        const filler = this.filler = document.createElement('div');
        filler.style.height = `${this.element.offsetHeight}px`;
        filler.className = 'sticky-filler xs-static xs-hide';
        /* insert right after the element so that the filler can be styled using `+` selector if need be */
        this.element.insertAdjacentElement('afterend', filler);

        if (this.config.breakpoints.indexOf('ALL') === -1) {
            solid.breakpointObserver.on('match', this.checkEligibility);
        }
        this.checkEligibility();

        this.stickyEventManager = stickyRegistry.subscribe(this.element);
        this.stickyEventManager.on(stickyRegistry.MEMBERS_UPDATE, this.adjustFixedPosition);
    }

    manageSticky({
        force = false
    } = {}) {
        if (!this.canStick) {
            return;
        }

        const {
            inViewport
        } = this.getPosition();
        if ((!this.isFixed || force) && (inViewport < this.fixAt)) {
            this.stick();
        } else if ((this.isFixed || force) && (inViewport >= this.fixAt)) {
            this.unstick();
        }
    }

    adjustFixedPosition = ({
        priority
    }) => {
        if (priority < this.stickyRegistryOpts.priority) {
            return;
        }
        if (!this.canStick) {
            return;
        }

        const allowedTop = stickyRegistry.getAvailableTop(this.element, this.stickyRegistryOpts);
        if (allowedTop !== this.fixAt) {
            this.fixAt = allowedTop;
            this.manageSticky({
                force: true
            });
        }
    }

    checkEligibility = ({
        breakpoint
    } = {}) => {
        let canStick;
        if (this.config.breakpoints.indexOf('ALL') > -1) {
            canStick = true;
        } else {
            if (!breakpoint) {
                breakpoint = solid.getBreakPoint();
            }
            canStick = this.config.breakpoints.indexOf(breakpoint) > -1;
        }

        if (canStick) {
            this.canStick = true;
            this.fixAt = stickyRegistry.getAvailableTop(this.element, this.stickyRegistryOpts);
            this.scrollListenerId = scrollListener.add({
                throttleTimeout: 150,
                /* the callback will be called as soon as the listener is added and then on scroll events */
                callback: () => this.manageSticky()
            });
        } else {
            this.canStick = false;
            scrollListener.remove(this.scrollListenerId);
            this.unstick();
        }
    }

    /**
     * Returns element's position relative to viewport and document as if it was not sticky
     * (i.e. its own position if it's not fixed, and its filler's position otherwise)
     */
    getPosition() {
        let el = this.isFixed ? this.filler : this.element;
        const inViewport = el.getBoundingClientRect().top;
        const inDocument = inViewport + window.pageYOffset;
        return {
            inViewport,
            inDocument
        };
    }

    setPosition(pos) {
        if (this.config.positionMode === 'translate') {
            const transform = `translateY(${pos}px)`;
            this.element.style.WebkitTransform = transform;
            this.element.style.transform = transform;
        } else {
            this.element.style.top = `${pos}px`;
        }
    }

    stick() {
        this.isFixed = true;
        this.filler.classList.remove('xs-hide');
        this.element.classList.add('xs-fixed', 'sticky--fixed');
        this.setPosition(this.fixAt);
        stickyRegistry.add(this.element, this.stickyRegistryOpts);
    }

    unstick() {
        this.isFixed = false;
        if (this.filler) {
            this.filler.classList.add('xs-hide');
        }
        this.element.classList.remove('xs-fixed', 'sticky--fixed');
        this.setPosition(0);
        stickyRegistry.remove(this.element);
    }

    destroy() {
        this.unstick();
        stickyRegistry.remove(this.element);
        stickyRegistry.unsubscribe(this.element);
        if (this.stickyEventManager) {
            this.stickyEventManager.off(stickyRegistry.MEMBERS_UPDATE, this.adjustFixedPosition);
        }
        scrollListener.remove(this.scrollListenerId);
        if (this.filler) {
            this.filler.parentElement.removeChild(this.filler);
        }
        delete this.onmessage;
        delete this.element;
        delete this.filler;
    }
}


Application.addBehavior(behaviorName, (context) => new Sticky(context));