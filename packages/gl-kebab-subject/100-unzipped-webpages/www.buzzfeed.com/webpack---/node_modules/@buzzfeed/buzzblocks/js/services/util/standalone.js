import closest from 'closest';
import {
    get,
    isFunction,
    merge
} from 'lodash';
import {
    instrument
} from '../metrics';
import {
    getModuleConfig
} from '../dom';


/**
 * Service with some general widely used functions
 */
var util = {};


/**
 * Gets a list of object's enumerable property names.
 * @param {Object} obj - target object.
 * @return {Array} - list of object's keys.
 */
util.getKeys = function(obj) {
    var res;
    if (Object.keys) {
        return Object.keys(obj);
    } else {
        res = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                res.push(key);
            }
        }
        return res;
    }
};

/**
 * Adds module's element id attribute value to the event name.
 * @param {String} origName - original event name.
 * @param {HTMLElement} moduleEl - module's DOM element.
 * @return {String} - name with id value.
 */
export function getUniqueEventName(origName, moduleEl) {
    return origName + '-' + moduleEl.id;
}
util.getUniqueEventName = getUniqueEventName;

util.capitalize = function(str) {
    if (typeof str !== 'string') {
        return str;
    } else {
        return str.replace(/\w+/g, function(a) {
            return a.charAt(0).toUpperCase() + a.substr(1).toLowerCase();
        });
    }
};

util.hasQueryString = function(url) {
    return url.indexOf('?') > -1;
};

util.removeHash = function(url) {
    url = url + ''; // Convert object to string, if necessary
    if (url.indexOf('#') > -1) {
        return url.substr(0, url.indexOf('#'));
    }
    return url;
};

util.removeQueryString = function(url) {
    url = url + ''; // Convert object to string, if necessary
    if (url.indexOf('?') > -1) {
        if (url.indexOf('#') === -1) {
            return url.substr(0, url.indexOf('?'));
        }
        return url.substr(0, url.indexOf('?')) + url.substr('#', url.length);
    }
    return url;
};

util.getQueryString = function(url) {
    url = util.removeHash(url);
    var querystring = '';
    if (url.indexOf('?') > -1) {
        querystring = url.substr(url.indexOf('?'), url.length); // Contains '?'
    }
    return querystring;
};

util.getHash = function(url) {
    url = url + ''; // Convert object to string, if necessary
    if (url.indexOf('#') > -1) {
        return url.substr(url.indexOf('#'), url.length);
    }
    return '';
};

util.queryStringToObject = function(qs) { // Without '?'
    if (qs === '' || qs === undefined || qs === null) {
        return {};
    }
    var params = qs.split('&');
    var pair;
    var obj = {};

    util.each(params, function(i, val) {
        pair = val.split('=');
        if (pair[1] === '') {
            pair[1] = null;
        }
        obj[pair[0]] = pair[1];
    });
    return obj;
};

util.objectToQueryString = function(qs) {
    var str = [];
    util.each(qs, function(key, val) {
        str.push(key + '=' + val);
    });
    return '?' + str.join('&');
};

util.getBaseUrl = function(url) {
    url = util.removeHash(url);
    url = util.removeQueryString(url);
    return url;
};

util.addParams = function(url, keyvals) {
    var qs = util.getQueryString(url); // Contains '?'
    var hash = util.getHash(url); // Contains '#'
    var key;
    var val;

    url = util.removeHash(url);
    url = util.removeQueryString(url);

    qs = util.queryStringToObject(qs.substr(1, qs.length)); // no '?'

    util.each(keyvals, function(i, keyval) {
        key = keyval[0];
        val = keyval[1];
        qs[key] = val;
    });

    return url + util.objectToQueryString(qs) + hash;
};

/**
 * Remove given parameters from a URL string.
 * @param {string} url - a url
 * @param {Array} keys - an array of keys to be deleted
 * @return {string} url - the url without the given params
 */
util.removeParams = function(url, keys) {
    var base = util.getBaseUrl(url);
    var qs = util.getQueryString(url);
    var hash = util.getHash(url);
    var params = util.queryStringToObject(qs.substr(1, qs.length));

    util.each(keys, function(i, key) {
        delete params[key];
    });

    return base + util.objectToQueryString(params) + hash;
};

util.prepareUrl = function(url, data) {
    // Append parameter(s) to url
    var keyvals = [];

    util.each(data, function(key, val) {
        if (typeof val === 'undefined') {
            return;
        }
        keyvals.push([
            key,
            encodeURIComponent(val),
        ]);
    });

    return util.addParams(url, keyvals);
};

util.redirect = function(url) {
    if (typeof url === 'string' && url) {
        window.location.href = url;
    }
};

util.openPopup = function(url, options) {
    if (typeof url === 'string' && url) {
        var name = '_blank';
        var wparams = '';

        if (options && options.height && options.width) {
            var sTop = (window.screen.height / 2) - (options.height / 2);
            var sLeft = (window.screen.width / 2) - (options.width / 2);
            wparams = 'scrollbars=yes, toolbar=0, status=0, width=' + options.width + ', height=' + options.height + ', top=' + sTop + ', left=' + sLeft;
            name = options.name ? options.name : name;
        }
        window.open(url, name, wparams);
    }
};

/**
 * A generic iterator function, which can be used to seamlessly iterate over both objects
 * and arrays.
 * @todo reorder arguments when iterating an array to match Array.prototype.forEach behavior
 */
util.each = (iterable, callback) => {
    if (Array.isArray(iterable)) {
        iterable.forEach((item, idx) => callback(idx, item));
    } else {
        for (let key in iterable) {
            if (iterable.hasOwnProperty(key)) {
                callback(key, iterable[key]);
            }
        }
    }
};

util.extend = merge;

/**
 *
 * @return {Object} - map of query parameters keys and values
 */
util.getQueryParams = function() {
    var search = window.location.search.substring(1);
    var result = {};
    if (search) {
        search.split('&').forEach(function(param) {
            var p = param.split('=');
            var key = decodeURIComponent(p[0]);
            var value = decodeURIComponent(p.slice(1).join('='));
            result[key] = value;
        });
    }

    return result;
};

/**
 * Adds query parameter to the end of provided URL string.
 * @param {String} [url=location.href] - target URL string.
 * @param {String} key - parameter name.
 * @param {String} val - parameter value.
 * @return {String} - url with specified parameter at the end.
 */
util.addQueryParam = function(url, key, val) {
    url = url || window.location.href;
    return url + (url.split('?')[1] ? '&' : '?') + (key + '=' + val);
};

/* eslint-disable max-len */
/**
 * Change number into shortened format.
 * Example: 125 -> 125; 3456 -> 3,456; 10355 -> 10,4K; 1100123 -> 1.1M;
 * Adapted from
 * https://stackoverflow.com/questions/3177855/how-to-format-numbers-similar-to-stack-overflow-reputation-format
 * @param {Number} val - number to be formatted
 * @returns {String} shortened number
 */
/* eslint-enable max-len */
util.largeNumberNotation = function(val) {
    if (val < 1000) {
        return val;
    } else if (val < 10000) {
        return val.toString().charAt(0) + ',' + val.toString().substring(1);
    } else if (val >= 1000000) {
        return (val / 1000000).toFixed(val % 1000000 !== 0) + 'M';
    }
    return (val / 1000).toFixed(val % 1000 !== 0) + 'K';
};

/* eslint-disable max-len */
/**
 * Splits number with comma by thousands
 * @param {Number} num - number to be formatted
 * @returns {String} - number with commas
 * eslint-disable max-len
 * @see http://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript
 * eslint-enable max-len
 */
util.numberWithCommas = function(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};

/**
 * Returns the smallest of numbers.
 * @return {Number} - smallest number.
 */
util.min = function( /*[value1[, value2[, ...]]]*/ ) {
    return Math.min.apply(Math, Array.prototype.filter.call(arguments, function(n) {
        return !isNaN(+n);
    }));
};

/**
 * Converts object to query string params.
 * @param {Object} obj - target object.
 * @return {string} - query string.
 */
util.toQueryString = function(obj) {
    var res = [];
    this.each(obj, function(k, v) {
        if (v !== null && v !== '' && typeof v !== 'undefined') {
            res.push(k + '=' + v);
        }
    });
    return res.join('&');
};

/**
 * Gets a handler for internal events for T3 modules and behaviors.
 * @param {Object} handlerMap - handlers map (key is a message name, value is a handler).
 * @return {Function} - handler for T3 onmessage method.
 */
util.getMessageHandler = function(handlerMap) {
    return function(name, data) {
        var handler = handlerMap[name];
        if (typeof handler === 'function') {
            handler.call(this, data);
        }
    };
};

/**
 * Gets a handler for DOM events for T3 modules and behaviors.
 * @param {Object} handlerMap - handlers map
 * (key is a dataType attribute of the target element, value is a handler).
 * @return {Function} - handler for native DOM events in T3.
 */
util.getEventHandler = function(handlerMap) {
    return function(ev, el, elType) {
        var handler = handlerMap[elType];
        if (typeof handler === 'function') {
            handler.call(this, ev, el);
        }
    };
};

/**
 * Adds leading symbols to a string.
 * @param {String} src - string to pad.
 * @param {String} sym - symbol to add to the src string.
 * @param {Number} len - required result string length.
 * @return {String} - padded src string.
 */
util.padLeft = function(src, sym, len) {
    var str = src.toString();
    var targetLength = len - str.length;
    var acc = '';

    for (var i = 0; i < targetLength; i++) {
        acc += sym;
    }

    return acc + src;
};


/**
 * Converts string into small caps
 * @param {String} str - string to convert.
 * @return {String} - converted string.
 */
util.freeFormFormat = function(str) {
    var uglyStr = str
        .replace(/["'"“’ ]/g, '')
        .toLowerCase();

    return uglyStr;
};

/**
 * Coverts seconds to a video-format timestamp
 * NOTE: this method will overflow for times greater than 24 hours
 * @param {Number} seconds
 * @returns {String} the timestamp
 */
export function secondsToTimeStamp(seconds) {
    const isoString = new Date(seconds * 1000).toISOString();
    let timePart = isoString.substr(11, 8); // 00:00:00;
    if (seconds < 3600) {
        timePart = timePart.substr(3, 5); // 00:00
    }
    return timePart.replace(/^0+(\d:)/, '$1'); // strip more than 1 leading 0
}
util.secondsToTimeStamp = secondsToTimeStamp;

/**
 * Returns time since text
 * @param {String} date - date string in UTC format `yy:mm:ddThh:mm:ssZ`
 * @return {Object} time since object {'type': '', 'value': '', 'text': ''}
 */
util.timeSince = function(date) {
    var baseFormat = {
        'year': ['year', 'years', ],
        'month': ['month', 'months', ],
        'day': ['day', 'days', ],
        'hour': ['hour', 'hours', ],
        'minute': ['minute', 'minutes', ],
        'justNow': ['just now', ],
    };
    var interval;
    var seconds = Math.floor(((new Date()).getTime() - (new Date(date)).getTime()) / 1000);

    interval = Math.floor(seconds / 31536000);

    if (interval >= 1) {
        return {
            'type': 'year',
            'value': interval,
            'text': interval + ' ' + (interval === 1 ? baseFormat.year[0] : baseFormat.year[1]) + ' ago'
        };
    }

    interval = Math.floor(seconds / 2592000);

    if (interval >= 1) {
        return {
            'type': 'month',
            'value': interval,
            'text': interval + ' ' + (interval === 1 ? baseFormat.month[0] : baseFormat.month[1]) + ' ago'
        };
    }

    interval = Math.floor(seconds / 86400);

    if (interval >= 1) {
        return {
            'type': 'day',
            'value': interval,
            'text': interval + ' ' + (interval === 1 ? baseFormat.day[0] : baseFormat.day[1]) + ' ago'
        };
    }

    interval = Math.floor(seconds / 3600);

    if (interval >= 1) {
        return {
            'type': 'hour',
            'value': interval,
            'text': interval + ' ' + (interval === 1 ? baseFormat.hour[0] : baseFormat.hour[1]) + ' ago'
        };
    }

    interval = Math.floor(seconds / 60);

    if (interval > 1) {
        return {
            'type': 'minute',
            'value': interval,
            'text': interval + ' ' + (interval === 1 ? baseFormat.minute[0] : baseFormat.minute[1]) + ' ago'
        };
    }

    return {
        'type': 'now',
        'value': '',
        'text': baseFormat.justNow[0]
    };
};

util.bulkDelete = function(fields, object) {
    util.each(fields, function(i, val) {
        delete object[val];
    });
};

/**
 * Send data to BF Analytics
 * Example:
 * @param {String} bfaRoute - the route for bfa ex. 'track/click/share'
 * @param {Object} bfaData - formatted object ex. {t:'click:share-button', d:'Facebook'}
 * @returns void
 */
export function bfaTrack(bfaRoute, bfaData = {}) {
    if (!window.bfa || !(window.bfa instanceof Function) || !window.bfaBinder) {
        return;
    }

    window.bfa(bfaRoute, bfaData);
}
util.bfaTrack = bfaTrack;

/**
 * Checks for screen orientation
 * @return {String} `portrait` or '`landscape`
 */
export function getScreenOrientation() {
    if (screen.orientation && screen.orientation.type) {
        return screen.orientation.type.replace('-primary', '');
    } else if (window.orientation) {
        if (Math.abs(window.orientation) === 90) {
            return 'landscape';
        } else {
            return 'portrait';
        }
    } else if (window.matchMedia) {
        if (window.matchMedia('(orientation: portrait)').matches) {
            return 'portrait';
        } else if (window.matchMedia('(orientation: landscape)').matches) {
            return 'landscape';
        }
    }

    return 'landscape';
}
util.getScreenOrientation = getScreenOrientation;

/**
 * Checks browser user agent to detect ipad device
 * @return {Boolean} `true` if ipad device detected, `false` otherwise
 */
util.isIOSIPad = (function() {
    var agent = navigator.userAgent.toLowerCase();

    if (agent.match(/ipad/)) {
        return true;
    }

    return false;
})();

/**
 * Checks browser user agent to detect iphone|ipod device
 * @return {Boolean} `true` if iphone|ipod device detected, `false` otherwise
 */
util.isIOSMobile = (function() {
    var agent = navigator.userAgent.toLowerCase();

    if (agent.match(/iphone|ipod/)) {
        return true;
    }

    return false;
})();

/**
 * Checks browser user agent to detect iOS device.
 * This is not a reliable long-term method for detecting iOS and should be used sparingly.
 * @return {Boolean} `true` if iOS device detected, `false` otherwise
 */
export const isIOS = (() => util.isIOSIPad || util.isIOSMobile)();
util.isIOS = isIOS;

/**
 * Checks browser user agent to detect if safari user
 * @return {Boolean}
 */
export const isSafari = (function() {
    // Safari 3.0+ "[object HTMLElementConstructor]"
    return /constructor/i.test(window.HTMLElement) || (function(p) {
        return p.toString() === '[object SafariRemoteNotification]';
    })(!window['safari'] || (typeof safari !== 'undefined' && safari.pushNotification)); // eslint-disable-line no-undef
})();
util.isSafari = isSafari;

/**
 * Creates a script tag with the specified URL and appends it to the specified element (defaults to <head>)
 * @param {String} url - resource URL.
 * @param {Element} [parent=document.head] - element to append the script to
 * @return {Promise} - resolves with the script element when it has loaded.
 */
export function createScript(url, parent = document.head, async = true) {
    return new Promise((resolve, reject) => {
        let script = document.createElement('script');
        script.onload = () => resolve(script);
        script.onerror = evt => {
            instrument('script', 'error', {
                url: get(evt, 'currentTarget.src', '').split('?')[0]
            });
            reject('Script failed to load');
        };
        script.src = url;
        script.async = async;
        parent.appendChild(script);
    });
}
util.createScript = createScript;

/**
 * Creates a link[rel=stylesheet] tag with the specified URL and appends it to the head)
 * @param {String} url - resource URL.
 * @return {Promise} - resolves with the link element when it has loaded.
 */
util.createStyleSheet = (url) => {
    return new Promise((resolve, reject) => {
        let link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = url;
        link.onload = () => resolve(link);
        link.onerror = () => reject(`${url} failed to load`);
        document.head.appendChild(link);
    });
};

/**
 * Recursively strip html tags
 * @param {Object|Array|String} strip - string or object to be stripped
 * @returns {Object|Array|String} - stripped string or object
 */
util.stripHTML = strip => {
    var stripped = Array.isArray(strip) ? [] : {};
    var div = document.createElement('div');

    switch (typeof strip) {
        case 'string':
            div.innerHTML = strip;
            return div.textContent || '';
        case 'object':
            util.each(strip, (key, val) => stripped[key] = util.stripHTML(val));
            return stripped;
    }
    return strip;
};

/**
 * Recursively truncate html to a given str length
 * @param {HTMLElement} html - element whose text we want to truncate
 * @param {Int} length - the character limit we want to impose
 */
util.truncate = (html, length) => {
    // no input
    if (!html || !html.textContent || !html.textContent.length) {
        return 0;
    }
    // no html in range
    const original = html.textContent;
    const textTrunc = html.textContent.substring(0, length);
    const htmlTrunc = html.innerHTML ? html.innerHTML.substring(0, length) : null;
    if (!html.innerHTML || textTrunc === htmlTrunc) {
        html.textContent = (original === textTrunc) ? textTrunc : textTrunc.replace(/\s*$/, '') + '...';
        return textTrunc.length;
    }
    // html in range
    let chars = 0;
    util.each(html.childNodes, (i, child) => {
        if (chars >= length) {
            html.removeChild(child);
        } else {
            chars += util.truncate(child, length - chars);
        }
    });
    return html.textContent.length;
};

/**
 * @param {Function} Cls - class that should be extended with mixins
 * @param {...Object|Function} mixin - mixin object or mixin factory;
 * if it's a factory, a parent prototype is passed to it to allow calling parent methods
 * @returns A class that is a descendant of Cls and is extended with methods defined in the mixins
 * Examples of usage: see the unit tests
 */
export function decorateWithMixins(Cls, ...mixins) {
    if (!isFunction(Cls)) {
        throw new TypeError(`${Cls} is not a function`);
    }
    mixins.forEach((mixin, idx) => {
        if (mixin === undefined) {
            throw new TypeError(`Mixin at position ${idx} is undefined`);
        }
    });

    const chain = [Cls];

    mixins.forEach((mixin) => {
        const Parent = chain[0];

        class Wrapper extends Parent {}

        if (isFunction(mixin)) {
            mixin = mixin(Parent.prototype);
        }
        Object.assign(Wrapper.prototype, mixin);

        chain.unshift(Wrapper);
    });

    return chain[0];
}
util.decorateWithMixins = decorateWithMixins;

/**
 * Returns instance of unique id generator
 * @param {Number} [start=1] - initial value to increment
 * @return {Function} function that increments its counter on each call and returns that value
 */
export function idGenerator(start = 1) {
    let id = start;
    return () => id++;
}
util.idGenerator = idGenerator;

/**
 * Promise with publicly available `resolve` and `reject` methods
 * @param {Object} options
 * @param {Function} [options.unsubscribe=noop] - will be attached to the promise as `unsubscribe` method
 */
export class Deferred {
    constructor({
        unsubscribe = () => {}
    } = {}) {
        let resolve, reject;
        const promise = new Promise((resolve_, reject_) => {
            resolve = resolve_;
            reject = reject_;
        });

        promise.resolve = resolve;
        promise.reject = reject;
        promise.unsubscribe = unsubscribe;

        return promise;
    }
}
util.Deferred = Deferred;

/**
 * Whether or not a given element is in context on an infinite quiz page
 * @param {HTMLElement} element - the element whose context we care about
 * @returns {Boolean}
 */
export function moduleIsInContext(element) {
    // element is in context by default
    let isInContext = true;
    const buzzModule = closest(element, '[data-module=buzz]', true);
    // if on infinite quiz page, we are only in context if our parent buzz module matches the global buzz id
    if (document.querySelector('.infinite-posts-enabled') && buzzModule) {
        try {
            isInContext = BZFD.Context.buzz.id === getModuleConfig(buzzModule).context.buzz.id;
        } catch (err) {
            // pass
        }
    }
    return isInContext;
}
util.moduleIsInContext = moduleIsInContext;

export default util;