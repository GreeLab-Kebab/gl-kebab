import {
    isEqual
} from 'lodash';
import {
    Application,
    EventTarget
} from 't3js';


const EVENT_PREFIX = 'sticky:';
export const MEMBERS_UPDATE = `${EVENT_PREFIX}members-update`;


const PRIORITY = {
    normal: 1,
    medium: 2,
    high: 3,
};


const stickyEls = new Map();
const stickyListeners = new Map();


function notifyMembers(priority, element) {
    const evData = {
        priority
    };

    const lower = new Set();
    const lowerPriorities = new Set();
    stickyEls.forEach((settings, el) => {
        if (settings.priority > priority) {
            return;
        }
        lower.add(el);
        lowerPriorities.add(settings.priority);
    });

    // then notify publicly
    Application.broadcast(MEMBERS_UPDATE, evData);
    // notify each priority less than or equal to this
    lowerPriorities.forEach((pr) => {
        Application.broadcast(`${MEMBERS_UPDATE}:${pr}`, evData);
    });
    // notify individual subscribers
    stickyListeners.forEach((eventManager, el) => {
        // do not notify of its own changes to prevent endless update/notify loop
        if (el === element) {
            return;
        }
        // notify those whose priority is not higher (i.e. that have lower priority or are not sticky at all)
        if (stickyEls.has(el) && !lower.has(el)) {
            return;
        }
        eventManager.fire(MEMBERS_UPDATE, evData);
    });
}


function isElementFixed(element) {
    return (getComputedStyle(element).position === 'fixed');
}

/**
 * @returns Rect whose left/right coordinates are relative to document
 * and top/bottom coordinates are relative to viewport
 */
function getBoundingRect(element, isFixed) {
    if (isFixed === undefined) {
        isFixed = isElementFixed(element);
    }
    let {
        top,
        right,
        bottom,
        left,
        width,
        height
    } = element.getBoundingClientRect();
    // It's possible to determine an element's coordinates relative to document in most cases,
    // except for when it has `position: sticky`,
    // in which case we only can reliably determine left/right coordinates, but not top/bottom,
    // so don't bother with `pageYOffset`,
    // considering actual top/bottom coordinates won't be used for non-fixed elements anyway
    const xOffset = window.pageXOffset;
    if (!isFixed) {
        left += xOffset;
        right += xOffset;
    }
    return {
        top,
        right,
        bottom,
        left,
        width,
        height
    };
}


const service = {
    get defaultPriorities() {
        return PRIORITY;
    },

    MEMBERS_UPDATE,

    validatePriority(priority) {
        if (isNaN(Number(priority))) {
            if (typeof priority === 'string') {
                priority = PRIORITY[priority];
                if (priority === undefined) {
                    throw new TypeError(`Unknown priority name, should be one of ${Object.keys(PRIORITY)}`);
                }
            } else {
                throw new TypeError('Unrecognized priority, should be a number or a name');
            }
        }
        return priority;
    },

    isFixed: isElementFixed,

    getFixedRect(element, {
        priority = PRIORITY.normal,
        requestedTop = 'auto'
    } = {}) {
        priority = service.validatePriority(priority);
        const rect = getBoundingRect(element);
        let allowedTop;
        if (requestedTop === 'auto') {
            allowedTop = service.getAvailableTop(element, {
                priority,
                boundingRect: rect
            });
        } else {
            allowedTop = requestedTop;
        }

        // the element may be in the middle of a transition, and will give incorrect height spacing
        // this forces the height to be the defined height for the wireframe
        if (element.parentElement && element.parentElement.className.includes('ad-wireframe-wrapper')) {
            rect.height = parseInt(element.parentElement.getAttribute('data-wireframe-height'), 10);
        }
        // the element may not be fixed yet, but it requests the vertical space beforehand for when it becomes fixed,
        // so use its "future" top and bottom
        rect.top = allowedTop;
        rect.bottom = allowedTop + rect.height;
        return rect;
    },

    subscribe(element) {
        let eventManager = stickyListeners.get(element);
        if (eventManager) {
            return eventManager;
        }
        eventManager = new EventTarget();
        stickyListeners.set(element, eventManager);
        return eventManager;
    },

    unsubscribe(element) {
        const eventManager = stickyListeners.get(element);
        if (!eventManager) {
            return;
        }
        eventManager._handlers = {};
        stickyListeners.delete(element);
    },

    /**
     * Registers an element as sticky so its position will be taken into account
     * when other sticky elements calculate their positions
     */
    add(element, {
        priority = PRIORITY.normal,
        requestedTop = 'auto'
    } = {}) {
        if (stickyEls.has(element)) {
            return service.update(element);
        }
        priority = service.validatePriority(priority);
        const rect = service.getFixedRect(element, {
            priority,
            requestedTop
        });
        stickyEls.set(element, {
            rect,
            priority,
            requestedTop
        });
        notifyMembers(priority, element);
        return rect.top;
    },

    /**
     * Updates sticky element's dimensions and position
     */
    update(element, {
        forceNotify = false
    } = {}) {
        const settings = stickyEls.get(element);
        if (!settings) {
            throw new Error('The element is not in the registry');
        }
        const {
            priority,
            requestedTop
        } = settings;
        const oldRect = settings.rect;
        const rect = service.getFixedRect(element, {
            priority,
            requestedTop
        });
        settings.rect = rect;
        stickyEls.set(element, settings);
        // if there's no change compared to previous state, don't trigger events unless it's forced
        if (forceNotify || !isEqual(rect, oldRect)) {
            notifyMembers(priority, element);
        }
        return rect.top;
    },

    /**
     * Removes the element that is no longer sticky from the registry
     */
    remove(element) {
        const settings = stickyEls.get(element);
        if (!settings) {
            return;
        }
        // added class check, spotlight on news was being removed prematurely
        if (!element.className.includes('sticky--fixed sticky--show')) {
            stickyEls.delete(element);
        }
        notifyMembers(settings.priority, element);
    },

    /**
     */
    has(element) {
        return stickyEls.has(element);
    },

    /**
     * For a given element that already is or is willing to be sticky,
     * returns the highest possible top position it could stick at
     * considering there may be other sticky elements above the element
     */
    getAvailableTop(element, {
        priority = PRIORITY.normal,
        boundingRect
    } = {}) {
        priority = service.validatePriority(priority);
        const higher = [];
        stickyEls.forEach((settings, el) => {
            if (el !== element && settings.priority >= priority) {
                higher.push(settings);
            }
        });
        if (higher.length === 0) {
            return 0;
        }
        if (!boundingRect) {
            const savedSettings = stickyEls.get(element);
            if (savedSettings) {
                boundingRect = savedSettings.rect;
            } else {
                boundingRect = getBoundingRect(element);
            }
        }
        const stickyOverlapping = [];
        // find those sticky elements that horizontally overlap with the element because they compete for the page space
        higher.forEach(({
            rect
        }) => {
            const horOverlap = (rect.right >= boundingRect.left || rect.left <= boundingRect.right);
            if (horOverlap) {
                stickyOverlapping.push(rect);
            }
        });
        // the element is allowed to stick right below the lowest of those elements
        return Math.max(...stickyOverlapping.map(({
            bottom
        }) => bottom));
    },

    /**
     */
    getTopmostPosition(priority = PRIORITY.normal) {
        priority = service.validatePriority(priority);
        const bottoms = [];
        stickyEls.forEach((settings) => {
            if (settings.priority > priority) {
                bottoms.push(settings.rect.bottom);
            }
        });
        return Math.max(...bottoms);
    },
};

export default service;