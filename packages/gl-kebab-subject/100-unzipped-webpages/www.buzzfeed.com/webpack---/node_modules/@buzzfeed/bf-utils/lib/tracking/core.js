import zip from 'just-zip-it';

/**
 * Explicit type for function returning consumer's context
 * @typedef {Function} Context
 */

/**
 * A helper type to define object literals
 * @typedef {Object.<string, string|number>} LayerObject
 */

/**
 * Individual layer types can vary, currently supported types are:
 * - async function with an object as a return value
 * - an object
 * @typedef {LayerObject|function(Context=):(LayerObject|Promise.<LayerObject)} Layer
 */

/**
 * Generates a data object by evaluating all supplied data layers.
 * All layers are always represented as an append-only list.
 */
const eventFromLayers = async ({
    context,
    layers = []
}) => {
    let dataObj = {};
    for (let i = 0; i < layers.length; i++) {
        let layer = layers[i];
        if (typeof layer === 'function') {
            layer = await layer(context());
        }
        dataObj = { ...dataObj,
            ...layer
        };
    }
    return dataObj;
};

/**
 * Creates a builder function, which provides a way to add more data layers to an event
 * @param {Layer[]} [layers=[]] - initial data layers for an event
 * @return {Function} - function to add more data layers
 */
export const createLayerBuilder = (layers = []) =>
    (...externalLayers) => {
        layers.push(...externalLayers);
        return layers;
    };

/**
 * Creates a broadcasting function, which when called will evaluate all data layers
 * and send the resulting data structure back to the tracking upstream.
 * @param {Object} params
 * @param {Layer[]} params.layers - data layers for the event
 * @param {Function} params.broadcast - function to be called with the constructed event
 * @param {Context} [params.context] - function that provides contextual data for layers
 * @returns {Function} - when called will send a constructed event into the broadcasting function
 */
export const bindEventBroadcaster = ({
    layers,
    broadcast,
    context = () => {}
}) => {
    return async (...args) => {
        const evt = await eventFromLayers({
            context,
            layers: [...layers, ...args]
        });
        return broadcast(evt);
    };
};

/**
 * Combines multiple event functions into one.
 * Example:
 * events = [
 *   [fn0, fn1],
 *   [fn2, fn3],
 *   [fn4, fn5],
 * ]
 *
 * will be combined into a pair of functions:
 * [fnExecEven, fnExecOdd]
 */
export const combineEvents = (...events) => {
    const createExecutors = fns => {
        return (...args) => {
            fns.forEach(fn => fn(...args));
        };
    };

    return zip(...events).map(createExecutors);
};