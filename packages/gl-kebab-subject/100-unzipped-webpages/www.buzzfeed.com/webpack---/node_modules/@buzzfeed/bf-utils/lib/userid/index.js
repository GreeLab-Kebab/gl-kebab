import XDomainCookieManager from '../XDomainCookieManager';
import {
    decode,
    encode
} from '../hashing';

// in-memory new user identifier
// ensures multiple async calls return the same value when cookie does not exist initially
const idSeed = parseInt(Math.random() * 10000000000, 10);

const unhash = val => {
    if (val.indexOf('.') !== 0) {
        // This may be a V1, unhashed id
        // TODO: instrument this
        const m = /[0-9A-Za-z]+/.exec(val);
        if (m !== null && m[0] === val) {
            return parseInt(val, 36);
        } else {
            // this is not a valid id
            return false;
        }
    }

    const salt = val.substr(1, 2);
    const strId = val.substr(3);

    return decode(strId, {
        salt
    });
};

const hash = id => {
    const salt = parseInt(Math.random() * 25 + 10, 10).toString(36) +
        parseInt(Math.random() * 25 + 10, 10).toString(36);
    return `.${salt}${encode(id, { salt, length: 0 })}`;
};

const parseFromCookieValue = cookieValue => {
    const identifier = decodeURIComponent(cookieValue)
        .split('&')
        .filter(token => token.indexOf('u=') !== -1)
        .map(token => token.split('=')[1])
        .pop();

    return unhash(identifier || '');
};

export const getUserId = ({
    env,
    create = true
}) => {
    const cookieManager = new XDomainCookieManager({
        namespace: 'bf-xdomain-tracking',
        cookieName: 'bf_visit',
        daysExpiry: 10000,
        env,
    });

    return cookieManager.get()
        .then(value => {
            if (!value && create) {
                const hashedId = hash(idSeed);
                cookieManager.set(encodeURIComponent(`u=${hashedId}&v=2`));
                return idSeed;
            }

            return parseFromCookieValue(value);
        });
};

export default {
    getUserId
};