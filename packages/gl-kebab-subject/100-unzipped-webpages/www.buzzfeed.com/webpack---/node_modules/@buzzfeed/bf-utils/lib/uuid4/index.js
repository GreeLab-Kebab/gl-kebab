/**
 * Service for generating RFC4122 compliant uuid values
 * Inspired from https://gist.github.com/jed/982883
 */

/**
 * Generates a random number using crypto.getRandomValues if available, else it falls back to
 * Math.random.
 *
 * We use crypto.getRandomValues whenever possible with Math.random there's a much higher probability of getting a
 * value colision (see here https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript)
 */
const random = () => {
    try {
        return crypto.getRandomValues(new Uint8Array(1))[0];
    } catch (error) {
        return Math.random() * 255; // max 8 bit unsigned value, so it's consistent with the value generated above
    }
};

/**
 * Generates RFC4122 compliant uuid4 values
 *
 * uuid4 format looks like:
 * xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
 *
 * where:
 *  x - any hex digit, 0 through f
 *  y - hex digit from 8 through b
 *
 * For example: 32e34052-dfc2-43ea-8683-417815ef5eaa
 *
 * How it works:
 * - it first generates a string like 10000000-1000-4000-8000-100000000000
 * - it then replaces any 0,1 or 8 character with:
 *    - if the character is not an 8 it is replaced with a random number between 0 and 16
 *    - if it is 8 it replaced it with a random number between 8 and 11
 * - it then converts each number generated in the previous step to a base 16 number returned as a string (0 through f)
 *
 * Note: in javascript bitwise operators work in 32 bit integers, that means that all the operands converted to ints
 *
 * c ^ (random() & (15 >> c / 4)) explained:
 *
 * We start with a string like 10000000-1000-4000-8000-100000000000 and replace all 0, 1 and 8 characters using the
 * formula above
 *
 * - if c is 0 or 1, this is equivalent to
 *   c ^ (random() & 15)
 *
 *   The 2nd part of this expression (random() & 15) ensures that no matter how big the random number is the returned
 *   value will be limited to 15 (all bits except last 4 will be set to 0). Assuming random() is 93, this is equivalent
 *   to:
 *
 *   0 1 0 1   1 1 0 1  &
 *   0 0 0 0   1 1 1 1
 *   -----------------
 *   0 0 0 0   1 1 0 1  (13)
 *
 *   The first part of the expression becomes c ^ 13 . Assuming c is 1, this is equivalent to
 *   0 0 0 0   0 0 0 1  ^
 *   0 0 0 0   1 1 0 1
 *   -----------------
 *   0 0 0 0   1 1 0 0  (12)
 *
 *   The first part only has an important role for the scenario, where c = 8.
 *  - if c is 8, the formula is:
 *   c ^ (random() & 3)
 *
 *   The 2nd part of the expression now can have a max value of 3 (all bits except last 2 are set to 0).Assuming again
 *   random() is 93, this is equivalent to:
 *   0 1 0 1   1 1 0 1  &
 *   0 0 0 0   0 0 1 1
 *   -----------------
 *   0 0 0 0   0 0 0 1  (1)
 *
 *
 *   The first part of the expression (the exclusive OR) now acts like an addition here to ensure the value is
 *   between 8 and 11 (between 8 + 0 and 8 + 3). This happens because
 *   - 8 only has the 4rd bit from the end set to 1
 *   - 0, 1, 2, and 3 only have the last 2 bits set to 1
 *   This is equivalent to:
 *   0 0 0 0    1 0 0 0  ^
 *   0 0 0 0    1 0 0 1
 *   ------------------
 *   0 0 0 0    1 0 0 1  (9)
 *
 * More details can be found here: https://gist.github.com/jed/982883
 */
export default () => {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
        (c ^ (random() & (15 >> c / 4))).toString(16)
    );
};