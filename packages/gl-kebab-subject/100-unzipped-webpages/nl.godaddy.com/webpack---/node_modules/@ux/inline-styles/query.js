const hasOwnProperty = Object.prototype.hasOwnProperty;
const delimiter = /_|-/;

export default class Query {
    constructor(vars) {
        this.load(vars);
    }

    /**
     * Initializes (or re-initializes) with the JSON representation
     * of the palette (i.e. fonts & colors).
     *
     * @param  {Object} vars JSON representation of the palette
     * @public
     */
    load(vars) {
        //
        // Mimic the logic within @ux/scss-definitions
        // - marketFonts: set of all font groups (e.g. brand, mangal, etc)
        // - marketGroups: mapping of language to key in marketFonts (e.g. "mr" => "mangal")
        //
        this.marketFonts = vars.marketFonts;
        this.marketGroups = vars.marketGroups;
        this.colors = vars.colors || vars.paletteColors;
    }

    /**
     * Transform a locale into iso639.
     *
     * @param {String} locale Locale to transform.
     * @returns {Array} Split locale, iso639.
     * @public
     */
    iso639(locale) {
        if (!locale) {
            return [];
        }
        return locale.split(delimiter);
    }

    /**
     * Returns the grouping name within the marketFonts lookups which are indexed
     * according to IETF language tags. If no group exists in marketGroups, 'brand'
     * is returned. (see: https://en.wikipedia.org/wiki/IETF_language_tag)
     *
     * e.g. zh-CN is composed of two distinct parts (or subtags):
     * 1. zh represents the **primary language subtag** (Chinese) from ISO-639
     *    (see: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)
     * 2. CN represents the **region subtag** (China) from ISO-3166-1 alpha-2
     *    (see: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     *
     * @param  {String} lang   Primary language subtag
     * @param  {String} region Region subtag
     * @returns {String} Name of the market group within marketFonts to provide.
     * @public
     */
    marketGroup(lang, region) {
        const group = this.marketGroups[lang];

        if (typeof group === 'string') {
            return group;
        }
        if (typeof group === 'object' && hasOwnProperty.call(group, region)) {
            return group[region];
        }

        return 'brand';
    }

    /**
     * Returns the market font information for the specified locale.
     *
     * @param  {String} locale IETF language tag for the locale (e.g. zh-SG).
     * @returns {Object} Object describing the font information for the locale
     * @public
     */
    marketFont(locale) {
        let [lang, region] = this.iso639(locale);
        if (region) {
            region = region.toLowerCase();
        }

        if (hasOwnProperty.call(this.marketFonts, lang)) {
            return this.marketFonts[lang];
        }

        const group = this.marketGroup(lang, region);
        return this.marketFonts[group];
    }

    /**
     * Retrieve typefaces based on device locale.
     *
     * @param {String} type primary or base.
     * @param {String} locale Locale of we want to use for the font.
     * @returns {Object} correct font names && weight for the given locale.
     * @public
     */
    font(type = 'base', locale = 'en_US') {
        const fontStack = this.marketFont(locale);

        if (type === 'primary') {
            type = 'primary-bold';
        }

        let font = fontStack[type];

        if (!font && type === 'marketing') {
            font = fontStack['primary-bold'];
        }

        return {
            fontFamily: font.family,
            fontWeight: font.weight
        };
    }

    /**
     * Retrieve hexidecimal color from UXCore2 color palette.
     *
     * @param {String} paletteName Palette name.
     * @param {String} tone Tone variation.
     * @param {String} color Variant (eg: contrast for text or color)
     * @returns {String} Color.
     * @public
     */
    palette(paletteName, tone = 'base', color = 'color') {
        if (!hasOwnProperty.call(this.colors, paletteName)) {
            return null;
        }

        if (!hasOwnProperty.call(this.colors[paletteName], tone)) {
            return null;
        }

        return this.colors[paletteName][tone][color];
    }
}




// WEBPACK FOOTER //
// ./node_modules/@ux/inline-styles/query.js