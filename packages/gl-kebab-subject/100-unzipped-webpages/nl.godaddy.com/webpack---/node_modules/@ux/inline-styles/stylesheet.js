import {
    breakpoints
} from '@ux/component';

const points = breakpoints.specification.map(spec => spec.name);
const hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Get style properties through a dot separated string.
 *
 * @param {Object} styles Source stylesheet.
 * @param {String} path Path to target property.
 * @param {Object} pathArguments The arguments to use if any styles are functions
 * @returns {Object} Reference to requested stylesheet property.
 * @private
 */
function get(styles, path = '', pathArguments = {}) {
    const props = path.split('.');

    if (!styles[props[0]]) return;

    for (let i = 0; i < props.length; i++) {
        const key = props[i];

        if (!hasOwnProperty.call(styles, key)) return;
        styles = styles[key];
        if (typeof styles === 'function') {
            styles = styles.apply(null, pathArguments[key] || []);
        }
    }

    return styles;
}

/**
 * Copy properties from source to target.
 *
 * @param {Object} source Stylesheet properties to be copied
 * @param {Object} target To contain copied stylesheet properies.
 * @returns {Object} Target styles
 * @private
 */
function copy(source, target) {
    for (const key in source) {
        if (hasOwnProperty.call(source, key)) target[key] = source[key];
    }

    return target;
}

/**
 * Recursive freeze of object(s) in stylesheet.
 *
 * @param {Object} styles Source stylesheet.
 * @returns {Object} Frozen stylesheet
 * @private
 */
function freeze(styles) {
    for (const key in styles) {
        if (hasOwnProperty.call(styles, key) && typeof styles[key] === 'object') freeze(styles[key]);
    }

    return Object.freeze(styles);
}

/**
 * Breakpoint aware recursive clone, minimal features as source styles are strings, objects or arrays.
 *
 * @param {Object|Array} obj Collection of properties to be cloned.
 * @param {String} breakpoint Clone object that is identified by breakpoint.
 * @returns {Object|Array} cloned object.
 * @private
 */
function clone(obj, breakpoint) {
    if (!obj) return;

    return Object.keys(obj).reduce((memo, key) => {
        const value = obj[key];
        const cloneable = value && typeof value === 'object' && !value._preserved;

        //
        // Clone shallow when a breakpoint is specified, only use matching objects.
        //
        if (cloneable && breakpoint) {
            if (key === breakpoint) {
                copy(value, memo);
            }

            return memo;
        }

        memo[key] = cloneable ? clone(value) : value;

        return memo;
    }, Array.isArray(obj) ? [] : Object.create(null));
}

/**
 * Immutable stylesheet definition.
 *
 * Example:
 *   ```
 *   new StyleSheet({
 *     button: {
 *      width: '100%',
 *
 *    }
 *   })
 *   ```
 *
 * @class StyleSheet
 * @param {Function} source Callable source reference.
 * @public
 */
export default class StyleSheet {
    constructor(styles) {
        //
        // Store copied source and media specific styling on instance and make the objects immutable.
        //
        this.styles = freeze(
            clone(styles)
        );
    }

    /**
     * Define breakpoint specific styles. Returned object should be spread on the source object
     * and will be have a `_[breakpoint]` identifier.
     *
     * Example:
     *   ```
     *   {
     *     ...StyleSheet.select({
     *       'mobile|phablet': {
     *         width: '75%',
     *         margin: 0
     *       }
     *     })
     *   }
     *   ```
     *
     * @param {Object} variety Breakpoint specific styling.
     * @returns {Object} Reduced collection of breakpoint specific styles.
     * @public
     */
    static select(variety) {
        return points.reduce(function select(memo, point) {
            const src = Object.keys(variety).filter(key => ~key.indexOf(point))[0];

            if (src) memo[`_${point}`] = variety[src];

            return memo;
        }, {});
    }

    /**
     * Lock the provided value so that the literal object is always returned in the result styles.
     * Useful for styles that expect values as object such as react-native's shadowOffset and textShadowOffset
     *
     * Example:
     *   ```
     *   {
     *     shadowRadius: 2,
     *     shadowOffset: StyleSheet.preserve({
     *       width: 0,
     *       height: 1
     *     })
     *   }
     *   ```
     *
     * @param {Object} value style value to preserve
     * @returns {Object} Preserved value for inclusion in the Stylesheet definition
     * @public
     */
    static preserve(value) {
        return Object.defineProperty(value, '_preserved', {
            value: true,
            enumerable: false
        });
    }

    /**
     * Reduce style objects
     *
     * @param {Array} styles Objects containing styles.
     * @returns {Object} Reduced collection of styles.
     * @private
     */
    query(...styles) {
        return styles.reduce(function query(memo, style) {
            return copy(clone(style, `_${breakpoints.breakpoint}`), memo);
        }, {});
    }

    /**
     * Get mutable styles from source stylesheet.
     *
     * @param {String} path Path to target property.
     * @param {Object} pathArguments The arguments to any path segments that are functions, keyed off the path segment
     * @returns {undefined|Object} mutable styles.
     * @public
     */
    get(path, pathArguments = {}) {
        const style = get(this.styles, path, pathArguments);

        if (!style) return;

        //
        // Return styles from cloned source. This is required to prevent
        // nested objects from being immutable or exposing the source.
        //
        const query = this.query.bind(this);
        return Object.defineProperty(query(style), 'merge', {
            enumerable: false,

            /**
             * Proxy to merge properties and update the current style property.
             *
             * @param {Array} styles Style properties to merge.
             * @returns {Style} fluent interface.
             * @public
             */
            value: function merge(...styles) {
                copy(query(...styles), this);

                return this;
            }
        });
    }
}



// WEBPACK FOOTER //
// ./node_modules/@ux/inline-styles/stylesheet.js