import addListener from 'hearing-aid';

/**
 * Collection of event names we need to listen on.
 *
 * @type {Array}
 * @public
 */
export const events = [];

/**
 * Detect browser based events.
 *
 * @private
 */
function browser() {
    const element = document.createElement('div');
    const style = element.style;

    const tests = {
        transitionend: {
            transition: ['transitionend'],
            WebkitTransition: ['webkitTransitionEnd'],
            MozTransition: ['mozTransitionEnd'],
            OTransition: ['oTransitionEnd', 'otransitionend'],
            msTransition: ['MSTransitionEnd']
        },

        animationend: {
            animation: ['animationend'],
            WebkitAnimation: ['webkitAnimationEnd'],
            MozAnimation: ['mozAnimationEnd'],
            OAnimation: ['oAnimationEnd'],
            msAnimation: ['MSAnimationEnd']
        }
    };

    //
    // On some platforms, in particular some releases of Android 4.x,
    // the un-prefixed "animation" and "transition" properties are defined on the
    // style object but the events that fire will still be prefixed, so we need
    // to check if the un-prefixed events are usable, and if not remove them
    // from the map.
    //
    if (!('AnimationEvent' in window)) {
        delete tests.animationend.animation;
    }

    if (!('TransitionEvent' in window)) {
        delete tests.transitionend.transition;
    }

    for (const name in tests) {
        if (Object.prototype.hasOwnProperty.call(tests, name)) {
            const transitionEvents = tests[name];

            for (const prop in transitionEvents) {
                if (prop in style) {
                    Array.prototype.push.apply(events, transitionEvents[prop]);
                    break;
                }
            }
        }
    }
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    browser();
}

/**
 * Assign a bunch of transition event listeners.
 *
 * @param {Element} node DOM element we need to assign things upon.
 * @param {Function} fn Callback for the event.
 * @returns {Array} Remove listeners function.
 * @public
 */
export default function on(node, fn) {
    //
    // It is possible that some of these events are not supported in the browser
    // so we want to call the callback as soon as possible so we can continue
    // without any animations and UI disruptions.
    //
    if (!events.length) {
        setTimeout(fn, 0);

        return [function() { /* does nothing intentionally */ }];
    }

    return events.map(event => {
        return addListener(node, event, fn);
    });
}



// WEBPACK FOOTER //
// ./node_modules/@ux/transition/transition-events.js