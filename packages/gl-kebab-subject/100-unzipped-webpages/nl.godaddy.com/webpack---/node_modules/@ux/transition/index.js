/* eslint react/no-find-dom-node: 1 */

import Component from '@ux/component';
import on from './transition-events';
import React from 'react';
import PropTypes from 'prop-types';

const transitionProps = {
    children: PropTypes.node, // the thing to animate.
    className: PropTypes.string, // additional classNames.
    animate: PropTypes.bool, // should we animate.
    in: PropTypes.bool, // transition in or out.
    remove: PropTypes.bool, // remove from DOM after exit.
    appear: PropTypes.bool, // start with transition.

    exited: PropTypes.string, // className to start exiting.
    exiting: PropTypes.string, // className to exit with.
    entered: PropTypes.string, // className when transitioned in.
    entering: PropTypes.string, // className when transition start.

    onExit: PropTypes.func, // callback when we're starting exit.
    onExiting: PropTypes.func, // callback when exiting class is added.
    onExited: PropTypes.func, // callback when exit transition completes.

    onEnter: PropTypes.func, // callback when we're starting enter.
    onEntering: PropTypes.func, // callback when start.
    onEntered: PropTypes.func
};


/**
 * Simple Transition helper.
 *
 * @constructor
 * @public
 */
export default class Transition extends Component {
    constructor(props) {
        super(...arguments);

        let state;

        if (props.in) {
            state = props.appear ?
                Transition.EXITED :
                Transition.ENTERED;
        } else {
            state = props.remove ?
                Transition.UNMOUNTED :
                Transition.EXITED;
        }

        this.state = {
            readyState: state
        };
    }

    /**
     * The component is mounted, check if we need to start with animation.
     *
     * @private
     */
    componentDidMount() {
        if (this.props.appear && this.props.in) {
            this.performEnter();
        }
    }

    /**
     * Check if we need to re-render.
     *
     * @param  {Object} prevProps Previous set of properties set on this instance.
     * @private
     */
    componentDidUpdate(prevProps) {
        let forceChildrenUpdate = false;
        const state = this.state.readyState;

        // Only want to call this block if props have been changed
        if (this.havePropsChanged(this.props, prevProps)) {
            if (this.props.in && prevProps.remove) {
                if (state === Transition.UNMOUNTED) {
                    this.setState({
                        readyState: Transition.EXITED
                    });
                }
            } else {
                forceChildrenUpdate = true;
            }
        }

        if (this.props.remove && state === Transition.EXITED) {
            if (this.props.in) {
                this.performEnter();
            } else {
                this.setState({
                    readyState: Transition.UNMOUNTED
                }); // eslint-disable-line react/no-did-update-set-state
            }
            return;
        }

        if (forceChildrenUpdate) {
            this.debug('update forced');

            if (this.props.in) {
                if (state === Transition.EXITING || state === Transition.EXITED) {
                    this.performEnter();
                }
            } else if (state === Transition.ENTERING || state === Transition.ENTERED) {
                this.performExit();
            }
        }
    }

    /**
     * Helper function to determine if any props have been changed
     * @param {Object} props current props object
     * @param {Object} prevProps previous props object
     * @returns {boolean} whether props have changed
     */
    havePropsChanged(props, prevProps) {
        for (const prop in transitionProps) {
            if (transitionProps.hasOwnProperty(prop) && props[prop] !== prevProps[prop]) {
                return true;
            }
        }
        return false;
    }

    /**
     * Perform the enter sequence of readyState change events.
     *
     * @private
     */
    performEnter() {
        this.debug('performEnter');
        this.lifeCycleCallback('enter');

        this.readyStateChange('entering', () => {
            this.transitionEnd(() => {
                this.readyStateChange('entered');
            });
        });
    }

    /**
     * Perform the exit sequence of readyState change events.
     *
     * @private
     */
    performExit() {
        this.debug('performExit');
        this.lifeCycleCallback('exit');

        this.readyStateChange('exiting', () => {
            this.transitionEnd(() => {
                this.readyStateChange('exited');
            });
        });
    }

    /**
     * Register and cleanup transitionEnd listeners.
     *
     * @param {Function} fn Callback for when the transition has ended.
     * @api private
     */
    transitionEnd(fn) {
        const node = this.node;

        const listeners = on(node, () => {
            this.debug('transitionEnd triggered');

            //
            // Iterate over all assigned listeners and remove them again to prevent
            // leaving event listeners behind as it's possible that we've assigned
            // multiple event listeners.
            //
            listeners.filter(remove => {
                remove();

                return false;
            });

            fn();
        });
    }

    /**
     * Trigger a readyState change
     *
     * @param {String} name The new readyState that this component should receive
     * @param {Function} fn Completion callback for when the new state is set.
     * @private
     */
    readyStateChange(name, fn) {
        const readyState = name.toUpperCase();

        this.debug('changing readyState to %s', name);

        this.setState({
            readyState: Transition[readyState]
        }, () => {
            this.lifeCycleCallback(name);

            if (fn) {
                fn();
            }
        });
    }

    /**
     * Optionally trigger a life cycle based callback if it's defined by the user.
     * It automatically triggers it in a `on{Name}` based name. So name `foo` is
     * transformed to `onFoo`.
     *
     * @param {String} name Name of the even that needs to be trigged.
     * @public
     */
    lifeCycleCallback(name) {
        const event = 'on' + name[0].toUpperCase() + name.substr(1);

        if (event in this.props) {
            this.props[event](this.node);
        }
    }

    /**
     * Render all the animations.
     *
     * @returns {Null|React.Component} Cloned child element with new classNames.
     * @private
     */
    render() {
        const child = React.Children.only(this.props.children);
        const readyState = this.state.readyState;

        //
        // Remove the component after the transition has been completed.
        //
        if (readyState === Transition.UNMOUNTED && this.props.remove) {
            this.debug('Unmounted and set to removal');
            return null;
        }

        //
        // We don't want to have the component animated, so we're not going to apply
        // the supplied classes and just return an un-modified child component.
        //
        if (!this.props.animate) {
            this.debug('The animate prop is set to false, bailing out');
            return child;
        }

        return React.cloneElement(child, {
            className: this.classNames(child.props.className, this.props.className, {
                [this.props.exited]: readyState === Transition.EXITED,
                [this.props.exiting]: readyState === Transition.EXITING,
                [this.props.entered]: readyState === Transition.ENTERED,
                [this.props.entering]: readyState === Transition.ENTERING
            }),

            /**
             * This is the part where it gets tricky, we need to have access to
             * a ref so we can access the DOM node. We can't just blindly override
             * the ref as that would kill any ref that was oringally provided on
             * the child element. So we need to mimic the React internal ref
             * handling of React so we can process any possible child ref.
             *
             * @see https://github.com/facebook/react/issues/8873
             * @param {Element} node Reference to the DOM node.
             * @private
             */
            ref: (node) => {
                const {
                    ref
                } = child;
                this.node = node;

                if (typeof ref === 'function') {
                    ref(node);
                } else if (ref !== null) {
                    ref.current = node;
                }
            }
        });
    }
}

/**
 * Property validation.
 *
 * @type {Object}
 * @public
 */
Transition.propTypes = transitionProps;

//
// The different states a transition can be in.
//
Transition.states = [
    'UNMOUNTED', 'EXITED', 'EXITING', 'ENTERING', 'ENTERED'
].map(function map(name, index) {
    Transition[name] = index;
    return name;
});

/**
 * The default properties of this component.
 *
 * @type {Object}
 * @public
 */
Transition.defaultProps = {
    appear: false,
    animate: true,
    in: true
};



// WEBPACK FOOTER //
// ./node_modules/@ux/transition/index.js