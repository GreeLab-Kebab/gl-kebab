/* eslint no-undefined: 0*/

import Component, {
    eventdist,
    target,
    EventDistContext,
    EventDistShape,
    withEventDistContext
} from './component';
import breakpoints from './breakpoints';
import debug from 'diagnostics';

//
// We pre-assign an event listener. This has one major drawback and that is that
// we always assign an resize listen even when it's not needed or used by
// components. But the added benefit is that if we have multiple components
// listening, we don't do viewport comparison x amount of times. Another reason
// is that breakpoints.changed() will only evaluate to `true` once. So if we
// have multiple components listening to resize and checking for changes only
// one them will actually see it as changed.
//
eventdist.on('resize', function resized() {
    if (!breakpoints.changed()) return;

    eventdist.emit('breakpoint:' + breakpoints.breakpoint);
    eventdist.emit('breakpoint:changed', breakpoints.breakpoint);
});

/**
 * The default component that extends React.Component so we can force the
 * Component interface and prevent React.createClass usage.
 *
 * @displayName Component (Web)
 * @constructor
 * @public
 */
export default class WebComponent extends Component {
    /**
     * Helper function to create and manage an array of classNames.
     *
     * @returns {String|Undefined} Concatenated result of classNames.
     * @public
     */
    classNames(...names) {
        const result = names
            .filter(Boolean)
            .reduce((memo, className) => {
                if (typeof className === 'string' && ~className.indexOf(' ')) {
                    className = className.split(' ');
                }

                if (Array.isArray(className)) {
                    Array.prototype.push.apply(memo, this.classNames(...className).split(' '));
                } else if (typeof className === 'object') {
                    Object.keys(className).forEach(function each(key) {
                        //
                        // In object mode we want to optionally enable or disable classNames
                        // based on boolean values for the keys. We're not going to be too
                        // strict on true and false as we want things like `undefined` and
                        // `null` to also trigger removal.
                        //
                        if (className[key]) {
                            memo.push(key);
                        } else if (~memo.indexOf(key)) {
                            memo.splice(memo.indexOf(key), 1);
                        }
                    });
                } else {
                    memo.push(className);
                }

                return memo;
            }, [])
            .filter(function filter(item, i, all) {
                return Boolean(item) && all.indexOf(item) === i;
            })
            .join(' ');

        //
        // If we return an empty string and directly pass it in to the className
        // property of a React component we will add an empty attribute to the
        // element. Returning `undefined` ensures that no empty property is added.
        //
        // The undefined value is also still accepted as value for the `classNames`
        // method so the resulting className can still be manipulated afterwards.
        //
        return result ? result : undefined;
    }

    /**
     * Check if we are running in a TRUE browser (i.e. **NOT** Node.js)
     * environment. This will only return true in REAL browser environments
     * (i.e. not `jsdom`). The navigator object will toString as '[object Navigator]'
     * instead of '[object Object]' if it was a leaked Node.js global.
     *
     * *NOTE:* This will return true in PhantomJS environments and other headless
     * browsers since those are, in fact, REAL browsers in the strict sense.
     *
     * @returns {Boolean} Is this a browser
     * @public
     */
    get isBrowser() {
        return typeof navigator !== 'undefined' && Object.prototype.toString.call(navigator) === '[object Navigator]';
    }

    /**
     * Helper function to set style.display = 'block'.
     *
     * @returns {Object} style object.
     * @public
     */
    get show() {
        return this.display(true);
    }

    /**
     * Helper function to set style.display = 'none'.
     *
     * @returns {Object} style object.
     * @public
     */
    get hide() {
        return this.display(false);
    }

    /**
     * Helper function to display components. By default sets `display` to 'block'.
     *
     * @param {Object} style Mutable style object.
     * @param {Boolean} show Should style become visible or not.
     * @returns {Object} style object.
     * @public
     */
    display(style, show = true) {
        if (typeof style === 'boolean') {
            show = style;
            style = {};
        }

        style.display = show ? 'block' : 'none';
        return {
            style
        };
    }

    /**
     * Calculate the component's offset relative to the window.
     *
     * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
     * @returns {Object} left and top offsets.
     * @public
     */
    offset(ref) {
        const rect = ref.getBoundingClientRect();

        return {
            left: rect.left + target.pageXOffset - target.document.documentElement.clientLeft,
            top: rect.top + target.pageYOffset - target.document.documentElement.clientTop
        };
    }

    /**
     * Assign an new event listener to the body element that only triggers if the
     * event target is outside the provided reference DOM Node.
     *
     * @param {String} event Event name.
     * @param {Function} fn Completion callback function.
     * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
     * @returns {Component} Returns self for chaining purposes.
     * @public
     */
    outside(event, fn, ref) {
        /**
         * Trigger the listener if the clicked target does not contain the
         * HTML/Component reference.
         *
         * @param {Event} e Browser event.
         * @private
         */
        function trigger(e) {
            if (ref && !ref.contains(e.target)) fn(e, trigger);
        }

        this.eventdist.on(event, trigger, this);
        return trigger;
    }

    /**
     * Returns a value indicating that the specified `ref` is out of the viewport in
     * a given direction +ve or -ve pixels. If the `ref` is within the viewport then
     * returns 0.
     *
     * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
     * @returns {Number|undefined} Number of pixels document.body.scrollTop must be modified by
     * @public
     */
    outOfViewport(ref) {
        const rect = ref.getBoundingClientRect();
        if (rect.top < 0) {
            return rect.top;
        }

        const height = window.innerHeight || document.documentElement.clientHeight;
        if (rect.bottom > height) {
            return rect.bottom - height;
        }

        return 0;
    }

    /**
     * Scroll the current element into the visible area of the browser window if not there.
     * If the element is already within the visible area of the browser window, then do not scroll.
     *
     * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
     * @public
     */
    scrollIntoViewIfNeeded(ref) {
        const outOf = this.outOfViewport(ref);
        if (!outOf) {
            return;
        }

        // WebKit & Blink have this native method.
        if (ref.scrollIntoViewIfNeeded) {
            ref.scrollIntoViewIfNeeded(false);
            return;
        }

        //
        // TODO (crobbins, jkeslin): do we still need this in this implementation?
        //
        // // If the menu itself is statically positioned, we need to take that into account
        // if (ref.offsetParent !== ref.parentNode) {
        //   top -= activeItem.parentNode.offsetTop;
        // }

        //
        // Remark (crobbins): MDN suggests checking if `typeof body.scrollTop === 'number'`
        // but based on empirical evidence that documentation is simply wrong. Other sources
        // around the Internetz suggest that when the value is 0 `document.body` should be used.
        // (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)
        //
        let body = document.documentElement || document.body.parentNode;
        if (body.scrollTop === 0) {
            body = document.body;
        }

        body.scrollTop = body.scrollTop + outOf;
    }
}

//
// Export our utilized internals in various ways so they can be imported as
// standalone functionality through the `import {debug} from 'component'`
// syntax as well as access them directly through the exposed Component
// constructor. This allows build systems to optimize and remove dead code if
// needed.
//
export {
    debug,
    eventdist,
    breakpoints,
    EventDistContext,
    EventDistShape,
    withEventDistContext
};

WebComponent.debug = debug;
WebComponent.eventdist = eventdist;
WebComponent.breakpoints = breakpoints;
WebComponent.EventDistContext = EventDistContext;
WebComponent.EventDistShape = EventDistShape;
WebComponent.withEventDistContext = withEventDistContext;



// WEBPACK FOOTER //
// ./node_modules/@ux/component/index.js