import validateComponents from 'react-component-validator';
import Component from '@ux/component';
import React from 'react';
import PropTypes from 'prop-types';
import rip from 'rip-out';
import Tab from './tab';

//
// Control attributes.
//
const directions = {
    prev: {
        side: 'left',
        step: -1
    },
    next: {
        side: 'right',
        step: 1
    }
};

/**
 * Render a default set of tabs used with each Component.
 *
 * @class TabIndex
 * @displayName Tab Index
 * @public
 */
export default class TabIndex extends Component {
    constructor() {
        super(...arguments);

        //
        // Move the conveyor through margin left styling.
        //
        this.state = {
            ...this.state,
            conveyorMarginLeft: 0
        };

        this.defaultStepSize = 200;
    }

    /**
     * Add eventListeners for breakpoints and force a single rerender which
     * is required to pickup on the actual width of the conveyor in relation to the
     * combined width of all childs. This renders the conveyor controls if required.
     *
     * @private
     */
    componentDidMount() {
        this.breakpoint('tablet', 'desktop', 'large', 'xlarge');
        this.forceUpdate();
    }

    /**
     * Remove the eventListeners of breakpoints.
     *
     * @private
     */
    componentWillUnmount() {
        this.breakup();
    }

    /**
     * Step size used to in- or decrement the conveyor position. Can also be provided
     * through properties on TabIndex.
     *
     * @returns {number} Step size
     * @public
     */
    get stepSize() {
        if (!this.props || !this.props.stepSize) return this.defaultStepSize;

        return this.props.stepSize;
    }

    /**
     * Increment or decrement the conveyor steps within bounds.
     * Bounds are: [0, this.tabsExceededWidth].
     *
     * @param {string} direction Previous or next control
     * @returns {Function} Event handler
     * @private
     */
    moveConveyor(direction) {
        return event => {
            event.preventDefault();

            const margin = this.state.conveyorMarginLeft;
            const absMargin = Math.abs(margin);
            let step = this.stepSize;

            if (direction === 'prev' && absMargin < step) {
                step = absMargin;
            } else if (direction === 'next' && this.tabsExceededWidth - absMargin < step) {
                step = this.tabsExceededWidth - absMargin;
            }

            this.setState({
                conveyorMarginLeft: margin + -directions[direction].step * step
            });
        };
    }

    /**
     * Calculate the amount of by which the tabs exceed the width of the conveyor.
     *
     * @returns {number} Exceeded width in pixels
     * @private
     */
    get tabsExceededWidth() {
        const tabindex = this.conveyor;
        let tabs = this.tabs;
        let sum = 0;
        let n;

        if (!tabindex || !tabs) {
            return sum;
        }

        tabs = Array.prototype.map.call(tabs.childNodes, tab => {
            var tabStyles = window.getComputedStyle(tab);

            return parseFloat(tabStyles.width) +
                parseFloat(tabStyles.marginLeft) +
                parseFloat(tabStyles.marginRight);

        });
        n = tabs.length;

        while (n--) {
            sum += tabs[n];
        }

        return sum - parseFloat(window.getComputedStyle(tabindex).width);
    }

    /**
     * Check if controls should be visible or hidden.
     *
     * @param {string} side Previous or next control
     * @returns {Object} Display style
     */
    conveyorArrowStyle(side) {
        const {
            breakpoint,
            conveyorMarginLeft
        } = this.state;
        const width = this.tabsExceededWidth;

        if (!~['large', 'desktop', 'xlarge'].indexOf(breakpoint)) {
            return this.hide.style;
        } else if (side === 'prev' && conveyorMarginLeft || side === 'next' && width !== Math.abs(conveyorMarginLeft) && width > 0) {
            return {
                display: 'flex'
            };
        }

        return this.hide.style;
    }

    /**
     * Get attributes that are required for conveyor controls.
     *
     * @param {string} direction Previous or next control
     * @returns {Object} Control attributes
     * @private
     */
    controlAttributes(direction) {
        return {
            'className': [directions[direction].side, 'ux-conveyor-control'].join(' '),
            'style': this.conveyorArrowStyle(direction),
            'onClick': this.moveConveyor(direction),
            'data-slide': direction,
            'role': 'button',
            // eslint-disable-next-line no-script-url
            'href': 'javascript:void(0);'
        };
    }

    /**
     * Render the TabIndex Component.
     *
     * @returns {React.DOM} conveyor clipping div element with children
     * @private
     */
    render() {
        const props = this.props;
        const {
            breakpoint,
            conveyorMarginLeft
        } = this.state;
        const other = rip(props, 'stepSize', 'selected', 'change', 'contentIds');

        const marginLeftStyle = {};

        // Only add the marginLeft if we're on large/desktop breakpoints (prevents scrolling from breaking on small devices)
        if (~['large', 'desktop', 'xlarge'].indexOf(breakpoint)) {
            marginLeftStyle.marginLeft = conveyorMarginLeft;
        }

        return ( <
            div className = 'ux-conveyor-clip' >
            <
            a { ...this.controlAttributes('prev')
            }
            aria - label = 'previous' >
            <
            span className = 'sr-only' > Previous < /span> <
            /a>

            <
            div { ...other
            }
            ref = {
                ref => {
                    this.conveyor = ref;
                }
            }
            className = 'ux-conveyor' >
            <
            ul className = 'nav nav-tabs'
            ref = {
                ref => {
                    this.tabs = ref;
                }
            }
            style = {
                marginLeftStyle
            }
            role = 'tablist' > {
                React.Children.map(props.children, (child, i) => React.cloneElement(child, {
                    onClick: props.change.bind(null, i),
                    selected: props.selected === i,
                    ariaControls: props.contentIds[i]
                }))
            } <
            /ul> <
            /div>

            <
            a { ...this.controlAttributes('next')
            }
            aria - label = 'next' >
            <
            span className = 'sr-only' > Next < /span> <
            /a> <
            /div>
        );
    }
}

/**
 * Validate that the passed children are of type Tab.
 *
 * @enum {Object} expected types of properties.
 * @api public
 */
TabIndex.propTypes = {
    /** Increments or decrements the conveyor position */
    stepSize: PropTypes.number,
    /** Function called when selection changes */
    change: PropTypes.func,
    /** Index of selected tab */
    selected: PropTypes.number,
    /** Child tab */
    children: validateComponents([Tab]),
    /** IDs of linked tab contents */
    contentIds: PropTypes.array
};



// WEBPACK FOOTER //
// ./node_modules/@ux/tabs/tab-index.js