import {
    NamespaceConsumer,
    withNamespace,
    NamespaceShape
} from '@ux/namespace-component';
import {
    TransitionGroup,
    CSSTransition
} from 'react-transition-group';
import GrowlMessage from './growl-message';
import PropTypes from 'prop-types';
import React from 'react';

/**
 * The next number for unique message id
 *
 * @type {number}
 * @private
 */
let _msgId = 0;

/**
 * The Growl component.
 *
 * @displayName Growl
 * @class Growl
 * @public
 */
class Growl extends NamespaceConsumer {
    constructor() {
        super(...arguments);

        this._fadeTimers = {};
        this.state = {
            ...this.state,
            messages: []
        };
    }

    componentDidMount() {
        if (!global.growlInstance) {
            global.growlInstance = this;
        } else {
            // eslint-disable-next-line
            try {
                console.error('Growl can only have one active instance.');
            } catch (e) {}
        }
    }

    /**
     * React lifecycle hook invoked when component is about to unmount.
     *
     * @private
     */
    componentWillUnmount() {
        this._clearMessages();

        if (this === global.growlInstance) {
            global.growlInstance = null;
        }
    }

    /**
     * Adds new message based on provided config options.
     *
     * @param {object}  config            Configuration
     * @param {string}  config.title      Title
     * @param {string}  config.content    Description
     * @param {string}  [config.icon]     Icon
     * @param {boolean} [config.fade]     Fade
     * @param {number}  [config.fadeTime] Fade time in milliseconds
     * @private
     */
    _addMessage(config) {
        const msgProps = this._setupMessage(config);

        const messages = this.state.messages.slice(0);
        messages.push(msgProps);
        if (msgProps.fade) {
            this._startFade(msgProps.id, msgProps.fadeTime);
        }

        this.setState({
            messages
        });
    }

    /**
     * Sets up callback and props for new GrowlMessage.
     *
     * @param {object} config Message config
     * @returns {object} msgProps Props used for a GrowlMessage
     * @private
     */
    _setupMessage(config) {
        const id = `GrowlMsg_${_msgId++}`;

        const msgProps = {
            id,
            fade: true,
            onClose: () => {
                this._closeMessage(id);
            }
        };

        this.assign(msgProps, config);

        if (msgProps.fade) {
            msgProps.fadeTime = !msgProps.fadeTime ? this.props.fadeTime : msgProps.fadeTime;

            msgProps.onMouseEnter = () => {
                this._stopFade(id);
            };
            msgProps.onMouseLeave = () => {
                this._startFade(id, msgProps.fadeTime);
            };
        }
        return msgProps;
    }

    /**
     * Cancel a message fade timer.
     *
     * @param {string} msgId Message id for timer to stop
     * @private
     */
    _stopFade(msgId) {
        if (msgId in this._fadeTimers) {
            clearTimeout(this._fadeTimers[msgId]);
            delete this._fadeTimers[msgId];
        }
    }

    /**
     * Start a message fade timer.
     *
     * @param {string} msgId Message id for timer to stop
     * @param {number} fadeTime Time in milliseconds before fade
     * @private
     */
    _startFade(msgId, fadeTime) {
        this._fadeTimers[msgId] = setTimeout(() => {
            this._closeMessage(msgId);
        }, fadeTime);
    }

    /**
     * Clear all the messages.
     *
     * @private
     */
    _clearMessages() {
        this.state.messages.forEach(m => {
            this._stopFade(m.id);
        });

        this.setState({
            messages: []
        });
    }

    /**
     * Close a message.
     *
     * @param {string} msgId Id of message to close
     * @private
     */
    _closeMessage(msgId) {
        let idx = 0;
        for (idx; idx < this.state.messages.length; idx++) {
            if (this.state.messages[idx].id === msgId) break;
        }

        const messages = this.state.messages.slice(0);
        this._stopFade(msgId);

        messages.splice(idx, 1);

        this.setState({
            messages
        });
    }

    /**
     * Get the message elements.
     *
     * @returns {Array} GrowlMessage elements
     * @private
     */
    get _messageElements() {
        const elements = [];

        this.state.messages.forEach((m) => {
            const element = ( <
                GrowlMessage onClose = {
                    this._closeMessage.bind(this)
                }
                key = {
                    m.id
                } { ...m
                }
                onCloseButtonKeyDown = {
                    this._handleMessageKeyDown.bind(this)
                }
                />
            );
            elements.push( <
                CSSTransition key = {
                    m.id
                }
                classNames = {
                    {
                        enter: this.namespace('ux-growl-item-enter'),
                        enterActive: this.namespace('ux-growl-item-enter-active'),
                        exit: this.namespace('ux-growl-item-exit'),
                        exitActive: this.namespace('ux-growl-item-exit-active')
                    }
                }
                timeout = {
                    {
                        enter: 500,
                        exit: 500
                    }
                } > {
                    element
                } <
                /CSSTransition>
            );
        });

        return elements;
    }

    /**
     * Handle keyboard events for escape key on the close all button.
     *
     * @param {Event} event Browser event.
     * @private
     */
    _handleMessageKeyDown(event) {
        const messageEvent = event.target;
        const growlMessage = messageEvent.parentNode.parentNode;

        if (event.type === 'keydown' && event.key === 'Escape') {
            this._closeMessage(growlMessage.id);
        }
    }

    /**
     * Handle keyboard events for escape key on the close all button.
     *
     * @param {Event} event Browser event.
     * @private
     */
    _handleKeyDown(event) {
        const key = event.key;

        if (this.growlMain) {
            this.closeAllButton = this.growlMain.querySelector(this.namespace('.ux-growl-clear-show'));
        }

        if (event.type === 'keydown' && key === 'Escape' && this.closeAllButton === event.currentTarget) {
            this._clearMessages();
        }
    }

    /**
     * Renders the component.
     *
     * @returns {ReactElement} Rendered Growl element.
     * @private
     */
    render() {
        const {
            messages = []
        } = this.state || {};
        if (!messages.length) return false;

        return ( <
            div aria - live = 'polite'
            className = {
                this.namespace('ux-growl')
            }
            ref = {
                r => {
                    this.growlMain = r;
                }
            } >
            <
            button type = 'button'
            aria - label = 'Close all'
            className = {
                this.namespace('ux-growl-clear', messages.length >= 2 ? 'ux-growl-clear-show' : '')
            }
            onClick = {
                this._clearMessages.bind(this)
            }
            onKeyDown = {
                this._handleKeyDown.bind(this)
            } > {
                this.props.closeLabel
            } <
            /button> <
            div className = {
                this.namespace('ux-growl-messages')
            } >
            <
            TransitionGroup > {
                this._messageElements
            } <
            /TransitionGroup> <
            /div> <
            /div>
        );
    }
}

/**
 * Adds new message based on provided config options.
 *
 * @param {object}  config            Configuration
 * @param {string}  config.title      Title
 * @param {string}  config.content    Description
 * @param {string}  [config.icon]     Icon
 * @param {boolean} [config.fade]     Fade
 * @param {number}  [config.fadeTime] Fade time in milliseconds
 * @public
 */
function addGrowlMessage(config) {
    if (!global.growlInstance) {
        // eslint-disable-next-line
        try {
            console.error('No Growl instance.');
        } catch (e) {}
    } else {
        global.growlInstance._addMessage(config);
    }
}

/**
 * Adds new message based on provided config options.
 *
 * @param {object}  config            Configuration
 * @param {string}  config.title      Title
 * @param {string}  config.content    Description
 * @param {string}  [config.icon]     Icon
 * @param {boolean} [config.fade]     Fade
 * @param {number}  [config.fadeTime] Fade time in milliseconds
 * @public
 */
Growl.addGrowlMessage = Growl.addMessage = addGrowlMessage;

/**
 * PropType validation.
 *
 * @type {Object}
 * @private
 */
Growl.propTypes = {
    ...NamespaceShape,

    fadeTime: PropTypes.number.isRequired,
    closeLabel: PropTypes.node
};

/**
 * PropType defaults.
 *
 * @type {Object}
 * @private
 */
Growl.defaultProps = {
    fadeTime: 3000,
    closeLabel: '[ close all ]'
};

const namespaced = withNamespace(Growl);

/**
 * Check if Growl has an active instance.
 *
 * @returns {boolean} If an instance exists
 * @public
 */
Object.defineProperty(namespaced, 'hasInstance', {
    get() {
        return global.growlInstance !== null;
    }
});

export {
    namespaced as
    default,
    addGrowlMessage,
    Growl
};



// WEBPACK FOOTER //
// ./node_modules/@ux/growl/index.js