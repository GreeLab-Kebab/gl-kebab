import React from 'react';
import PropTypes from 'prop-types';
import Close from './tooltip-close';
import Title from './tooltip-title';
import {
    NamespaceConsumer,
    withNamespace,
    NamespaceShape
} from '@ux/namespace-component';

/**
 * Render and position the tooltip content.
 *
 * @class TooltipContent
 * @private
 */
export class TooltipContent extends NamespaceConsumer {
    constructor() {
        super(...arguments);
        this.state = {
            anchor: {
                height: 0,
                width: 0,
                top: 0,
                y: 0,
                x: 0
            }
        };
        this.wrapper = React.createRef();
        this.element = React.createRef();
    }

    /**
     * After the initial render the tooltip will need to be re-rendered for
     * correct positioning in the DOM.
     *
     * @private
     */
    componentDidMount() {
        this.on('resize', this.update);
        this.recalculateAnchor();
        if (!this.props.persistent) {
            setTimeout(() => {
                this.outsideHandler = this.outside('click', (e, handler) => {
                    this.off('click', handler);
                    this.props.close(e);
                }, this.wrapper.current);
            }, 0);
        }
    }

    /**
     * Remove the attached click event listener.
     *
     * @private
     */
    componentWillUnmount() {
        this.off('resize', this.update);
        this.off('click', this.outsideHandler);
    }

    /**
     * Provide the position and dimensions of the anchor element each time the
     * component is about to update the DOM.
     *
     * @private
     */
    componentDidUpdate() {
        this.recalculateAnchor();
    }

    /**
     * Force an update of the component, usually required to update the position.
     *
     * @private
     */
    update() {
        this.forceUpdate();
    }

    anchorsDiffer(prevAnchor, newAnchor) {
        return JSON.stringify(prevAnchor) !== JSON.stringify(newAnchor);
    }

    recalculateAnchor() {
        const {
            anchor
        } = this.props;
        const offset = this.offset(anchor);
        const bounding = anchor.getBoundingClientRect();
        const recalculatedAnchor = {
            height: bounding.height,
            width: bounding.width,
            top: bounding.top,
            y: offset.top,
            x: offset.left
        };

        const prevAnchor = this.state.anchor;
        if (this.anchorsDiffer(prevAnchor, recalculatedAnchor)) {
            this.setState({
                anchor: recalculatedAnchor
            });
        }
    }

    /**
     * Get top and left distances of the tooltip. Also return if the tooltip needs
     * to be rendered above or below the anchor.
     *
     * @returns {Array} positional values.
     * @private
     */
    get position() { // eslint-disable-line max-statements
        let left;

        //
        // Deliberately return to top left corner here so the tooltip will get the
        // maximum space to render. Having it elsewhere on the page might cause
        // the message to render with a different width causing errors in the
        // calculation afterwards.
        //
        if (!this.element.current) {
            return [{
                left: 0,
                top: 0
            }];
        }

        const {
            anchor
        } = this.state;
        const viewportWidth = window.innerWidth;
        const tooltip = this.element.current.getBoundingClientRect();
        const height = tooltip.height;
        const width = tooltip.width;
        const above = height < anchor.top;

        //
        // Determine x position on the tooltip, attempt to place it centered above
        // the anchor at first.
        //
        left = Math.floor(anchor.x + (anchor.width / 2) - (width / 2));

        const delta = above ? height : -anchor.height;
        const overflow = left + width - viewportWidth;

        const arrowMargin = {
            marginLeft: this.arrowMarginLeft
        };

        //
        // Move the tooltip further to the left if there is not enough space in
        // the viewport to the right side of the anchor. Also move the arrow the
        //
        if (overflow > 0) {
            arrowMargin.marginLeft += overflow;
            left -= overflow;
        }

        //
        // Do not allow for positioning left < 0, respect boundaries of the viewport.
        // Instead move the arrow with margin-left above the anchor.
        //
        if (left < 0) {
            arrowMargin.marginLeft += left;
            left = 0;
        }

        return [{
            top: Math.floor(anchor.y - delta),
            left: left
        }, arrowMargin, above];
    }

    /**
     * Render Tooltip content and store references to the wrapping div and the arrow.
     * Both are required for positional calculations and updates.
     *
     * @returns {ReactElement} div element with Tooltip content.
     * @private
     */
    render() {
            const props = this.props;
            const [style, arrowMargin, above] = this.position;
            const classNames = this.namespace(this.classNames([props.className, 'tooltip', 'show', {
                'bs-tooltip-bottom': above,
                'bs-tooltip-top': !above
            }]));

            //
            // Get and store the arrow's original margin-left
            //
            const arrowMarginRef = r => {
                if (!this.arrowMarginLeft && r) {
                    this.arrowMarginLeft = parseInt(window.getComputedStyle(r).getPropertyValue('margin-left'), 10) || 0;
                }
            };

            return ( <
                div className = {
                    this.namespace('spaced-group')
                }
                ref = {
                    this.wrapper
                } >
                <
                div role = 'tooltip'
                ref = {
                    this.element
                }
                className = {
                    classNames
                }
                style = {
                    style
                }
                onMouseEnter = {
                    props.onMouseEnter
                }
                onMouseLeave = {
                    props.onMouseLeave
                } >
                <
                div className = {
                    this.namespace('tooltip-arrow')
                }
                ref = {
                    arrowMarginRef
                }
                style = {
                    arrowMargin
                } > < /div> <
                div className = {
                    this.namespace('tooltip-inner')
                } > {
                    props.hideClose || < Close close = {
                        props.dismiss
                    }
                    className = {
                        this.namespace('close')
                    }
                    /> } <
                    span role = 'status'
                    aria - live = 'assertive' > {
                        props.title && < Title className = {
                            this.namespace('tooltip-title')
                        } > {
                            props.title
                        } < /Title> } {
                            props.message
                        } <
                        /span> <
                        /div> <
                        /div> <
                        /div>
                    );
                }
            }

            /**
             * Define required and types of properties.
             *
             * @enum {Object} propTypes
             * @private
             */
            TooltipContent.propTypes = {
                ...NamespaceShape,

                anchor: PropTypes.object,
                message: PropTypes.node,
                title: PropTypes.node,
                close: PropTypes.func.isRequired,
                onMouseEnter: PropTypes.func,
                onMouseLeave: PropTypes.func,
                hideClose: PropTypes.bool,
                persistent: PropTypes.bool,
                dismiss: PropTypes.func
            };

            export default withNamespace(TooltipContent);



            // WEBPACK FOOTER //
            // ./node_modules/@ux/tooltip/tooltip-content.js