'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var object = require('./object');
var uuidv5 = require('uuid/v5');
var browserHelper = require('./browser');
var cookieHelper = require('./cookie');
var authHelper = require('./auth');
var mathHelper = require('./math');
var dateHelper = require('./date');

var MY_NAMESPACE = 'd9a11081-301d-478b-98df-6511799184e5';
var DEFAULT_ENCODE = false;

function _getSeed() {
    var keys = [mathHelper.rand(), dateHelper.getDate().getMilliseconds(), browserHelper.getNavigator().userAgent.replace(/\D+/g, ''), browserHelper.getNavigator().plugins.length, browserHelper.getWindow().screen.height || '', browserHelper.getWindow().screen.width || '', browserHelper.getWindow().screen.pixelDepth || '', cookieHelper.findCookie('market'), authHelper.getCustomerId() || '', browserHelper.getDocument().referrer, browserHelper.getWindow().location.href];
    return keys.join('');
}

//
// So the code below is a REALLY hacky mess.  However, it is very short and specific to the purpose of
// converting a GUID buffer to BASE58.  Code originated from a gist at:
//
// https://gist.github.com/diafygi/90a3e80ca1c2793220e5/
//
var BASE_CHARS = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var _encode = function _encode(B, // Uint8Array raw byte input
    A // Base58 characters (i.e. "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
) {
    var d = [],
        // the array for storing the stream of base58 digits
        s = '',
        // the result string variable that will be returned
        i,
        // the iterator variable for the byte input
        j,
        // the iterator variable for the base58 digit array (d)
        c,
        // the carry amount variable that is used to overflow from the current base58 digit to the next base58 digit
        n; // a temporary placeholder variable for the current base58 digit
    // eslint-disable-next-line
    for (i in B) {
        // loop through each byte in the input stream
        j = 0; // reset the base58 digit iterator
        c = B[i]; // set the initial carry amount equal to the current byte amount
        // eslint-disable-next-line
        s += c || s.length ^ i ? '' : 1; // prepend the result string with a "1" (0 in base58) if the byte stream is zero and non-zero bytes haven't been seen yet (to ensure correct decode length)
        while (j in d || c) {
            // start looping through the digits until there are no more digits and no carry amount
            n = d[j]; // set the placeholder for the current base58 digit
            n = n ? n * 256 + c : c; // shift the current base58 one byte and add the carry amount (or just add the carry amount if this is a new digit)
            // eslint-disable-next-line
            c = n / 58 | 0; // find the new carry amount (floored integer of current digit divided by 58)
            d[j] = n % 58; // reset the current base58 digit to the remainder (the carry amount will pass on the overflow)
            j++; // iterate to the next base58 digit
        }
    }
    while (j--) {
        // since the base58 digits are backwards, loop through them in reverse order
        s += A[d[j]]; // lookup the character associated with each base58 digit
    }
    return s; // return the final base58 string
};

// This should be set by the _lock(enable) method
var _lockedGuid = void 0;

// Give a base58 encoded GUID
function createGuid(encode) {
    if (_lockedGuid !== undefined) {
        return _lockedGuid;
    }
    if ((typeof encode === 'undefined' ? 'undefined' : _typeof(encode)) !== undefined && encode || DEFAULT_ENCODE) {
        var buffer = [];
        uuidv5(_getSeed(), MY_NAMESPACE, buffer);
        return _encode(buffer, BASE_CHARS);
    }
    return uuidv5(_getSeed(), MY_NAMESPACE);
}

// For test use
function _lock(encode) {
    _lockedGuid = createGuid(encode);
    return _lockedGuid;
}

function _unlock() {
    _lockedGuid = undefined;
    return _lockedGuid;
}

var internalExports = {};
if (process.env.NODE_ENV !== 'production') {
    internalExports = {
        _lock: _lock,
        _unlock: _unlock,
        _getSeed: _getSeed
    };
}

module.exports = object.merge({
    createGuid: createGuid
}, internalExports);