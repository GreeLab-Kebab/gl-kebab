'use strict';

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var arrayHelper = require('../helper/array');
var propertyHelper = require('../helper/property');
var object = require('../helper/object');

// Validation options
var OPTIONAL = 'OPTIONAL';
var REQUIRED = 'REQUIRED';

// Resolution types
// Objects that are mapped must have a KEY present in the caller's data
// Objects that are substituted should not have a KEY present in the caller's data.
//    They are simply there to reuse an existing property definition.
//    However, all sub properties of a substituted object will be validated.
var MAPPING = 'map';
var SUBSTITUTION = 'sub';

// Find properties for a particular schema type
// * Not all schemas are broken into types
function _findSchemaByType(definitions, type) {
    for (var i = 0; i < definitions.length; i++) {
        var definition = definitions[i];
        var schemaType = definition.type;
        if (type === schemaType) {
            return definition;
        }
    }
}
// Lookup all possible types for a particular schema
// * Not all schemas are broken into types
function _parseSchemaTypes(definitions) {
    var types = [];
    if (definitions) {
        for (var i = 0; i < definitions.length; i++) {
            var definition = definitions[i];
            types.push(definition.type);
        }
    }
    return types;
}

// Using the provided Schema name, type, and version,
// fetch the proper schema definition from the metadata config.
function _findSchemaDefinition(commandSchemaDefinitions, name, type, version) {
    var schema = commandSchemaDefinitions[name];
    // Check that the schema is valid
    if (!schema) {
        if (process.env.NODE_ENV !== 'production') {
            throw 'Schema ' + name + ' is not valid.';
        }
        return undefined;
    }

    // Check that the schema type is valid
    var definition = schema;
    if (arrayHelper.isArray(definition) || type) {
        definition = _findSchemaByType(definition, type);
        if (!definition) {
            if (process.env.NODE_ENV !== 'production') {
                var types = _parseSchemaTypes(schema);
                var errorStr = 'Type \'' + type + '\' is invalid for Schema \'' + name + '\'.';
                if (types.length === 0) {
                    throw errorStr;
                } else {
                    throw errorStr + ' Possible Types are ' + types + '.';
                }
            }
            return undefined;
        }
    }

    // Check that the version is valid
    var schemaMetadata = definition[version];
    if (!schemaMetadata) {
        if (process.env.NODE_ENV !== 'production') {
            var typeStr = type ? ' / Type \'' + type + '\'' : '';
            throw 'Version \'' + version + '\' is not valid for Schema \'' + name + '\'' + typeStr + '.';
        }
        return undefined;
    }

    return schemaMetadata;
}

// Abstract Class

var BaseDefinitionBlock = function() {
    function BaseDefinitionBlock(name) {
        _classCallCheck(this, BaseDefinitionBlock);

        // Name of the property.
        // * This will be used in error logs to indicate
        // * in which definition block failed validation
        this.name = name;

        // Sub property definitions for this block.
        // * Leaf nodes (properties) will not have any sub-properties.
        this.properties = [];

        // Used in errors logs to denote the DefinitionBlock that failed validation
        this.definitionType = '';

        // By default, all properties are of type 'MAPPING' and must therefore be supplied by the caller
        this.resolutionType = MAPPING;

        // IMMUTABLE PROPERTIES - DO NOT MODIFY DURING LOAD/CLEAN/PARSE
        this.outputKeys = {};
        this.sinkList = [];
        this.commandSchemaDefinitions = {};
        this.transformMap = {};
    }

    // Parse input for this definition block


    BaseDefinitionBlock.prototype.parse = function parse(input, sink) {
        var result = new propertyHelper.PropertySet();
        for (var i = 0; i < this.properties.length; i++) {
            var property = this.properties[i];

            if (property.sinkList.length > 0) {
                if (property.sinkList.indexOf(sink) === -1) {
                    continue;
                }
            }
            // Check the caller's input for the property being validated
            var inputForProperty = input[property.name];

            // If property is a substitution, validate the property
            // using the input for this definition
            if (property.resolutionType === SUBSTITUTION) {
                inputForProperty = input;
            }

            var value = property.parse(inputForProperty, sink);

            var transforms = this._getTransforms(property.transformMap, sink);
            for (var j = 0; j < transforms.length; j++) {
                value = transforms[j](value);
            }

            if (property.resolutionType === MAPPING) {
                var outputKey = property.name;
                if (typeof sink !== 'undefined') {
                    if (property.outputKeys[sink] || property.outputKeys.ALL) {
                        outputKey = property.outputKeys[sink] || property.outputKeys.ALL;
                    }
                }
                result.set(outputKey, value);
            } else {
                result.merge(value);
            }
        }
        return result.getProperties();
    };

    // Load definitions into memory before validating


    BaseDefinitionBlock.prototype.load = function load(sink) {
        for (var i = 0; i < this.properties.length; i++) {
            var property = this.properties[i];
            property.commandSchemaDefinitions = this.commandSchemaDefinitions;
            property.load(sink);
        }
    };

    // Returns a JSON representation of our metadata and
    // the OPTIONAL/REQUIRED property for each leaf node


    BaseDefinitionBlock.prototype.stringify = function stringify() {
        var result = new propertyHelper.PropertySet();
        for (var i = 0; i < this.properties.length; i++) {
            var property = this.properties[i];
            result.merge(property.stringify());
        }
        return result.getProperties();
    };

    BaseDefinitionBlock.prototype.clean = function clean() {
        for (var i = 0; i < this.properties.length; i++) {
            this.properties[i].clean();
        }
        this.properties = [];
    };

    BaseDefinitionBlock.prototype._getTransforms = function _getTransforms(transformMap, sink) {
        var baseTransforms = transformMap.ALL || [];
        var groupTransforms = transformMap[sink] || [];
        var combined = [].concat(baseTransforms).concat(groupTransforms);
        return arrayHelper.getUnique(combined);
    };

    // Transforms the output for a definitionBlock for a particular sink


    BaseDefinitionBlock.prototype.transform = function transform(transformMap) {
        this.transformMap = transformMap;
        return this;
    };

    // Transforms the output key for a definitionBlock for a particular sink


    BaseDefinitionBlock.prototype.transformKeys = function transformKeys(outputKeys) {
        this.outputKeys = outputKeys;
        return this;
    };

    // Restricts whether the definitionBlock will be parsed for a particular sink


    BaseDefinitionBlock.prototype.sinks = function sinks(_sinks) {
        this.sinkList = _sinks;
        return this;
    };

    return BaseDefinitionBlock;
}();

// This is the root node of the tree


var SchemaDefinitionBlock = function(_BaseDefinitionBlock) {
    _inherits(SchemaDefinitionBlock, _BaseDefinitionBlock);

    function SchemaDefinitionBlock(commandSchemaDefinitions, name, type, version) {
        _classCallCheck(this, SchemaDefinitionBlock);

        var _this = _possibleConstructorReturn(this, _BaseDefinitionBlock.call(this, name));

        _this.commandSchemaDefinitions = commandSchemaDefinitions;
        _this.type = type;
        _this.version = version;
        _this.definitionType = 'Schema';

        // Fetches the schema (root) properties for the specified schema.
        _this.schema = _findSchemaDefinition(_this.commandSchemaDefinitions, _this.name, _this.type, _this.version);
        return _this;
    }

    SchemaDefinitionBlock.prototype.load = function load(sink) {
        this.properties = this.properties.concat(this.schema.data);
        _BaseDefinitionBlock.prototype.load.call(this, sink);
    };

    SchemaDefinitionBlock.prototype.parse = function parse(input, sinks) {
        // output groups can be overriden when one schema loads another schema
        // i.e. add_experiment calls add_event, but add_experiment's groups
        //  control where the output will go
        var groups = sinks || this.schema.sinks || [];
        var output = {};
        if (this.schema.data && this.schema.data.length > 0) {
            try {
                if (groups.indexOf('ALL') === -1) {
                    groups = groups.concat(['ALL']);
                }

                // Parse the input against each output group
                for (var i = 0; i < groups.length; i++) {
                    var sink = groups[i];
                    this.load(sink);
                    output[sink] = _BaseDefinitionBlock.prototype.parse.call(this, input || {}, sink);
                    this.clean();
                }
            } catch (error) {
                throw [error, '\n\nExpected Parameters:\n', this.stringify(), '\n\nReceived Parameters:\n', input];
            }
        }
        return Object.freeze(output);
    };

    return SchemaDefinitionBlock;
}(BaseDefinitionBlock);

// This is the only leaf node and represents a single field.
// * Can be a sub property of a Collection, Object, or Schema


var PropertyDefinitionBlock = function(_BaseDefinitionBlock2) {
    _inherits(PropertyDefinitionBlock, _BaseDefinitionBlock2);

    function PropertyDefinitionBlock(name) {
        _classCallCheck(this, PropertyDefinitionBlock);

        return _possibleConstructorReturn(this, _BaseDefinitionBlock2.call(this, name));
    }

    // parse input for the property block


    PropertyDefinitionBlock.prototype.parse = function parse(input) {
        // If the property is REQUIRED, ensure it was provided
        if (this.validationType === REQUIRED && !input || input === '') {
            throw 'Missing required property \'' + this.name + '\'';
        }
        return input;
    };

    // Returns key/value representation of a property config


    PropertyDefinitionBlock.prototype.stringify = function stringify() {
        var result = {};
        result[this.name] = this.validationType;
        return result;
    };

    // Sets the property definition as optional


    PropertyDefinitionBlock.prototype.optional = function optional() {
        this.validationType = OPTIONAL;
        return this;
    };

    // Sets the property definition as required.
    // An exception will be thrown if a truthy value is not provided when parsing against this blockk.


    PropertyDefinitionBlock.prototype.required = function required() {
        this.validationType = REQUIRED;
        return this;
    };

    return PropertyDefinitionBlock;
}(BaseDefinitionBlock);

// Object Definitions will pull their properties the _objectSchemaDefinition metadata config

// MAPPED objects are those that MUST be provided by the caller
// I.e. if the 'items' object is MAPPED, then the caller must provide
// {'items': {......}} and all of the REQUIRED sub properties of items

// SUBSTITUTE objects themselves do not need to be provided by the caller.
// However, all sub properties will be validated.
// I.e. if a SUBSTITUTE object 'ecomm_event' is defined then the caller would
// NOT have a key for 'ecomm_event' in their data, but they would have a key
// for all sub properties.


var ObjectDefinitionBlock = function(_BaseDefinitionBlock3) {
    _inherits(ObjectDefinitionBlock, _BaseDefinitionBlock3);

    function ObjectDefinitionBlock() {
        _classCallCheck(this, ObjectDefinitionBlock);

        // extra definitions that are defined by the mapped/substituted object
        var _this3 = _possibleConstructorReturn(this, _BaseDefinitionBlock3.call(this));

        _this3.objDefinitions = [];
        _this3.definitionType = 'Object';
        return _this3;
    }

    ObjectDefinitionBlock.prototype.load = function load(sink) {
        // Add all properties for the object from our metadata config
        this.properties = this.properties.concat(this.objDefinitions);

        // If the definition included extra properties, include them
        if (this.extraDefinitions) {
            this.properties = this.properties.concat(this.extraDefinitions);
        }
        _BaseDefinitionBlock3.prototype.load.call(this, sink);
    };

    ObjectDefinitionBlock.prototype.stringify = function stringify() {
        if (this.resolutionType === MAPPING) {
            var result = {};
            if (this.definitionType === 'Collection') {
                result[this.name] = {
                    '1...n': _BaseDefinitionBlock3.prototype.stringify.call(this)
                };
            } else {
                result[this.name] = _BaseDefinitionBlock3.prototype.stringify.call(this);
            }
            return result;
        }
        return _BaseDefinitionBlock3.prototype.stringify.call(this);
    };

    // objDefinitions should be an array of definition blocks


    ObjectDefinitionBlock.prototype.substitute = function substitute(objDefinitions) {
        this.objDefinitions = objDefinitions;
        this.resolutionType = SUBSTITUTION;
        return this;
    };

    // By mapping an inputKey, an object will be expected with the specified key.
    // For example:
    //  map('cart_product', 'product') would cause the parser to look for {'product': .....}


    ObjectDefinitionBlock.prototype.map = function map(inputKey, objDefinitions) {
        this.name = inputKey;
        this.objDefinitions = objDefinitions;
        this.resolutionType = MAPPING;
        return this;
    };

    // Extending an object/collections definitions will add additional definitionBlocks to an existing object.
    // This can be used to setup shared objects between multiple schemas, where particular definitions are extended
    // by each schema.


    ObjectDefinitionBlock.prototype.extend = function extend(extraDefinitions) {
        this.extraDefinitions = extraDefinitions;
        return this;
    };

    return ObjectDefinitionBlock;
}(BaseDefinitionBlock);

// Each element that is part of a CollectionDefinition will be validated against
// the definition's properties
// * MAPPING / SUBSTITUTE work the same for a Collection Definition as they do for an Object Definition


var CollectionDefinitionBlock = function(_ObjectDefinitionBloc) {
    _inherits(CollectionDefinitionBlock, _ObjectDefinitionBloc);

    function CollectionDefinitionBlock() {
        _classCallCheck(this, CollectionDefinitionBlock);

        var _this4 = _possibleConstructorReturn(this, _ObjectDefinitionBloc.call(this));

        _this4.definitionType = 'Collection';
        return _this4;
    }

    // Parse each object in the collection using the defined properties


    CollectionDefinitionBlock.prototype.parse = function parse(input, sink) {
        // For now, collections CANNOT be empty
        if (typeof input === 'undefined' || input.length === 0) {
            throw 'Collection \'' + this.name + '\' does not contain any elements.';
        }

        var records = [];
        for (var i = 0; i < input.length; i++) {
            records.push(_ObjectDefinitionBloc.prototype.parse.call(this, input[i], sink));
        }
        return records;
    };

    return CollectionDefinitionBlock;
}(ObjectDefinitionBlock);

var internalExports = {};
if (process.env.NODE_ENV !== 'production') {
    internalExports = {
        BaseDefinitionBlock: BaseDefinitionBlock,
        _findSchemaDefinition: _findSchemaDefinition,
        _parseSchemaTypes: _parseSchemaTypes,
        _findSchemaByType: _findSchemaByType,
        OPTIONAL: OPTIONAL,
        REQUIRED: REQUIRED
    };
}

module.exports = object.merge({
    SchemaDefinitionBlock: SchemaDefinitionBlock,
    PropertyDefinitionBlock: PropertyDefinitionBlock,
    ObjectDefinitionBlock: ObjectDefinitionBlock,
    CollectionDefinitionBlock: CollectionDefinitionBlock
}, internalExports);