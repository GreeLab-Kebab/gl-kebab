import {
    IntlProvider,
    FormattedMessage
} from 'react-intl';
import {
    Cookies,
    Delegate
} from '@ux/header-util';
import Icon from '@ux/icon';
import {
    NamespaceConsumer,
    NamespaceShape,
    withNamespace
} from '@ux/namespace-component';
import clickguard from './clickguard';
import verify, {
    refreshCookie,
    VerificationModal
} from './verify';
import React from 'react';
import PropTypes from 'prop-types';

//
// Delegation types.
//
// Impersonate: c3 representatives
// Delegate: shopper delegation
//
const impersonate = 'impersonate';
const delegate = 'delegate';

/**
 * Render exit links on the right side of each delegation bar.
 *
 * @class ExitLink
 * @api private
 */
class ActualExitLink extends NamespaceConsumer {
    /**
     * Render form to ensure a POST request to action.
     *
     * @returns {ReactElement} form element.
     * @api private
     */
    delegate() {
        const props = this.props;

        return ( <
            form method = 'post'
            action = {
                props.action
            } >
            <
            input type = 'hidden'
            name = 'secret'
            value = {
                props.secret
            }
            /> <
            button type = 'submit'
            className = {
                this.namespace('delegate-link')
            } >
            <
            Icon name = 'x' / > {
                ' ' /* deliberate space between icon and message */
            } <
            FormattedMessage id = 'PC:AppHeader:Header:AcctDelegationExitLabel' / >
            <
            /button> <
            /form>
        );
    }

    /**
     * Render a simple logout link.
     *
     * @returns {ReactElement} anchor element.
     * @api private
     */
    impersonate() {
        return ( <
            a href = {
                this.props.action
            }
            className = {
                this.namespace('delegate-link')
            } >
            <
            Icon name = 'x' / > {
                ' ' /* deliberate space between icon and message */
            } <
            FormattedMessage id = 'PC:AppHeader:Header:AcctImpersonationExitLabel' / >
            <
            /a>
        );
    }

    render() {
        return this[this.props.type]();
    }
}

/**
 * Default type and action for exit link.
 *
 * @enum {Object}
 * @api public
 */
ActualExitLink.defaultProps = {
    type: delegate
};

/**
 * Required ExitLink properties.
 *
 * @enum {Object}
 * @api public
 */
ActualExitLink.propTypes = {
    ...NamespaceShape,
    secret: PropTypes.string,
    type: PropTypes.string.isRequired,
    action: PropTypes.string
};

const ExitLink = withNamespace(ActualExitLink);

/**
 * Render delegation bar.
 *
 * @class Bar
 * @api private
 */
class ActualBar extends NamespaceConsumer {
    render() {
        const props = this.props;
        const type = props.type;

        const wrapper = this.namespace(this.classNames('delegate', {
            rep: type === impersonate
        }));

        const animated = this.namespace(this.classNames('container', {
            refreshed: props.refreshed
        }));

        if (!props.active) {
            return null;
        }

        return ( <
            div className = {
                wrapper
            } >
            <
            div className = {
                animated
            } >
            <
            div className = {
                this.namespace('pull-left')
            } >
            <
            FormattedMessage { ...props.label
            }
            /> <
            /div> <
            div className = {
                this.namespace('pull-right')
            } >
            <
            ExitLink type = {
                type
            }
            action = {
                props.action
            }
            secret = {
                props.secret
            }
            /> <
            /div> <
            /div> <
            /div>
        );
    }
}

/**
 * Require Bar properties.
 *
 * @enum {Object}
 * @api public
 */
ActualBar.propTypes = {
    ...NamespaceShape,
    refreshed: PropTypes.bool,
    active: PropTypes.bool,
    label: PropTypes.object,
    type: PropTypes.string,
    secret: PropTypes.string,
    action: PropTypes.string
};

const Bar = withNamespace(ActualBar);

let AccountDelegation;

/**
 * Render internationalized delegation bars.
 *
 * @class AccountDelegation
 * @api public
 */
export class ActualAccountDelegation extends NamespaceConsumer {
    constructor(props = {}) {
        super(...arguments);

        //
        // Setup delegate instance
        //
        this.delegate = new Delegate({
            data: props.delegate || {}
        });

        //
        // Keep track of the delegation type.
        //
        this._type = AccountDelegation.type || impersonate;
        this.state = {
            refreshed: false,
            credentialRefreshPending: false,
            showVerificationModal: false,
            impersonatedCustomerId: null
        };

        //
        // Expose the clickguard method on the constructor. This is safe since there
        // should only be one AccountDelegation Component on the page. Required
        // to get the localization data in the modal. Also ClickGuard cannot
        // be used without account delegation being active.
        //
        AccountDelegation.clickguard = clickguard.bind(clickguard, props.market, props.messages);
    }

    /**
     * Determine type of delegating from cookie. This method is made static for
     * external consumption.
     *
     * @returns {String|Array} Account delegation type.
     * @api public
     */
    static get type() {
        const auth = AccountDelegation.idp.getIdpProperty('auth');

        switch (auth) {
            case 'e2s2s':
                return [delegate, impersonate];
            case 'e2s':
                return impersonate;
            case 's2s':
                return delegate;
            case 'e2s2snpr':
                return [delegate, impersonate];
            case 'e2snpr':
                return impersonate;
            case 's2snpr':
                return delegate;
            default:
                return 'none';
        }
    }

    /**
     * Return idp cookie reference. Also attempts to fetch latest data from cookie.
     *
     * @returns {Cookie} Header utils cookies instance.
     * @api public
     */
    static get idp() {
        if (!AccountDelegation._idp) {
            AccountDelegation._idp = new Cookies();
        }

        return AccountDelegation._idp.updateIdp();
    }

    /**
     * Is delegation active?
     *
     * @returns {Boolean} Active
     * @api public
     */
    static get active() {
        return !~AccountDelegation.type.indexOf('none');
    }

    /**
     * Is the delegation of type shopper delegate.
     *
     * @returns {Boolean} shopper delegation
     * @api private
     */
    get isDelegate() {
        return !!~this._type.indexOf(delegate);
    }

    /**
     * Is the delegation of type c3 impersonation.
     *
     * @returns {Boolean} impersonation
     * @api private
     */
    get isImpersonation() {
        return !!~this._type.indexOf(impersonate);
    }

    /**
     * Label properties of delegation bar.
     *
     * @param {Boolean} [forImpersonationBar] Whether this label is for the impersonation bar
     * @returns {Object} data used by formatted message.
     * @api private
     */
    label(forImpersonationBar = false) {
        let customer, impersonator;
        if (forImpersonationBar) {
            customer = this.delegate.impersonatedCustomer || this.props.customer;
            impersonator = this.delegate;
        } else { // delegation bar
            customer = this.props.customer;
            impersonator = this.delegate.impersonatedCustomer || this.delegate;
        }
        // If we have a displayName set, use that.
        // If we have the customer's first and last name, pass those in so the i18n string handles localizing name order.
        // Otherwise, use the displayName method to handle fallbacks to fullName, username, or shopperId.
        let customerFirstName = customer.get('displayName');
        let customerLastName = '';

        if (!customerFirstName) {
            customerFirstName = customer.get('firstName');
            customerLastName = customer.get('lastName');
            if (!(customerFirstName && customerLastName)) {
                customerFirstName = customer.displayName(true);
                customerLastName = '';
            }
        }

        return {
            id: 'PC:AppHeader:Header:AcctDelegationLabel',
            values: {
                delegate: impersonator.delegateName(),
                firstName: customerFirstName,
                lastName: customerLastName
            }
        };
    }

    /**
     * Update the window title to reflect the current shopperId of the customer.
     *
     * @api private
     */
    updateTitle() {
        const {
            customer
        } = this.props;
        if (!customer || !customer.shopperId) {
            return;
        }

        let title = window.document.title;
        const i = title.indexOf(']');

        title = ~i ? title.substr(i + 2) : title;
        window.document.title = `[${ customer.shopperId }] ${ title }`;
    }

    /**
     * Verify consistency of credentials when a browser tab is focused.
     *
     * @api private
     */
    onTabFocus() {
        const self = this;
        const props = self.props;

        // Don't reset state if the dialog is already showing
        if (this.state.showVerificationModal) return;

        const credentialsValid = verify({
            customer: props.customer
        });

        this.setState({
            showVerificationModal: !credentialsValid,
            credentialRefreshPending: false,
            credentialRefreshFailed: false
        });
    }

    /**
     * Handle click on OK button in verification modal
     *
     * @api private
     */
    onVerificationModalOkClicked() {
        const props = this.props;

        this.setState({
            credentialRefreshPending: true
        });

        refreshCookie({
            customer: props.customer,
            restoreCookie: props.restoreCookie
        }, refreshed => {
            this.setState({
                showVerificationModal: !refreshed,
                credentialRefreshPending: false,
                credentialRefreshFailed: !refreshed
            });
        });
    }

    /**
     * Get data, listen to window focus and update the title if required.
     *
     * @api private
     */
    componentDidMount() {
        this.delegate.updateFromCookie();

        // If there is an intermediate customer in the delegation chain, we need to set state so we re-render the
        // impersonation bar label
        this.delegate.impersonatedCustomer && this.setState({
            impersonatedCustomerId: this.delegate.impersonatedCustomer.shopperId
        });
        this.on('focus', this.onTabFocus);

        if (this.isImpersonation) {
            this.updateTitle();
        }
    }

    /**
     * Update title if required
     *
     * @api private
     */
    componentDidUpdate() {
        if (this.isImpersonation) {
            this.updateTitle();
        }
    }

    /**
     * Remove window focus listener.
     *
     * @api private
     */
    componentWillUnmount() {
        this.off('focus', this.onTabFocus);
    }

    /**
     * Render the delegation bar.
     *
     * @returns {ReactElement} Translated delegation bar.
     * @api private
     */
    render() {
        const state = this.state;
        const props = this.props;
        const wrapper = this.namespace(this.classNames('delegation', {
            db: this.isImpersonation && this.isDelegate
        }));

        //
        // Do not render the bar if there is no active delegation.
        //
        if (!AccountDelegation.active) {
            return null;
        }

        return ( <
            IntlProvider locale = {
                props.market
            }
            messages = {
                props.messages
            } >
            <
            div className = {
                wrapper
            } >
            <
            Bar { ...props
            }
            type = {
                impersonate
            }
            refreshed = {
                state.refreshed
            }
            label = {
                this.label(true)
            }
            active = {
                this.isImpersonation
            }
            /> <
            Bar { ...props
            }
            type = {
                delegate
            }
            refreshed = {
                state.refreshed
            }
            label = {
                this.label(false)
            }
            active = {
                this.isDelegate
            }
            /> {
                this.state.showVerificationModal &&
                    <
                    VerificationModal
                displayName = {
                    props.customer.displayName()
                }
                shopperId = {
                    props.customer.shopperId
                }
                pending = {
                    this.state.credentialRefreshPending
                }
                refreshFailed = {
                    this.state.credentialRefreshFailed
                }
                onDismiss = {
                    () => {
                        this.setState({
                            showVerificationModal: false
                        });
                    }
                }
                onOk = {
                    this.onVerificationModalOkClicked.bind(this)
                }
                />
            } <
            /div> <
            /IntlProvider>
        );
    }
}

/**
 * Default type and action for exit link.
 *
 * @enum {Object}
 * @api public
 */
ActualAccountDelegation.defaultProps = {
    action: 'https://sso.godaddy.com/cookie/switchback/',
    restoreCookie: 'https://sso.godaddy.com/cookie/restore/'
};

/**
 * Allowed delegation values.
 *
 * @enum {Object}
 * @api public
 */
ActualAccountDelegation.propTypes = {
    ...NamespaceShape,
    customer: PropTypes.object,
    delegate: PropTypes.object,
    secret: PropTypes.string,
    restoreCookie: PropTypes.string,
    market: PropTypes.string.isRequired,
    messages: PropTypes.object.isRequired,
    action: PropTypes.string
};

AccountDelegation = withNamespace(ActualAccountDelegation);
// Need to manually copy this over since `hoist-non-react-statics` ignores this static property.
Object.defineProperty(AccountDelegation,
    'type',
    Object.getOwnPropertyDescriptor(ActualAccountDelegation, 'type'));
export default AccountDelegation;