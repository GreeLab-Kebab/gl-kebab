import {
    NamespaceConsumer,
    NamespaceShape,
    withNamespace
} from '@ux/namespace-component';
import React from 'react';
import PropTypes from 'prop-types';
import {
    toggle
} from 'toggler';
import Tray from './tray';
import TrayButton from './tray-button';
import TrayClose from './tray-close';

const isDataAttr = /^data-[a-zA-Z0-9-]+$/;

/**
 * Tray menu component.
 *
 * This is the primary component for using the tray menu. It defines and renders
 * the button and establishes click handlers for toggling open the menu.
 *
 * @class TrayMenu
 * @public
 */
export class TrayMenu extends NamespaceConsumer {
    constructor() {
        super(...arguments);

        const {
            open,
            onToggle,
            trayAlignment
        } = this.props;
        this.state = {
            ...this.state,
            open: open || false,
            alignment: trayAlignment
        };

        this.close = this.close.bind(this);
        this.toggle = toggle(this, 'open', () => {
            if (typeof onToggle === 'function') {
                onToggle(this.state.open);
            }
        });

        this.handleKeyDown = this.handleKeyDown.bind(this);
    }

    /**
     * Hide the dropdown if clicks are outside the Tray itself.
     *
     * @api private
     */
    componentDidMount() {
        this.outside('click', this.close, this.wrapperDiv);
        this.on('keydown', this.handleKeyDown);
        this.outside('focusin', this.close, this.wrapperDiv);
        if (!this.props.fullwidth && !this.state.alignment) {
            const alignment = this.getAlignment();
            this.setState({ ...this.state,
                alignment
            });
        }
    }

    /**
     * Remove the attached click event listener.
     *
     * @api private
     */
    componentWillUnmount() {
        this.off('click', this.close);
        this.off('keydown', this.handleKeyDown);
        this.off('focusin', this.close);
    }

    componentDidUpdate(prevProps, prevState) {
        const {
            open
        } = this.state;
        const {
            trayAlignment
        } = this.props;

        if (trayAlignment && trayAlignment !== prevProps.trayAlignment) {
            this.setState({
                ...this.state,
                alignment: trayAlignment
            });
        } else if (open && open !== prevState.open) {
            const alignment = this.getAlignment();
            if (alignment !== prevState.alignment) {
                this.setState({ ...this.state,
                    alignment
                });
            }
        }
    }


    /**
     * Listen for the ESC key event.
     * @param {object} e the event object sent from the browser
     * @api private
     */
    handleKeyDown(e) {
        if (e.key && (e.key === 'Escape' || e.key === 'Esc')) {
            e.preventDefault();
            this.close();
        }
    }

    /**
     * Open the tray.
     *
     * @api public
     */
    get show() {
        if (!this.state.open) {
            this.toggle();
        }

        // This is a getter because it has to override `this.show` in `@ux/component` which is also a getter for some
        // reason. We can have the debate later about whether we should ship a breaking change here to rename this and make
        // it a method as it should be. But for now, let's at least make this getter return `undefined` since getters have
        // to return _something_
        return void 0;
    }

    /**
     * Close the tray.
     *
     * @api public
     */
    close() {
        if (this.state.open) {
            this.toggle();
        }
    }

    /**
     * Fetches all element bounds to necessary calculations of display
     * @private
     * @returns {object} element bounds
     */
    getElementBounds() {
        // Viewport Bounds
        const viewportBounds = {
            x: window.pageXOffset,
            y: window.pageYOffset,
            width: window.innerWidth,
            height: window.innerHeight
        };

        // Wrapper Div for Tray Menu
        const wrapperDivBounds = this.wrapperDiv && this.wrapperDiv.getBoundingClientRect();

        // Tray Menu Element
        const menuBounds = this.trayMenuElement &&
            this.trayMenuElement.wrapper &&
            this.trayMenuElement.wrapper.getBoundingClientRect();

        return {
            viewportBounds,
            wrapperDivBounds,
            menuBounds
        };
    }

    /**
     * Compute horizontal spacing for menu and determine whether to show aligned left or right to the tray menu.
     *
     * @returns {String|Boolean} The direction of alignment. False if neither left nor right.
     * @private
     */
    getAlignment() {
        let alignment = null;
        if (!this.props.fullwidth) {
            const {
                wrapperDivBounds,
                menuBounds,
                viewportBounds
            } = this.getElementBounds();
            if (wrapperDivBounds && menuBounds) {
                const right = wrapperDivBounds.left + viewportBounds.x - window.document.documentElement.clientLeft + menuBounds.width;
                // The element needs to be right aligned if it's too close or outside the bounds of the viewport
                // and it it small enough to fit inside a viewport, if it's too big we'll default to left
                if (viewportBounds.width - right < 10 && menuBounds.width < viewportBounds.width) {
                    alignment = 'right';
                } else {
                    // otherwise align left
                    alignment = 'left';
                }
            }
        }
        return alignment;
    }

    /**
     * Collects `data-*` attributes from the given object and returns them in a new object
     *
     * @param  {Object} obj The object from which data attributes are collected
     * @returns {Object} Thec colleciton of data attributes
     * @api private
     */
    collectDataAttrs(obj) {
        return Object.keys(obj).reduce((accumulator, key) => {
            if (isDataAttr.test(key)) {
                accumulator[key] = obj[key];
            }
            return accumulator;
        }, {});
    }

    /**
     * Render the tray menu
     *
     * @returns {React.ReactElement} react element
     * @api public
     */
    render() {
        const props = this.props;
        const dataAttrs = this.collectDataAttrs(props);
        const {
            open,
            alignment
        } = this.state;
        let alignMenuClass;
        if (!props.fullwidth) {
            alignMenuClass = (alignment === 'left') ? 'tray-align-left' : 'tray-align-right';
        }
        // Don't namespace the incoming `props.className` -- the parent component should do so
        const wrapperClassNames = this.classNames(this.namespace(
            this.classNames('tray-menu', {
                open
            })
        ), props.className);

        const trayClassNames = this.classNames(this.namespace(
            this.classNames(alignMenuClass, {
                'tray-fullwidth': props.fullwidth
            })));

        return ( <
            div className = {
                wrapperClassNames
            }
            ref = {
                r => {
                    this.wrapperDiv = r;
                }
            } >
            <
            TrayButton type = {
                props.type
            }
            aria - expanded = {
                open
            }
            ariaLabel = {
                props.ariaLabel
            }
            showOpenCaret = {
                props.showOpenCaret
            }
            onClick = {
                evt => {
                    this.toggle(evt);
                }
            }
            dataAttrs = {
                dataAttrs
            }
            traySpanClass = {
                props.traySpanClass
            } > {
                props.name
            } <
            /TrayButton> <
            Tray className = {
                trayClassNames
            }
            ref = {
                r => {
                    this.trayMenuElement = r;
                }
            } > {
                props.showClose && < TrayClose onClick = {
                    evt => {
                        this.toggle(evt);
                    }
                }
                /> } {
                    props.children
                } <
                /Tray> <
                /div>
            );
        }
    }

    /**
     * Property definitions.
     *
     * @type {Object}
     * @public
     */
    TrayMenu.propTypes = {
        ...NamespaceShape,
        // Arbitrary data-* tags can be passed along, e.g. data-mix, data-eid, ...
        // 'data-*': PropTypes.string,
        ariaLabel: PropTypes.string,
        className: PropTypes.string,
        type: PropTypes.string,
        name: PropTypes.node.isRequired,
        children: PropTypes.node.isRequired,
        showOpenCaret: PropTypes.bool,
        open: PropTypes.bool,
        onToggle: PropTypes.func,
        fullwidth: PropTypes.bool,
        showClose: PropTypes.bool,
        traySpanClass: PropTypes.string,
        trayAlignment: PropTypes.oneOf(['left', 'right'])
    };

    /**
     * Default property values.
     *
     * @type {Object}
     * @public
     */
    TrayMenu.defaultProps = {
        fullwidth: true,
        showClose: true,
        type: 'base',
        showOpenCaret: false
    };

    export default withNamespace(TrayMenu);